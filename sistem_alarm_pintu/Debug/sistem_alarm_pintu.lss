
sistem_alarm_pintu.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00003706  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000b2  00802000  00003706  0000379a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000302  008020b2  008020b2  0000384c  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  0000384c  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000044  00000000  00000000  000038a8  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000005f8  00000000  00000000  000038ec  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00012a6c  00000000  00000000  00003ee4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000057bf  00000000  00000000  00016950  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000a090  00000000  00000000  0001c10f  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001330  00000000  00000000  000261a0  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0003965b  00000000  00000000  000274d0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00009639  00000000  00000000  00060b2b  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000007a0  00000000  00000000  0006a164  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  0000c89b  00000000  00000000  0006a904  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	50 c2       	rjmp	.+1184   	; 0x4a2 <__ctors_end>
       2:	00 00       	nop
       4:	6f c2       	rjmp	.+1246   	; 0x4e4 <__bad_interrupt>
       6:	00 00       	nop
       8:	6d c2       	rjmp	.+1242   	; 0x4e4 <__bad_interrupt>
       a:	00 00       	nop
       c:	6b c2       	rjmp	.+1238   	; 0x4e4 <__bad_interrupt>
       e:	00 00       	nop
      10:	69 c2       	rjmp	.+1234   	; 0x4e4 <__bad_interrupt>
      12:	00 00       	nop
      14:	67 c2       	rjmp	.+1230   	; 0x4e4 <__bad_interrupt>
      16:	00 00       	nop
      18:	65 c2       	rjmp	.+1226   	; 0x4e4 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	63 c2       	rjmp	.+1222   	; 0x4e4 <__bad_interrupt>
      1e:	00 00       	nop
      20:	61 c2       	rjmp	.+1218   	; 0x4e4 <__bad_interrupt>
      22:	00 00       	nop
      24:	5f c2       	rjmp	.+1214   	; 0x4e4 <__bad_interrupt>
      26:	00 00       	nop
      28:	5d c2       	rjmp	.+1210   	; 0x4e4 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	5b c2       	rjmp	.+1206   	; 0x4e4 <__bad_interrupt>
      2e:	00 00       	nop
      30:	59 c2       	rjmp	.+1202   	; 0x4e4 <__bad_interrupt>
      32:	00 00       	nop
      34:	57 c2       	rjmp	.+1198   	; 0x4e4 <__bad_interrupt>
      36:	00 00       	nop
      38:	0c 94 89 0b 	jmp	0x1712	; 0x1712 <__vector_14>
      3c:	53 c2       	rjmp	.+1190   	; 0x4e4 <__bad_interrupt>
      3e:	00 00       	nop
      40:	51 c2       	rjmp	.+1186   	; 0x4e4 <__bad_interrupt>
      42:	00 00       	nop
      44:	4f c2       	rjmp	.+1182   	; 0x4e4 <__bad_interrupt>
      46:	00 00       	nop
      48:	4d c2       	rjmp	.+1178   	; 0x4e4 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	4b c2       	rjmp	.+1174   	; 0x4e4 <__bad_interrupt>
      4e:	00 00       	nop
      50:	49 c2       	rjmp	.+1170   	; 0x4e4 <__bad_interrupt>
      52:	00 00       	nop
      54:	47 c2       	rjmp	.+1166   	; 0x4e4 <__bad_interrupt>
      56:	00 00       	nop
      58:	45 c2       	rjmp	.+1162   	; 0x4e4 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	43 c2       	rjmp	.+1158   	; 0x4e4 <__bad_interrupt>
      5e:	00 00       	nop
      60:	41 c2       	rjmp	.+1154   	; 0x4e4 <__bad_interrupt>
      62:	00 00       	nop
      64:	3f c2       	rjmp	.+1150   	; 0x4e4 <__bad_interrupt>
      66:	00 00       	nop
      68:	3d c2       	rjmp	.+1146   	; 0x4e4 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	3b c2       	rjmp	.+1142   	; 0x4e4 <__bad_interrupt>
      6e:	00 00       	nop
      70:	39 c2       	rjmp	.+1138   	; 0x4e4 <__bad_interrupt>
      72:	00 00       	nop
      74:	37 c2       	rjmp	.+1134   	; 0x4e4 <__bad_interrupt>
      76:	00 00       	nop
      78:	35 c2       	rjmp	.+1130   	; 0x4e4 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	33 c2       	rjmp	.+1126   	; 0x4e4 <__bad_interrupt>
      7e:	00 00       	nop
      80:	31 c2       	rjmp	.+1122   	; 0x4e4 <__bad_interrupt>
      82:	00 00       	nop
      84:	2f c2       	rjmp	.+1118   	; 0x4e4 <__bad_interrupt>
      86:	00 00       	nop
      88:	2d c2       	rjmp	.+1114   	; 0x4e4 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	2b c2       	rjmp	.+1110   	; 0x4e4 <__bad_interrupt>
      8e:	00 00       	nop
      90:	29 c2       	rjmp	.+1106   	; 0x4e4 <__bad_interrupt>
      92:	00 00       	nop
      94:	27 c2       	rjmp	.+1102   	; 0x4e4 <__bad_interrupt>
      96:	00 00       	nop
      98:	25 c2       	rjmp	.+1098   	; 0x4e4 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	23 c2       	rjmp	.+1094   	; 0x4e4 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	21 c2       	rjmp	.+1090   	; 0x4e4 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	1f c2       	rjmp	.+1086   	; 0x4e4 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	1d c2       	rjmp	.+1082   	; 0x4e4 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	1b c2       	rjmp	.+1078   	; 0x4e4 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	19 c2       	rjmp	.+1074   	; 0x4e4 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	17 c2       	rjmp	.+1070   	; 0x4e4 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	15 c2       	rjmp	.+1066   	; 0x4e4 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	13 c2       	rjmp	.+1062   	; 0x4e4 <__bad_interrupt>
      be:	00 00       	nop
      c0:	11 c2       	rjmp	.+1058   	; 0x4e4 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	0f c2       	rjmp	.+1054   	; 0x4e4 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	0d c2       	rjmp	.+1050   	; 0x4e4 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	0b c2       	rjmp	.+1046   	; 0x4e4 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	09 c2       	rjmp	.+1042   	; 0x4e4 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	07 c2       	rjmp	.+1038   	; 0x4e4 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	05 c2       	rjmp	.+1034   	; 0x4e4 <__bad_interrupt>
      da:	00 00       	nop
      dc:	03 c2       	rjmp	.+1030   	; 0x4e4 <__bad_interrupt>
      de:	00 00       	nop
      e0:	01 c2       	rjmp	.+1026   	; 0x4e4 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	ff c1       	rjmp	.+1022   	; 0x4e4 <__bad_interrupt>
      e6:	00 00       	nop
      e8:	fd c1       	rjmp	.+1018   	; 0x4e4 <__bad_interrupt>
      ea:	00 00       	nop
      ec:	fb c1       	rjmp	.+1014   	; 0x4e4 <__bad_interrupt>
      ee:	00 00       	nop
      f0:	f9 c1       	rjmp	.+1010   	; 0x4e4 <__bad_interrupt>
      f2:	00 00       	nop
      f4:	f7 c1       	rjmp	.+1006   	; 0x4e4 <__bad_interrupt>
      f6:	00 00       	nop
      f8:	f5 c1       	rjmp	.+1002   	; 0x4e4 <__bad_interrupt>
      fa:	00 00       	nop
      fc:	f3 c1       	rjmp	.+998    	; 0x4e4 <__bad_interrupt>
      fe:	00 00       	nop
     100:	f1 c1       	rjmp	.+994    	; 0x4e4 <__bad_interrupt>
     102:	00 00       	nop
     104:	ef c1       	rjmp	.+990    	; 0x4e4 <__bad_interrupt>
     106:	00 00       	nop
     108:	ed c1       	rjmp	.+986    	; 0x4e4 <__bad_interrupt>
     10a:	00 00       	nop
     10c:	eb c1       	rjmp	.+982    	; 0x4e4 <__bad_interrupt>
     10e:	00 00       	nop
     110:	e9 c1       	rjmp	.+978    	; 0x4e4 <__bad_interrupt>
     112:	00 00       	nop
     114:	e7 c1       	rjmp	.+974    	; 0x4e4 <__bad_interrupt>
     116:	00 00       	nop
     118:	e5 c1       	rjmp	.+970    	; 0x4e4 <__bad_interrupt>
     11a:	00 00       	nop
     11c:	e3 c1       	rjmp	.+966    	; 0x4e4 <__bad_interrupt>
     11e:	00 00       	nop
     120:	e1 c1       	rjmp	.+962    	; 0x4e4 <__bad_interrupt>
     122:	00 00       	nop
     124:	df c1       	rjmp	.+958    	; 0x4e4 <__bad_interrupt>
     126:	00 00       	nop
     128:	dd c1       	rjmp	.+954    	; 0x4e4 <__bad_interrupt>
     12a:	00 00       	nop
     12c:	db c1       	rjmp	.+950    	; 0x4e4 <__bad_interrupt>
     12e:	00 00       	nop
     130:	d9 c1       	rjmp	.+946    	; 0x4e4 <__bad_interrupt>
     132:	00 00       	nop
     134:	d7 c1       	rjmp	.+942    	; 0x4e4 <__bad_interrupt>
     136:	00 00       	nop
     138:	d5 c1       	rjmp	.+938    	; 0x4e4 <__bad_interrupt>
     13a:	00 00       	nop
     13c:	d3 c1       	rjmp	.+934    	; 0x4e4 <__bad_interrupt>
     13e:	00 00       	nop
     140:	d1 c1       	rjmp	.+930    	; 0x4e4 <__bad_interrupt>
     142:	00 00       	nop
     144:	cf c1       	rjmp	.+926    	; 0x4e4 <__bad_interrupt>
     146:	00 00       	nop
     148:	cd c1       	rjmp	.+922    	; 0x4e4 <__bad_interrupt>
     14a:	00 00       	nop
     14c:	cb c1       	rjmp	.+918    	; 0x4e4 <__bad_interrupt>
     14e:	00 00       	nop
     150:	c9 c1       	rjmp	.+914    	; 0x4e4 <__bad_interrupt>
     152:	00 00       	nop
     154:	c7 c1       	rjmp	.+910    	; 0x4e4 <__bad_interrupt>
     156:	00 00       	nop
     158:	c5 c1       	rjmp	.+906    	; 0x4e4 <__bad_interrupt>
     15a:	00 00       	nop
     15c:	c3 c1       	rjmp	.+902    	; 0x4e4 <__bad_interrupt>
     15e:	00 00       	nop
     160:	c1 c1       	rjmp	.+898    	; 0x4e4 <__bad_interrupt>
     162:	00 00       	nop
     164:	bf c1       	rjmp	.+894    	; 0x4e4 <__bad_interrupt>
     166:	00 00       	nop
     168:	bd c1       	rjmp	.+890    	; 0x4e4 <__bad_interrupt>
     16a:	00 00       	nop
     16c:	bb c1       	rjmp	.+886    	; 0x4e4 <__bad_interrupt>
     16e:	00 00       	nop
     170:	b9 c1       	rjmp	.+882    	; 0x4e4 <__bad_interrupt>
     172:	00 00       	nop
     174:	b7 c1       	rjmp	.+878    	; 0x4e4 <__bad_interrupt>
     176:	00 00       	nop
     178:	b5 c1       	rjmp	.+874    	; 0x4e4 <__bad_interrupt>
     17a:	00 00       	nop
     17c:	b3 c1       	rjmp	.+870    	; 0x4e4 <__bad_interrupt>
     17e:	00 00       	nop
     180:	b1 c1       	rjmp	.+866    	; 0x4e4 <__bad_interrupt>
     182:	00 00       	nop
     184:	af c1       	rjmp	.+862    	; 0x4e4 <__bad_interrupt>
     186:	00 00       	nop
     188:	ad c1       	rjmp	.+858    	; 0x4e4 <__bad_interrupt>
     18a:	00 00       	nop
     18c:	ab c1       	rjmp	.+854    	; 0x4e4 <__bad_interrupt>
     18e:	00 00       	nop
     190:	a9 c1       	rjmp	.+850    	; 0x4e4 <__bad_interrupt>
     192:	00 00       	nop
     194:	a7 c1       	rjmp	.+846    	; 0x4e4 <__bad_interrupt>
     196:	00 00       	nop
     198:	a5 c1       	rjmp	.+842    	; 0x4e4 <__bad_interrupt>
     19a:	00 00       	nop
     19c:	a3 c1       	rjmp	.+838    	; 0x4e4 <__bad_interrupt>
     19e:	00 00       	nop
     1a0:	a1 c1       	rjmp	.+834    	; 0x4e4 <__bad_interrupt>
     1a2:	00 00       	nop
     1a4:	9f c1       	rjmp	.+830    	; 0x4e4 <__bad_interrupt>
     1a6:	00 00       	nop
     1a8:	9d c1       	rjmp	.+826    	; 0x4e4 <__bad_interrupt>
     1aa:	00 00       	nop
     1ac:	9b c1       	rjmp	.+822    	; 0x4e4 <__bad_interrupt>
     1ae:	00 00       	nop
     1b0:	99 c1       	rjmp	.+818    	; 0x4e4 <__bad_interrupt>
     1b2:	00 00       	nop
     1b4:	97 c1       	rjmp	.+814    	; 0x4e4 <__bad_interrupt>
     1b6:	00 00       	nop
     1b8:	95 c1       	rjmp	.+810    	; 0x4e4 <__bad_interrupt>
     1ba:	00 00       	nop
     1bc:	93 c1       	rjmp	.+806    	; 0x4e4 <__bad_interrupt>
     1be:	00 00       	nop
     1c0:	91 c1       	rjmp	.+802    	; 0x4e4 <__bad_interrupt>
     1c2:	00 00       	nop
     1c4:	8f c1       	rjmp	.+798    	; 0x4e4 <__bad_interrupt>
     1c6:	00 00       	nop
     1c8:	8d c1       	rjmp	.+794    	; 0x4e4 <__bad_interrupt>
     1ca:	00 00       	nop
     1cc:	8b c1       	rjmp	.+790    	; 0x4e4 <__bad_interrupt>
     1ce:	00 00       	nop
     1d0:	89 c1       	rjmp	.+786    	; 0x4e4 <__bad_interrupt>
     1d2:	00 00       	nop
     1d4:	87 c1       	rjmp	.+782    	; 0x4e4 <__bad_interrupt>
     1d6:	00 00       	nop
     1d8:	85 c1       	rjmp	.+778    	; 0x4e4 <__bad_interrupt>
     1da:	00 00       	nop
     1dc:	83 c1       	rjmp	.+774    	; 0x4e4 <__bad_interrupt>
     1de:	00 00       	nop
     1e0:	81 c1       	rjmp	.+770    	; 0x4e4 <__bad_interrupt>
     1e2:	00 00       	nop
     1e4:	7f c1       	rjmp	.+766    	; 0x4e4 <__bad_interrupt>
     1e6:	00 00       	nop
     1e8:	7d c1       	rjmp	.+762    	; 0x4e4 <__bad_interrupt>
     1ea:	00 00       	nop
     1ec:	7b c1       	rjmp	.+758    	; 0x4e4 <__bad_interrupt>
     1ee:	00 00       	nop
     1f0:	79 c1       	rjmp	.+754    	; 0x4e4 <__bad_interrupt>
     1f2:	00 00       	nop
     1f4:	77 c1       	rjmp	.+750    	; 0x4e4 <__bad_interrupt>
     1f6:	00 00       	nop
     1f8:	75 c1       	rjmp	.+746    	; 0x4e4 <__bad_interrupt>
     1fa:	00 00       	nop
     1fc:	50 14       	cp	r5, r0
     1fe:	50 14       	cp	r5, r0
     200:	50 14       	cp	r5, r0
     202:	86 14       	cp	r8, r6
     204:	76 14       	cp	r7, r6
     206:	83 14       	cp	r8, r3
     208:	50 14       	cp	r5, r0
     20a:	50 14       	cp	r5, r0
     20c:	86 14       	cp	r8, r6
     20e:	76 14       	cp	r7, r6

00000210 <__trampolines_end>:
     210:	00 00       	nop
     212:	00 00       	nop
     214:	00 00       	nop
     216:	00 20       	and	r0, r0
     218:	20 20       	and	r2, r0
     21a:	20 20       	and	r2, r0
     21c:	00 20       	and	r0, r0
     21e:	50 50       	subi	r21, 0x00	; 0
     220:	50 00       	.word	0x0050	; ????
     222:	00 00       	nop
     224:	00 50       	subi	r16, 0x00	; 0
     226:	50 f8       	bld	r5, 0
     228:	50 f8       	bld	r5, 0
     22a:	50 50       	subi	r21, 0x00	; 0
     22c:	20 78       	andi	r18, 0x80	; 128
     22e:	a0 70       	andi	r26, 0x00	; 0
     230:	28 f0       	brcs	.+10     	; 0x23c <__trampolines_end+0x2c>
     232:	20 c0       	rjmp	.+64     	; 0x274 <__trampolines_end+0x64>
     234:	c8 10       	cpse	r12, r8
     236:	20 40       	sbci	r18, 0x00	; 0
     238:	98 18       	sub	r9, r8
     23a:	60 90 a0 40 	lds	r6, 0x40A0	; 0x8040a0 <__bss_end+0x1cec>
     23e:	a8 90       	.word	0x90a8	; ????
     240:	68 60       	ori	r22, 0x08	; 8
     242:	20 40       	sbci	r18, 0x00	; 0
     244:	00 00       	nop
     246:	00 00       	nop
     248:	10 20       	and	r1, r0
     24a:	40 40       	sbci	r20, 0x00	; 0
     24c:	40 20       	and	r4, r0
     24e:	10 40       	sbci	r17, 0x00	; 0
     250:	20 10       	cpse	r2, r0
     252:	10 10       	cpse	r1, r0
     254:	20 40       	sbci	r18, 0x00	; 0
     256:	00 50       	subi	r16, 0x00	; 0
     258:	20 f8       	bld	r2, 0
     25a:	20 50       	subi	r18, 0x00	; 0
     25c:	00 00       	nop
     25e:	20 20       	and	r2, r0
     260:	f8 20       	and	r15, r8
     262:	20 00       	.word	0x0020	; ????
     264:	00 00       	nop
     266:	00 00       	nop
     268:	60 20       	and	r6, r0
     26a:	40 00       	.word	0x0040	; ????
     26c:	00 00       	nop
     26e:	f8 00       	.word	0x00f8	; ????
     270:	00 00       	nop
     272:	00 00       	nop
     274:	00 00       	nop
     276:	00 60       	ori	r16, 0x00	; 0
     278:	60 00       	.word	0x0060	; ????
     27a:	08 10       	cpse	r0, r8
     27c:	20 40       	sbci	r18, 0x00	; 0
     27e:	80 00       	.word	0x0080	; ????
     280:	70 88       	ldd	r7, Z+16	; 0x10
     282:	98 a8       	ldd	r9, Y+48	; 0x30
     284:	c8 88       	ldd	r12, Y+16	; 0x10
     286:	70 20       	and	r7, r0
     288:	60 20       	and	r6, r0
     28a:	20 20       	and	r2, r0
     28c:	20 70       	andi	r18, 0x00	; 0
     28e:	70 88       	ldd	r7, Z+16	; 0x10
     290:	08 10       	cpse	r0, r8
     292:	20 40       	sbci	r18, 0x00	; 0
     294:	f8 f8       	.word	0xf8f8	; ????
     296:	10 20       	and	r1, r0
     298:	10 08       	sbc	r1, r0
     29a:	88 70       	andi	r24, 0x08	; 8
     29c:	10 30       	cpi	r17, 0x00	; 0
     29e:	50 90 f8 10 	lds	r5, 0x10F8	; 0x8010f8 <__TEXT_REGION_LENGTH__+0x7010f8>
     2a2:	10 f8       	bld	r1, 0
     2a4:	80 f0       	brcs	.+32     	; 0x2c6 <__trampolines_end+0xb6>
     2a6:	08 08       	sbc	r0, r8
     2a8:	88 70       	andi	r24, 0x08	; 8
     2aa:	30 40       	sbci	r19, 0x00	; 0
     2ac:	80 f0       	brcs	.+32     	; 0x2ce <__trampolines_end+0xbe>
     2ae:	88 88       	ldd	r8, Y+16	; 0x10
     2b0:	70 f8       	bld	r7, 0
     2b2:	08 10       	cpse	r0, r8
     2b4:	20 40       	sbci	r18, 0x00	; 0
     2b6:	40 40       	sbci	r20, 0x00	; 0
     2b8:	70 88       	ldd	r7, Z+16	; 0x10
     2ba:	88 70       	andi	r24, 0x08	; 8
     2bc:	88 88       	ldd	r8, Y+16	; 0x10
     2be:	70 70       	andi	r23, 0x00	; 0
     2c0:	88 88       	ldd	r8, Y+16	; 0x10
     2c2:	78 08       	sbc	r7, r8
     2c4:	10 60       	ori	r17, 0x00	; 0
     2c6:	00 60       	ori	r16, 0x00	; 0
     2c8:	60 00       	.word	0x0060	; ????
     2ca:	60 60       	ori	r22, 0x00	; 0
     2cc:	00 00       	nop
     2ce:	60 60       	ori	r22, 0x00	; 0
     2d0:	00 60       	ori	r16, 0x00	; 0
     2d2:	20 40       	sbci	r18, 0x00	; 0
     2d4:	08 10       	cpse	r0, r8
     2d6:	20 40       	sbci	r18, 0x00	; 0
     2d8:	20 10       	cpse	r2, r0
     2da:	08 00       	.word	0x0008	; ????
     2dc:	00 f8       	bld	r0, 0
     2de:	00 f8       	bld	r0, 0
     2e0:	00 00       	nop
     2e2:	80 40       	sbci	r24, 0x00	; 0
     2e4:	20 10       	cpse	r2, r0
     2e6:	20 40       	sbci	r18, 0x00	; 0
     2e8:	80 70       	andi	r24, 0x00	; 0
     2ea:	88 08       	sbc	r8, r8
     2ec:	10 20       	and	r1, r0
     2ee:	00 20       	and	r0, r0
     2f0:	70 88       	ldd	r7, Z+16	; 0x10
     2f2:	08 68       	ori	r16, 0x88	; 136
     2f4:	a8 a8       	ldd	r10, Y+48	; 0x30
     2f6:	70 70       	andi	r23, 0x00	; 0
     2f8:	88 88       	ldd	r8, Y+16	; 0x10
     2fa:	88 f8       	.word	0xf888	; ????
     2fc:	88 88       	ldd	r8, Y+16	; 0x10
     2fe:	f0 88       	ldd	r15, Z+16	; 0x10
     300:	88 f0       	brcs	.+34     	; 0x324 <__trampolines_end+0x114>
     302:	88 88       	ldd	r8, Y+16	; 0x10
     304:	f0 70       	andi	r31, 0x00	; 0
     306:	88 80       	ld	r8, Y
     308:	80 80       	ld	r8, Z
     30a:	88 70       	andi	r24, 0x08	; 8
     30c:	e0 90 88 88 	lds	r14, 0x8888	; 0x808888 <__bss_end+0x64d4>
     310:	88 90       	.word	0x9088	; ????
     312:	e0 f8       	bld	r14, 0
     314:	80 80       	ld	r8, Z
     316:	f0 80       	ld	r15, Z
     318:	80 f8       	bld	r8, 0
     31a:	f8 80       	ld	r15, Y
     31c:	80 e0       	ldi	r24, 0x00	; 0
     31e:	80 80       	ld	r8, Z
     320:	80 70       	andi	r24, 0x00	; 0
     322:	88 80       	ld	r8, Y
     324:	80 98       	cbi	0x10, 0	; 16
     326:	88 70       	andi	r24, 0x08	; 8
     328:	88 88       	ldd	r8, Y+16	; 0x10
     32a:	88 f8       	.word	0xf888	; ????
     32c:	88 88       	ldd	r8, Y+16	; 0x10
     32e:	88 70       	andi	r24, 0x08	; 8
     330:	20 20       	and	r2, r0
     332:	20 20       	and	r2, r0
     334:	20 70       	andi	r18, 0x00	; 0
     336:	38 10       	cpse	r3, r8
     338:	10 10       	cpse	r1, r0
     33a:	10 90 60 88 	lds	r1, 0x8860	; 0x808860 <__bss_end+0x64ac>
     33e:	90 a0       	ldd	r9, Z+32	; 0x20
     340:	c0 a0       	ldd	r12, Z+32	; 0x20
     342:	90 88       	ldd	r9, Z+16	; 0x10
     344:	80 80       	ld	r8, Z
     346:	80 80       	ld	r8, Z
     348:	80 80       	ld	r8, Z
     34a:	f8 88       	ldd	r15, Y+16	; 0x10
     34c:	d8 a8       	ldd	r13, Y+48	; 0x30
     34e:	88 88       	ldd	r8, Y+16	; 0x10
     350:	88 88       	ldd	r8, Y+16	; 0x10
     352:	88 88       	ldd	r8, Y+16	; 0x10
     354:	c8 a8       	ldd	r12, Y+48	; 0x30
     356:	98 88       	ldd	r9, Y+16	; 0x10
     358:	88 70       	andi	r24, 0x08	; 8
     35a:	88 88       	ldd	r8, Y+16	; 0x10
     35c:	88 88       	ldd	r8, Y+16	; 0x10
     35e:	88 70       	andi	r24, 0x08	; 8
     360:	f0 88       	ldd	r15, Z+16	; 0x10
     362:	88 f0       	brcs	.+34     	; 0x386 <__trampolines_end+0x176>
     364:	80 80       	ld	r8, Z
     366:	80 70       	andi	r24, 0x00	; 0
     368:	88 88       	ldd	r8, Y+16	; 0x10
     36a:	88 a8       	ldd	r8, Y+48	; 0x30
     36c:	90 68       	ori	r25, 0x80	; 128
     36e:	f0 88       	ldd	r15, Z+16	; 0x10
     370:	88 f0       	brcs	.+34     	; 0x394 <__trampolines_end+0x184>
     372:	a0 90 88 78 	lds	r10, 0x7888	; 0x807888 <__bss_end+0x54d4>
     376:	80 80       	ld	r8, Z
     378:	70 08       	sbc	r7, r0
     37a:	08 f0       	brcs	.+2      	; 0x37e <__trampolines_end+0x16e>
     37c:	f8 20       	and	r15, r8
     37e:	20 20       	and	r2, r0
     380:	20 20       	and	r2, r0
     382:	20 88       	ldd	r2, Z+16	; 0x10
     384:	88 88       	ldd	r8, Y+16	; 0x10
     386:	88 88       	ldd	r8, Y+16	; 0x10
     388:	88 70       	andi	r24, 0x08	; 8
     38a:	88 88       	ldd	r8, Y+16	; 0x10
     38c:	88 88       	ldd	r8, Y+16	; 0x10
     38e:	88 50       	subi	r24, 0x08	; 8
     390:	20 88       	ldd	r2, Z+16	; 0x10
     392:	88 88       	ldd	r8, Y+16	; 0x10
     394:	a8 a8       	ldd	r10, Y+48	; 0x30
     396:	d8 88       	ldd	r13, Y+16	; 0x10
     398:	88 88       	ldd	r8, Y+16	; 0x10
     39a:	50 20       	and	r5, r0
     39c:	50 88       	ldd	r5, Z+16	; 0x10
     39e:	88 88       	ldd	r8, Y+16	; 0x10
     3a0:	88 50       	subi	r24, 0x08	; 8
     3a2:	20 20       	and	r2, r0
     3a4:	20 20       	and	r2, r0
     3a6:	f8 08       	sbc	r15, r8
     3a8:	10 20       	and	r1, r0
     3aa:	40 80       	ld	r4, Z
     3ac:	f8 38       	cpi	r31, 0x88	; 136
     3ae:	20 20       	and	r2, r0
     3b0:	20 20       	and	r2, r0
     3b2:	20 38       	cpi	r18, 0x80	; 128
     3b4:	00 80       	ld	r0, Z
     3b6:	40 20       	and	r4, r0
     3b8:	10 08       	sbc	r1, r0
     3ba:	00 e0       	ldi	r16, 0x00	; 0
     3bc:	20 20       	and	r2, r0
     3be:	20 20       	and	r2, r0
     3c0:	20 e0       	ldi	r18, 0x00	; 0
     3c2:	20 50       	subi	r18, 0x00	; 0
     3c4:	88 00       	.word	0x0088	; ????
	...
     3ce:	00 f8       	bld	r0, 0
     3d0:	40 20       	and	r4, r0
     3d2:	10 00       	.word	0x0010	; ????
     3d4:	00 00       	nop
     3d6:	00 00       	nop
     3d8:	00 70       	andi	r16, 0x00	; 0
     3da:	08 78       	andi	r16, 0x88	; 136
     3dc:	88 78       	andi	r24, 0x88	; 136
     3de:	80 80       	ld	r8, Z
     3e0:	b0 c8       	rjmp	.-3744   	; 0xfffff542 <__eeprom_end+0xff7ef542>
     3e2:	88 88       	ldd	r8, Y+16	; 0x10
     3e4:	f0 00       	.word	0x00f0	; ????
     3e6:	00 70       	andi	r16, 0x00	; 0
     3e8:	80 80       	ld	r8, Z
     3ea:	88 70       	andi	r24, 0x08	; 8
     3ec:	08 08       	sbc	r0, r8
     3ee:	68 98       	cbi	0x0d, 0	; 13
     3f0:	88 88       	ldd	r8, Y+16	; 0x10
     3f2:	78 00       	.word	0x0078	; ????
     3f4:	00 70       	andi	r16, 0x00	; 0
     3f6:	88 f8       	.word	0xf888	; ????
     3f8:	80 70       	andi	r24, 0x00	; 0
     3fa:	30 48       	sbci	r19, 0x80	; 128
     3fc:	40 e0       	ldi	r20, 0x00	; 0
     3fe:	40 40       	sbci	r20, 0x00	; 0
     400:	40 00       	.word	0x0040	; ????
     402:	00 78       	andi	r16, 0x80	; 128
     404:	88 78       	andi	r24, 0x88	; 136
     406:	08 30       	cpi	r16, 0x08	; 8
     408:	80 80       	ld	r8, Z
     40a:	b0 c8       	rjmp	.-3744   	; 0xfffff56c <__eeprom_end+0xff7ef56c>
     40c:	88 88       	ldd	r8, Y+16	; 0x10
     40e:	88 20       	and	r8, r8
     410:	00 60       	ori	r16, 0x00	; 0
     412:	20 20       	and	r2, r0
     414:	20 70       	andi	r18, 0x00	; 0
     416:	10 00       	.word	0x0010	; ????
     418:	30 10       	cpse	r3, r0
     41a:	10 90 60 40 	lds	r1, 0x4060	; 0x804060 <__bss_end+0x1cac>
     41e:	40 48       	sbci	r20, 0x80	; 128
     420:	50 60       	ori	r21, 0x00	; 0
     422:	50 48       	sbci	r21, 0x80	; 128
     424:	60 20       	and	r6, r0
     426:	20 20       	and	r2, r0
     428:	20 20       	and	r2, r0
     42a:	70 00       	.word	0x0070	; ????
     42c:	00 d0       	rcall	.+0      	; 0x42e <__LOCK_REGION_LENGTH__+0x2e>
     42e:	a8 a8       	ldd	r10, Y+48	; 0x30
     430:	88 88       	ldd	r8, Y+16	; 0x10
     432:	00 00       	nop
     434:	b0 c8       	rjmp	.-3744   	; 0xfffff596 <__eeprom_end+0xff7ef596>
     436:	88 88       	ldd	r8, Y+16	; 0x10
     438:	88 00       	.word	0x0088	; ????
     43a:	00 70       	andi	r16, 0x00	; 0
     43c:	88 88       	ldd	r8, Y+16	; 0x10
     43e:	88 70       	andi	r24, 0x08	; 8
     440:	00 00       	nop
     442:	f0 88       	ldd	r15, Z+16	; 0x10
     444:	f0 80       	ld	r15, Z
     446:	80 00       	.word	0x0080	; ????
     448:	00 68       	ori	r16, 0x80	; 128
     44a:	98 78       	andi	r25, 0x88	; 136
     44c:	08 08       	sbc	r0, r8
     44e:	00 00       	nop
     450:	b0 c8       	rjmp	.-3744   	; 0xfffff5b2 <__eeprom_end+0xff7ef5b2>
     452:	80 80       	ld	r8, Z
     454:	80 00       	.word	0x0080	; ????
     456:	00 70       	andi	r16, 0x00	; 0
     458:	80 70       	andi	r24, 0x00	; 0
     45a:	08 f0       	brcs	.+2      	; 0x45e <__LOCK_REGION_LENGTH__+0x5e>
     45c:	40 40       	sbci	r20, 0x00	; 0
     45e:	e0 40       	sbci	r30, 0x00	; 0
     460:	40 48       	sbci	r20, 0x80	; 128
     462:	30 00       	.word	0x0030	; ????
     464:	00 88       	ldd	r0, Z+16	; 0x10
     466:	88 88       	ldd	r8, Y+16	; 0x10
     468:	98 68       	ori	r25, 0x88	; 136
     46a:	00 00       	nop
     46c:	88 88       	ldd	r8, Y+16	; 0x10
     46e:	88 50       	subi	r24, 0x08	; 8
     470:	20 00       	.word	0x0020	; ????
     472:	00 88       	ldd	r0, Z+16	; 0x10
     474:	88 a8       	ldd	r8, Y+48	; 0x30
     476:	a8 50       	subi	r26, 0x08	; 8
     478:	00 00       	nop
     47a:	88 50       	subi	r24, 0x08	; 8
     47c:	20 50       	subi	r18, 0x00	; 0
     47e:	88 00       	.word	0x0088	; ????
     480:	00 88       	ldd	r0, Z+16	; 0x10
     482:	88 78       	andi	r24, 0x88	; 136
     484:	08 70       	andi	r16, 0x08	; 8
     486:	00 00       	nop
     488:	f8 10       	cpse	r15, r8
     48a:	20 40       	sbci	r18, 0x00	; 0
     48c:	f8 10       	cpse	r15, r8
     48e:	20 20       	and	r2, r0
     490:	40 20       	and	r4, r0
     492:	20 10       	cpse	r2, r0
     494:	20 20       	and	r2, r0
     496:	20 20       	and	r2, r0
     498:	20 20       	and	r2, r0
     49a:	20 40       	sbci	r18, 0x00	; 0
     49c:	20 20       	and	r2, r0
     49e:	10 20       	and	r1, r0
     4a0:	20 40       	sbci	r18, 0x00	; 0

000004a2 <__ctors_end>:
     4a2:	11 24       	eor	r1, r1
     4a4:	1f be       	out	0x3f, r1	; 63
     4a6:	cf ef       	ldi	r28, 0xFF	; 255
     4a8:	cd bf       	out	0x3d, r28	; 61
     4aa:	df e5       	ldi	r29, 0x5F	; 95
     4ac:	de bf       	out	0x3e, r29	; 62
     4ae:	00 e0       	ldi	r16, 0x00	; 0
     4b0:	0c bf       	out	0x3c, r16	; 60

000004b2 <__do_copy_data>:
     4b2:	10 e2       	ldi	r17, 0x20	; 32
     4b4:	a0 e0       	ldi	r26, 0x00	; 0
     4b6:	b0 e2       	ldi	r27, 0x20	; 32
     4b8:	e6 e0       	ldi	r30, 0x06	; 6
     4ba:	f7 e3       	ldi	r31, 0x37	; 55
     4bc:	00 e0       	ldi	r16, 0x00	; 0
     4be:	0b bf       	out	0x3b, r16	; 59
     4c0:	02 c0       	rjmp	.+4      	; 0x4c6 <__do_copy_data+0x14>
     4c2:	07 90       	elpm	r0, Z+
     4c4:	0d 92       	st	X+, r0
     4c6:	a2 3b       	cpi	r26, 0xB2	; 178
     4c8:	b1 07       	cpc	r27, r17
     4ca:	d9 f7       	brne	.-10     	; 0x4c2 <__do_copy_data+0x10>

000004cc <__do_clear_bss>:
     4cc:	23 e2       	ldi	r18, 0x23	; 35
     4ce:	a2 eb       	ldi	r26, 0xB2	; 178
     4d0:	b0 e2       	ldi	r27, 0x20	; 32
     4d2:	01 c0       	rjmp	.+2      	; 0x4d6 <.do_clear_bss_start>

000004d4 <.do_clear_bss_loop>:
     4d4:	1d 92       	st	X+, r1

000004d6 <.do_clear_bss_start>:
     4d6:	a4 3b       	cpi	r26, 0xB4	; 180
     4d8:	b2 07       	cpc	r27, r18
     4da:	e1 f7       	brne	.-8      	; 0x4d4 <.do_clear_bss_loop>
     4dc:	0e 94 b4 16 	call	0x2d68	; 0x2d68 <main>
     4e0:	0c 94 81 1b 	jmp	0x3702	; 0x3702 <_exit>

000004e4 <__bad_interrupt>:
     4e4:	8d cd       	rjmp	.-1254   	; 0x0 <__vectors>

000004e6 <__portable_avr_delay_cycles>:
 *
 * @{
 */
__always_optimize
static inline void __portable_avr_delay_cycles(unsigned long n)
{
     4e6:	04 c0       	rjmp	.+8      	; 0x4f0 <__portable_avr_delay_cycles+0xa>
	while (n) {
		barrier();
		n--;
     4e8:	61 50       	subi	r22, 0x01	; 1
     4ea:	71 09       	sbc	r23, r1
     4ec:	81 09       	sbc	r24, r1
     4ee:	91 09       	sbc	r25, r1
 * @{
 */
__always_optimize
static inline void __portable_avr_delay_cycles(unsigned long n)
{
	while (n) {
     4f0:	61 15       	cp	r22, r1
     4f2:	71 05       	cpc	r23, r1
     4f4:	81 05       	cpc	r24, r1
     4f6:	91 05       	cpc	r25, r1
     4f8:	b9 f7       	brne	.-18     	; 0x4e8 <__portable_avr_delay_cycles+0x2>
     4fa:	08 95       	ret

000004fc <st7565r_init>:
 * Call this function to initialize the hardware interface and the LCD
 * controller. When initialization is done the display is turned on and ready
 * to receive data.
 */
void st7565r_init(void)
{
     4fc:	bf 92       	push	r11
     4fe:	cf 92       	push	r12
     500:	df 92       	push	r13
     502:	ef 92       	push	r14
     504:	ff 92       	push	r15
     506:	0f 93       	push	r16
     508:	1f 93       	push	r17
     50a:	cf 93       	push	r28
     50c:	df 93       	push	r29
     50e:	1f 92       	push	r1
     510:	cd b7       	in	r28, 0x3d	; 61
     512:	de b7       	in	r29, 0x3e	; 62
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
     514:	00 e0       	ldi	r16, 0x00	; 0
     516:	16 e0       	ldi	r17, 0x06	; 6
     518:	68 94       	set
     51a:	ff 24       	eor	r15, r15
     51c:	f3 f8       	bld	r15, 3
     51e:	f8 01       	movw	r30, r16
     520:	f6 82       	std	Z+6, r15	; 0x06
 * function, this command will control the RST pin.
 */
static inline void st7565r_hard_reset(void)
{
	ioport_set_pin_low(ST7565R_RESET_PIN);
	delay_us(10);
     522:	64 e0       	ldi	r22, 0x04	; 4
     524:	70 e0       	ldi	r23, 0x00	; 0
     526:	80 e0       	ldi	r24, 0x00	; 0
     528:	90 e0       	ldi	r25, 0x00	; 0
     52a:	dd df       	rcall	.-70     	; 0x4e6 <__portable_avr_delay_cycles>
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
     52c:	f8 01       	movw	r30, r16
     52e:	f5 82       	std	Z+5, r15	; 0x05
	ioport_set_pin_high(ST7565R_RESET_PIN);
	delay_us(10);
     530:	64 e0       	ldi	r22, 0x04	; 4
     532:	70 e0       	ldi	r23, 0x00	; 0
     534:	80 e0       	ldi	r24, 0x00	; 0
     536:	90 e0       	ldi	r25, 0x00	; 0
     538:	d6 df       	rcall	.-84     	; 0x4e6 <__portable_avr_delay_cycles>
	spi_flags_t spi_flags = SPI_MODE_3;
	board_spi_select_id_t spi_select_id = 0;
#endif

#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {
     53a:	0f 2e       	mov	r0, r31
     53c:	fb e2       	ldi	r31, 0x2B	; 43
     53e:	bf 2e       	mov	r11, r31
     540:	f0 2d       	mov	r31, r0
     542:	b9 82       	std	Y+1, r11	; 0x01
		.id = ST7565R_CS_PIN,
	};
	usart_spi_init(ST7565R_USART_SPI);
     544:	80 ea       	ldi	r24, 0xA0	; 160
     546:	99 e0       	ldi	r25, 0x09	; 9
     548:	1e d4       	rcall	.+2108   	; 0xd86 <usart_spi_init>
	usart_spi_setup_device(ST7565R_USART_SPI, &device, spi_flags,
     54a:	c1 2c       	mov	r12, r1
     54c:	d1 2c       	mov	r13, r1
     54e:	76 01       	movw	r14, r12
     550:	00 e4       	ldi	r16, 0x40	; 64
     552:	12 e4       	ldi	r17, 0x42	; 66
     554:	2f e0       	ldi	r18, 0x0F	; 15
     556:	30 e0       	ldi	r19, 0x00	; 0
     558:	43 e0       	ldi	r20, 0x03	; 3
     55a:	be 01       	movw	r22, r28
     55c:	6f 5f       	subi	r22, 0xFF	; 255
     55e:	7f 4f       	sbci	r23, 0xFF	; 255
     560:	80 ea       	ldi	r24, 0xA0	; 160
     562:	99 e0       	ldi	r25, 0x09	; 9
     564:	3f d4       	rcall	.+2174   	; 0xde4 <usart_spi_setup_device>
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
     566:	00 e6       	ldi	r16, 0x60	; 96
     568:	16 e0       	ldi	r17, 0x06	; 6
     56a:	ff 24       	eor	r15, r15
     56c:	f3 94       	inc	r15
     56e:	f8 01       	movw	r30, r16
     570:	f6 82       	std	Z+6, r15	; 0x06
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     572:	b9 82       	std	Y+1, r11	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     574:	be 01       	movw	r22, r28
     576:	6f 5f       	subi	r22, 0xFF	; 255
     578:	7f 4f       	sbci	r23, 0xFF	; 255
     57a:	80 ea       	ldi	r24, 0xA0	; 160
     57c:	99 e0       	ldi	r25, 0x09	; 9
     57e:	4c d4       	rcall	.+2200   	; 0xe18 <usart_spi_select_device>
     580:	f8 01       	movw	r30, r16
     582:	f6 82       	std	Z+6, r15	; 0x06
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     584:	e0 ea       	ldi	r30, 0xA0	; 160
     586:	f9 e0       	ldi	r31, 0x09	; 9
     588:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     58a:	85 ff       	sbrs	r24, 5
     58c:	fd cf       	rjmp	.-6      	; 0x588 <st7565r_init+0x8c>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     58e:	80 ea       	ldi	r24, 0xA0	; 160
     590:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     594:	e0 ea       	ldi	r30, 0xA0	; 160
     596:	f9 e0       	ldi	r31, 0x09	; 9
     598:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     59a:	86 ff       	sbrs	r24, 6
     59c:	fd cf       	rjmp	.-6      	; 0x598 <st7565r_init+0x9c>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     59e:	e0 ea       	ldi	r30, 0xA0	; 160
     5a0:	f9 e0       	ldi	r31, 0x09	; 9
     5a2:	80 e4       	ldi	r24, 0x40	; 64
     5a4:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     5a6:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     5a8:	be 01       	movw	r22, r28
     5aa:	6f 5f       	subi	r22, 0xFF	; 255
     5ac:	7f 4f       	sbci	r23, 0xFF	; 255
     5ae:	80 ea       	ldi	r24, 0xA0	; 160
     5b0:	99 e0       	ldi	r25, 0x09	; 9
     5b2:	48 d4       	rcall	.+2192   	; 0xe44 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     5b4:	8b e2       	ldi	r24, 0x2B	; 43
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     5b6:	89 83       	std	Y+1, r24	; 0x01
     5b8:	be 01       	movw	r22, r28
     5ba:	6f 5f       	subi	r22, 0xFF	; 255
     5bc:	7f 4f       	sbci	r23, 0xFF	; 255
     5be:	80 ea       	ldi	r24, 0xA0	; 160
     5c0:	99 e0       	ldi	r25, 0x09	; 9
     5c2:	2a d4       	rcall	.+2132   	; 0xe18 <usart_spi_select_device>
     5c4:	81 e0       	ldi	r24, 0x01	; 1
     5c6:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     5ca:	e0 ea       	ldi	r30, 0xA0	; 160
     5cc:	f9 e0       	ldi	r31, 0x09	; 9
     5ce:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     5d0:	85 ff       	sbrs	r24, 5
     5d2:	fd cf       	rjmp	.-6      	; 0x5ce <st7565r_init+0xd2>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     5d4:	86 ea       	ldi	r24, 0xA6	; 166
     5d6:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     5da:	e0 ea       	ldi	r30, 0xA0	; 160
     5dc:	f9 e0       	ldi	r31, 0x09	; 9
     5de:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     5e0:	86 ff       	sbrs	r24, 6
     5e2:	fd cf       	rjmp	.-6      	; 0x5de <st7565r_init+0xe2>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     5e4:	e0 ea       	ldi	r30, 0xA0	; 160
     5e6:	f9 e0       	ldi	r31, 0x09	; 9
     5e8:	80 e4       	ldi	r24, 0x40	; 64
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     5ea:	81 83       	std	Z+1, r24	; 0x01
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     5ec:	80 81       	ld	r24, Z
     5ee:	be 01       	movw	r22, r28
     5f0:	6f 5f       	subi	r22, 0xFF	; 255
     5f2:	7f 4f       	sbci	r23, 0xFF	; 255
     5f4:	80 ea       	ldi	r24, 0xA0	; 160
     5f6:	99 e0       	ldi	r25, 0x09	; 9
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     5f8:	25 d4       	rcall	.+2122   	; 0xe44 <usart_spi_deselect_device>
     5fa:	8b e2       	ldi	r24, 0x2B	; 43
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     5fc:	89 83       	std	Y+1, r24	; 0x01
     5fe:	be 01       	movw	r22, r28
     600:	6f 5f       	subi	r22, 0xFF	; 255
     602:	7f 4f       	sbci	r23, 0xFF	; 255
     604:	80 ea       	ldi	r24, 0xA0	; 160
     606:	99 e0       	ldi	r25, 0x09	; 9
     608:	07 d4       	rcall	.+2062   	; 0xe18 <usart_spi_select_device>
     60a:	81 e0       	ldi	r24, 0x01	; 1
     60c:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     610:	e0 ea       	ldi	r30, 0xA0	; 160
     612:	f9 e0       	ldi	r31, 0x09	; 9
     614:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     616:	85 ff       	sbrs	r24, 5
     618:	fd cf       	rjmp	.-6      	; 0x614 <st7565r_init+0x118>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     61a:	88 ec       	ldi	r24, 0xC8	; 200
     61c:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     620:	e0 ea       	ldi	r30, 0xA0	; 160
     622:	f9 e0       	ldi	r31, 0x09	; 9
     624:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     626:	86 ff       	sbrs	r24, 6
     628:	fd cf       	rjmp	.-6      	; 0x624 <st7565r_init+0x128>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     62a:	e0 ea       	ldi	r30, 0xA0	; 160
     62c:	f9 e0       	ldi	r31, 0x09	; 9
     62e:	80 e4       	ldi	r24, 0x40	; 64
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     630:	81 83       	std	Z+1, r24	; 0x01
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     632:	80 81       	ld	r24, Z
     634:	be 01       	movw	r22, r28
     636:	6f 5f       	subi	r22, 0xFF	; 255
     638:	7f 4f       	sbci	r23, 0xFF	; 255
     63a:	80 ea       	ldi	r24, 0xA0	; 160
     63c:	99 e0       	ldi	r25, 0x09	; 9
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     63e:	02 d4       	rcall	.+2052   	; 0xe44 <usart_spi_deselect_device>
     640:	8b e2       	ldi	r24, 0x2B	; 43
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     642:	89 83       	std	Y+1, r24	; 0x01
     644:	be 01       	movw	r22, r28
     646:	6f 5f       	subi	r22, 0xFF	; 255
     648:	7f 4f       	sbci	r23, 0xFF	; 255
     64a:	80 ea       	ldi	r24, 0xA0	; 160
     64c:	99 e0       	ldi	r25, 0x09	; 9
     64e:	e4 d3       	rcall	.+1992   	; 0xe18 <usart_spi_select_device>
     650:	81 e0       	ldi	r24, 0x01	; 1
     652:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     656:	e0 ea       	ldi	r30, 0xA0	; 160
     658:	f9 e0       	ldi	r31, 0x09	; 9
     65a:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     65c:	85 ff       	sbrs	r24, 5
     65e:	fd cf       	rjmp	.-6      	; 0x65a <st7565r_init+0x15e>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     660:	82 ea       	ldi	r24, 0xA2	; 162
     662:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     666:	e0 ea       	ldi	r30, 0xA0	; 160
     668:	f9 e0       	ldi	r31, 0x09	; 9
     66a:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     66c:	86 ff       	sbrs	r24, 6
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     66e:	fd cf       	rjmp	.-6      	; 0x66a <st7565r_init+0x16e>
     670:	e0 ea       	ldi	r30, 0xA0	; 160
     672:	f9 e0       	ldi	r31, 0x09	; 9
     674:	80 e4       	ldi	r24, 0x40	; 64
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     676:	81 83       	std	Z+1, r24	; 0x01
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     678:	80 81       	ld	r24, Z
     67a:	be 01       	movw	r22, r28
     67c:	6f 5f       	subi	r22, 0xFF	; 255
     67e:	7f 4f       	sbci	r23, 0xFF	; 255
     680:	80 ea       	ldi	r24, 0xA0	; 160
     682:	99 e0       	ldi	r25, 0x09	; 9
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     684:	df d3       	rcall	.+1982   	; 0xe44 <usart_spi_deselect_device>
     686:	8b e2       	ldi	r24, 0x2B	; 43
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     688:	89 83       	std	Y+1, r24	; 0x01
     68a:	be 01       	movw	r22, r28
     68c:	6f 5f       	subi	r22, 0xFF	; 255
     68e:	7f 4f       	sbci	r23, 0xFF	; 255
     690:	80 ea       	ldi	r24, 0xA0	; 160
     692:	99 e0       	ldi	r25, 0x09	; 9
     694:	c1 d3       	rcall	.+1922   	; 0xe18 <usart_spi_select_device>
     696:	81 e0       	ldi	r24, 0x01	; 1
     698:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     69c:	e0 ea       	ldi	r30, 0xA0	; 160
     69e:	f9 e0       	ldi	r31, 0x09	; 9
     6a0:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     6a2:	85 ff       	sbrs	r24, 5
     6a4:	fd cf       	rjmp	.-6      	; 0x6a0 <st7565r_init+0x1a4>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     6a6:	8f e2       	ldi	r24, 0x2F	; 47
     6a8:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     6ac:	e0 ea       	ldi	r30, 0xA0	; 160
     6ae:	f9 e0       	ldi	r31, 0x09	; 9
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     6b0:	81 81       	ldd	r24, Z+1	; 0x01
     6b2:	86 ff       	sbrs	r24, 6
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     6b4:	fd cf       	rjmp	.-6      	; 0x6b0 <st7565r_init+0x1b4>
     6b6:	e0 ea       	ldi	r30, 0xA0	; 160
     6b8:	f9 e0       	ldi	r31, 0x09	; 9
     6ba:	80 e4       	ldi	r24, 0x40	; 64
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     6bc:	81 83       	std	Z+1, r24	; 0x01
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     6be:	80 81       	ld	r24, Z
     6c0:	be 01       	movw	r22, r28
     6c2:	6f 5f       	subi	r22, 0xFF	; 255
     6c4:	7f 4f       	sbci	r23, 0xFF	; 255
     6c6:	80 ea       	ldi	r24, 0xA0	; 160
     6c8:	99 e0       	ldi	r25, 0x09	; 9
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     6ca:	bc d3       	rcall	.+1912   	; 0xe44 <usart_spi_deselect_device>
     6cc:	8b e2       	ldi	r24, 0x2B	; 43
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     6ce:	89 83       	std	Y+1, r24	; 0x01
     6d0:	be 01       	movw	r22, r28
     6d2:	6f 5f       	subi	r22, 0xFF	; 255
     6d4:	7f 4f       	sbci	r23, 0xFF	; 255
     6d6:	80 ea       	ldi	r24, 0xA0	; 160
     6d8:	99 e0       	ldi	r25, 0x09	; 9
     6da:	9e d3       	rcall	.+1852   	; 0xe18 <usart_spi_select_device>
     6dc:	81 e0       	ldi	r24, 0x01	; 1
     6de:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     6e2:	e0 ea       	ldi	r30, 0xA0	; 160
     6e4:	f9 e0       	ldi	r31, 0x09	; 9
     6e6:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     6e8:	85 ff       	sbrs	r24, 5
     6ea:	fd cf       	rjmp	.-6      	; 0x6e6 <st7565r_init+0x1ea>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     6ec:	88 ef       	ldi	r24, 0xF8	; 248
     6ee:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     6f2:	e0 ea       	ldi	r30, 0xA0	; 160
     6f4:	f9 e0       	ldi	r31, 0x09	; 9
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     6f6:	81 81       	ldd	r24, Z+1	; 0x01
     6f8:	86 ff       	sbrs	r24, 6
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     6fa:	fd cf       	rjmp	.-6      	; 0x6f6 <st7565r_init+0x1fa>
     6fc:	e0 ea       	ldi	r30, 0xA0	; 160
     6fe:	f9 e0       	ldi	r31, 0x09	; 9
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     700:	80 e4       	ldi	r24, 0x40	; 64
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     702:	81 83       	std	Z+1, r24	; 0x01
     704:	80 81       	ld	r24, Z
     706:	be 01       	movw	r22, r28
     708:	6f 5f       	subi	r22, 0xFF	; 255
     70a:	7f 4f       	sbci	r23, 0xFF	; 255
     70c:	80 ea       	ldi	r24, 0xA0	; 160
     70e:	99 e0       	ldi	r25, 0x09	; 9
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     710:	99 d3       	rcall	.+1842   	; 0xe44 <usart_spi_deselect_device>
     712:	8b e2       	ldi	r24, 0x2B	; 43
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     714:	89 83       	std	Y+1, r24	; 0x01
     716:	be 01       	movw	r22, r28
     718:	6f 5f       	subi	r22, 0xFF	; 255
     71a:	7f 4f       	sbci	r23, 0xFF	; 255
     71c:	80 ea       	ldi	r24, 0xA0	; 160
     71e:	99 e0       	ldi	r25, 0x09	; 9
     720:	7b d3       	rcall	.+1782   	; 0xe18 <usart_spi_select_device>
     722:	81 e0       	ldi	r24, 0x01	; 1
     724:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     728:	e0 ea       	ldi	r30, 0xA0	; 160
     72a:	f9 e0       	ldi	r31, 0x09	; 9
     72c:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     72e:	85 ff       	sbrs	r24, 5
     730:	fd cf       	rjmp	.-6      	; 0x72c <st7565r_init+0x230>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     732:	10 92 a0 09 	sts	0x09A0, r1	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     736:	e0 ea       	ldi	r30, 0xA0	; 160
     738:	f9 e0       	ldi	r31, 0x09	; 9
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     73a:	81 81       	ldd	r24, Z+1	; 0x01
     73c:	86 ff       	sbrs	r24, 6
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     73e:	fd cf       	rjmp	.-6      	; 0x73a <st7565r_init+0x23e>
     740:	e0 ea       	ldi	r30, 0xA0	; 160
     742:	f9 e0       	ldi	r31, 0x09	; 9
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     744:	80 e4       	ldi	r24, 0x40	; 64
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     746:	81 83       	std	Z+1, r24	; 0x01
     748:	80 81       	ld	r24, Z
     74a:	be 01       	movw	r22, r28
     74c:	6f 5f       	subi	r22, 0xFF	; 255
     74e:	7f 4f       	sbci	r23, 0xFF	; 255
     750:	80 ea       	ldi	r24, 0xA0	; 160
     752:	99 e0       	ldi	r25, 0x09	; 9
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     754:	77 d3       	rcall	.+1774   	; 0xe44 <usart_spi_deselect_device>
     756:	8b e2       	ldi	r24, 0x2B	; 43
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     758:	89 83       	std	Y+1, r24	; 0x01
     75a:	be 01       	movw	r22, r28
     75c:	6f 5f       	subi	r22, 0xFF	; 255
     75e:	7f 4f       	sbci	r23, 0xFF	; 255
     760:	80 ea       	ldi	r24, 0xA0	; 160
     762:	99 e0       	ldi	r25, 0x09	; 9
     764:	59 d3       	rcall	.+1714   	; 0xe18 <usart_spi_select_device>
     766:	81 e0       	ldi	r24, 0x01	; 1
     768:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     76c:	e0 ea       	ldi	r30, 0xA0	; 160
     76e:	f9 e0       	ldi	r31, 0x09	; 9
     770:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     772:	85 ff       	sbrs	r24, 5
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     774:	fd cf       	rjmp	.-6      	; 0x770 <st7565r_init+0x274>
     776:	81 e2       	ldi	r24, 0x21	; 33
     778:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     77c:	e0 ea       	ldi	r30, 0xA0	; 160
     77e:	f9 e0       	ldi	r31, 0x09	; 9
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     780:	81 81       	ldd	r24, Z+1	; 0x01
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     782:	86 ff       	sbrs	r24, 6
     784:	fd cf       	rjmp	.-6      	; 0x780 <st7565r_init+0x284>
     786:	e0 ea       	ldi	r30, 0xA0	; 160
     788:	f9 e0       	ldi	r31, 0x09	; 9
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     78a:	80 e4       	ldi	r24, 0x40	; 64
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     78c:	81 83       	std	Z+1, r24	; 0x01
     78e:	80 81       	ld	r24, Z
     790:	be 01       	movw	r22, r28
     792:	6f 5f       	subi	r22, 0xFF	; 255
     794:	7f 4f       	sbci	r23, 0xFF	; 255
     796:	80 ea       	ldi	r24, 0xA0	; 160
     798:	99 e0       	ldi	r25, 0x09	; 9
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     79a:	54 d3       	rcall	.+1704   	; 0xe44 <usart_spi_deselect_device>
     79c:	8b e2       	ldi	r24, 0x2B	; 43
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     79e:	89 83       	std	Y+1, r24	; 0x01
     7a0:	be 01       	movw	r22, r28
     7a2:	6f 5f       	subi	r22, 0xFF	; 255
     7a4:	7f 4f       	sbci	r23, 0xFF	; 255
     7a6:	80 ea       	ldi	r24, 0xA0	; 160
     7a8:	99 e0       	ldi	r25, 0x09	; 9
     7aa:	36 d3       	rcall	.+1644   	; 0xe18 <usart_spi_select_device>
     7ac:	81 e0       	ldi	r24, 0x01	; 1
     7ae:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     7b2:	e0 ea       	ldi	r30, 0xA0	; 160
     7b4:	f9 e0       	ldi	r31, 0x09	; 9
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     7b6:	81 81       	ldd	r24, Z+1	; 0x01
     7b8:	85 ff       	sbrs	r24, 5
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     7ba:	fd cf       	rjmp	.-6      	; 0x7b6 <st7565r_init+0x2ba>
     7bc:	81 e8       	ldi	r24, 0x81	; 129
     7be:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     7c2:	e0 ea       	ldi	r30, 0xA0	; 160
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     7c4:	f9 e0       	ldi	r31, 0x09	; 9
     7c6:	81 81       	ldd	r24, Z+1	; 0x01
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     7c8:	86 ff       	sbrs	r24, 6
     7ca:	fd cf       	rjmp	.-6      	; 0x7c6 <st7565r_init+0x2ca>
     7cc:	e0 ea       	ldi	r30, 0xA0	; 160
     7ce:	f9 e0       	ldi	r31, 0x09	; 9
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     7d0:	80 e4       	ldi	r24, 0x40	; 64
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     7d2:	81 83       	std	Z+1, r24	; 0x01
     7d4:	80 81       	ld	r24, Z
     7d6:	be 01       	movw	r22, r28
     7d8:	6f 5f       	subi	r22, 0xFF	; 255
     7da:	7f 4f       	sbci	r23, 0xFF	; 255
     7dc:	80 ea       	ldi	r24, 0xA0	; 160
     7de:	99 e0       	ldi	r25, 0x09	; 9
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     7e0:	31 d3       	rcall	.+1634   	; 0xe44 <usart_spi_deselect_device>
     7e2:	8b e2       	ldi	r24, 0x2B	; 43
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     7e4:	89 83       	std	Y+1, r24	; 0x01
     7e6:	be 01       	movw	r22, r28
     7e8:	6f 5f       	subi	r22, 0xFF	; 255
     7ea:	7f 4f       	sbci	r23, 0xFF	; 255
     7ec:	80 ea       	ldi	r24, 0xA0	; 160
     7ee:	99 e0       	ldi	r25, 0x09	; 9
     7f0:	13 d3       	rcall	.+1574   	; 0xe18 <usart_spi_select_device>
     7f2:	81 e0       	ldi	r24, 0x01	; 1
     7f4:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     7f8:	e0 ea       	ldi	r30, 0xA0	; 160
     7fa:	f9 e0       	ldi	r31, 0x09	; 9
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     7fc:	81 81       	ldd	r24, Z+1	; 0x01
     7fe:	85 ff       	sbrs	r24, 5
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     800:	fd cf       	rjmp	.-6      	; 0x7fc <st7565r_init+0x300>
     802:	81 e2       	ldi	r24, 0x21	; 33
     804:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     808:	e0 ea       	ldi	r30, 0xA0	; 160
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     80a:	f9 e0       	ldi	r31, 0x09	; 9
     80c:	81 81       	ldd	r24, Z+1	; 0x01
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     80e:	86 ff       	sbrs	r24, 6
     810:	fd cf       	rjmp	.-6      	; 0x80c <st7565r_init+0x310>
     812:	e0 ea       	ldi	r30, 0xA0	; 160
     814:	f9 e0       	ldi	r31, 0x09	; 9
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     816:	80 e4       	ldi	r24, 0x40	; 64
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     818:	81 83       	std	Z+1, r24	; 0x01
     81a:	80 81       	ld	r24, Z
     81c:	be 01       	movw	r22, r28
     81e:	6f 5f       	subi	r22, 0xFF	; 255
     820:	7f 4f       	sbci	r23, 0xFF	; 255
     822:	80 ea       	ldi	r24, 0xA0	; 160
     824:	99 e0       	ldi	r25, 0x09	; 9
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     826:	0e d3       	rcall	.+1564   	; 0xe44 <usart_spi_deselect_device>
     828:	8b e2       	ldi	r24, 0x2B	; 43
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     82a:	89 83       	std	Y+1, r24	; 0x01
     82c:	be 01       	movw	r22, r28
     82e:	6f 5f       	subi	r22, 0xFF	; 255
     830:	7f 4f       	sbci	r23, 0xFF	; 255
     832:	80 ea       	ldi	r24, 0xA0	; 160
     834:	99 e0       	ldi	r25, 0x09	; 9
     836:	f0 d2       	rcall	.+1504   	; 0xe18 <usart_spi_select_device>
     838:	81 e0       	ldi	r24, 0x01	; 1
     83a:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     83e:	e0 ea       	ldi	r30, 0xA0	; 160
     840:	f9 e0       	ldi	r31, 0x09	; 9
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     842:	81 81       	ldd	r24, Z+1	; 0x01
     844:	85 ff       	sbrs	r24, 5
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     846:	fd cf       	rjmp	.-6      	; 0x842 <st7565r_init+0x346>
     848:	8f ea       	ldi	r24, 0xAF	; 175
     84a:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     84e:	e0 ea       	ldi	r30, 0xA0	; 160
     850:	f9 e0       	ldi	r31, 0x09	; 9
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     852:	81 81       	ldd	r24, Z+1	; 0x01
     854:	86 ff       	sbrs	r24, 6
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     856:	fd cf       	rjmp	.-6      	; 0x852 <st7565r_init+0x356>
     858:	e0 ea       	ldi	r30, 0xA0	; 160
     85a:	f9 e0       	ldi	r31, 0x09	; 9
     85c:	80 e4       	ldi	r24, 0x40	; 64
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     85e:	81 83       	std	Z+1, r24	; 0x01
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     860:	80 81       	ld	r24, Z
     862:	be 01       	movw	r22, r28
     864:	6f 5f       	subi	r22, 0xFF	; 255
     866:	7f 4f       	sbci	r23, 0xFF	; 255
     868:	80 ea       	ldi	r24, 0xA0	; 160
     86a:	99 e0       	ldi	r25, 0x09	; 9
     86c:	eb d2       	rcall	.+1494   	; 0xe44 <usart_spi_deselect_device>
	is set to the defined min*/
	st7565r_set_contrast(ST7565R_DISPLAY_CONTRAST_MIN);

	// Turn on the display
	st7565r_display_on();
}
     86e:	0f 90       	pop	r0
     870:	df 91       	pop	r29
     872:	cf 91       	pop	r28
     874:	1f 91       	pop	r17
     876:	0f 91       	pop	r16
     878:	ff 90       	pop	r15
     87a:	ef 90       	pop	r14
     87c:	df 90       	pop	r13
     87e:	cf 90       	pop	r12
     880:	bf 90       	pop	r11
     882:	08 95       	ret

00000884 <sysclk_enable_module>:
	sysclk_rtcsrc_enable(CONFIG_RTC_SOURCE);
#endif
}

void sysclk_enable_module(enum sysclk_port_id port, uint8_t id)
{
     884:	cf 93       	push	r28
     886:	df 93       	push	r29
     888:	1f 92       	push	r1
     88a:	cd b7       	in	r28, 0x3d	; 61
     88c:	de b7       	in	r29, 0x3e	; 62

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags = SREG;
     88e:	9f b7       	in	r25, 0x3f	; 63
     890:	99 83       	std	Y+1, r25	; 0x01
	cpu_irq_disable();
     892:	f8 94       	cli
	return flags;
     894:	99 81       	ldd	r25, Y+1	; 0x01
	irqflags_t flags = cpu_irq_save();

	*((uint8_t *)&PR.PRGEN + port) &= ~id;
     896:	e8 2f       	mov	r30, r24
     898:	f0 e0       	ldi	r31, 0x00	; 0
     89a:	e0 59       	subi	r30, 0x90	; 144
     89c:	ff 4f       	sbci	r31, 0xFF	; 255
     89e:	60 95       	com	r22
     8a0:	80 81       	ld	r24, Z
     8a2:	68 23       	and	r22, r24
     8a4:	60 83       	st	Z, r22
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
     8a6:	9f bf       	out	0x3f, r25	; 63

	cpu_irq_restore(flags);
}
     8a8:	0f 90       	pop	r0
     8aa:	df 91       	pop	r29
     8ac:	cf 91       	pop	r28
     8ae:	08 95       	ret

000008b0 <gfx_mono_st7565r_put_byte>:
	gfx_mono_st7565r_put_byte(0, 0, 0xFF);
\endcode
 */
void gfx_mono_st7565r_put_byte(gfx_coord_t page, gfx_coord_t column,
		uint8_t data)
{
     8b0:	ff 92       	push	r15
     8b2:	0f 93       	push	r16
     8b4:	1f 93       	push	r17
     8b6:	cf 93       	push	r28
     8b8:	df 93       	push	r29
     8ba:	1f 92       	push	r1
     8bc:	cd b7       	in	r28, 0x3d	; 61
     8be:	de b7       	in	r29, 0x3e	; 62
     8c0:	08 2f       	mov	r16, r24
     8c2:	f6 2e       	mov	r15, r22
     8c4:	14 2f       	mov	r17, r20
#ifdef CONFIG_ST7565R_FRAMEBUFFER
	gfx_mono_framebuffer_put_byte(page, column, data);
     8c6:	1a d1       	rcall	.+564    	; 0xafc <gfx_mono_framebuffer_put_byte>
 */
static inline void st7565r_set_page_address(uint8_t address)
{
	// Make sure that the address is 4 bits (only 8 pages)
	address &= 0x0F;
	st7565r_write_command(ST7565R_CMD_PAGE_ADDRESS_SET(address));
     8c8:	0f 70       	andi	r16, 0x0F	; 15
     8ca:	00 6b       	ori	r16, 0xB0	; 176
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     8cc:	8b e2       	ldi	r24, 0x2B	; 43
     8ce:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     8d0:	be 01       	movw	r22, r28
     8d2:	6f 5f       	subi	r22, 0xFF	; 255
     8d4:	7f 4f       	sbci	r23, 0xFF	; 255
     8d6:	80 ea       	ldi	r24, 0xA0	; 160
     8d8:	99 e0       	ldi	r25, 0x09	; 9
     8da:	9e d2       	rcall	.+1340   	; 0xe18 <usart_spi_select_device>
     8dc:	81 e0       	ldi	r24, 0x01	; 1
     8de:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     8e2:	e0 ea       	ldi	r30, 0xA0	; 160
     8e4:	f9 e0       	ldi	r31, 0x09	; 9
     8e6:	91 81       	ldd	r25, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     8e8:	95 ff       	sbrs	r25, 5
     8ea:	fd cf       	rjmp	.-6      	; 0x8e6 <gfx_mono_st7565r_put_byte+0x36>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     8ec:	00 93 a0 09 	sts	0x09A0, r16	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     8f0:	e0 ea       	ldi	r30, 0xA0	; 160
     8f2:	f9 e0       	ldi	r31, 0x09	; 9
     8f4:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     8f6:	86 ff       	sbrs	r24, 6
     8f8:	fd cf       	rjmp	.-6      	; 0x8f4 <gfx_mono_st7565r_put_byte+0x44>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     8fa:	e0 ea       	ldi	r30, 0xA0	; 160
     8fc:	f9 e0       	ldi	r31, 0x09	; 9
     8fe:	80 e4       	ldi	r24, 0x40	; 64
     900:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     902:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     904:	be 01       	movw	r22, r28
     906:	6f 5f       	subi	r22, 0xFF	; 255
     908:	7f 4f       	sbci	r23, 0xFF	; 255
     90a:	80 ea       	ldi	r24, 0xA0	; 160
     90c:	99 e0       	ldi	r25, 0x09	; 9
     90e:	9a d2       	rcall	.+1332   	; 0xe44 <usart_spi_deselect_device>
 */
static inline void st7565r_set_column_address(uint8_t address)
{
	// Make sure the address is 7 bits
	address &= 0x7F;
	st7565r_write_command(ST7565R_CMD_COLUMN_ADDRESS_SET_MSB(address >> 4));
     910:	0f 2d       	mov	r16, r15
     912:	0f 77       	andi	r16, 0x7F	; 127
     914:	02 95       	swap	r16
     916:	0f 70       	andi	r16, 0x0F	; 15
     918:	00 61       	ori	r16, 0x10	; 16
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     91a:	8b e2       	ldi	r24, 0x2B	; 43
     91c:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     91e:	be 01       	movw	r22, r28
     920:	6f 5f       	subi	r22, 0xFF	; 255
     922:	7f 4f       	sbci	r23, 0xFF	; 255
     924:	80 ea       	ldi	r24, 0xA0	; 160
     926:	99 e0       	ldi	r25, 0x09	; 9
     928:	77 d2       	rcall	.+1262   	; 0xe18 <usart_spi_select_device>
     92a:	81 e0       	ldi	r24, 0x01	; 1
     92c:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     930:	e0 ea       	ldi	r30, 0xA0	; 160
     932:	f9 e0       	ldi	r31, 0x09	; 9
     934:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     936:	85 ff       	sbrs	r24, 5
     938:	fd cf       	rjmp	.-6      	; 0x934 <gfx_mono_st7565r_put_byte+0x84>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     93a:	00 93 a0 09 	sts	0x09A0, r16	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     93e:	e0 ea       	ldi	r30, 0xA0	; 160
     940:	f9 e0       	ldi	r31, 0x09	; 9
     942:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     944:	86 ff       	sbrs	r24, 6
     946:	fd cf       	rjmp	.-6      	; 0x942 <gfx_mono_st7565r_put_byte+0x92>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     948:	e0 ea       	ldi	r30, 0xA0	; 160
     94a:	f9 e0       	ldi	r31, 0x09	; 9
     94c:	80 e4       	ldi	r24, 0x40	; 64
     94e:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     950:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     952:	be 01       	movw	r22, r28
     954:	6f 5f       	subi	r22, 0xFF	; 255
     956:	7f 4f       	sbci	r23, 0xFF	; 255
     958:	80 ea       	ldi	r24, 0xA0	; 160
     95a:	99 e0       	ldi	r25, 0x09	; 9
     95c:	73 d2       	rcall	.+1254   	; 0xe44 <usart_spi_deselect_device>
static inline void st7565r_set_column_address(uint8_t address)
{
	// Make sure the address is 7 bits
	address &= 0x7F;
	st7565r_write_command(ST7565R_CMD_COLUMN_ADDRESS_SET_MSB(address >> 4));
	st7565r_write_command(ST7565R_CMD_COLUMN_ADDRESS_SET_LSB(address & 0x0F));
     95e:	0f 2d       	mov	r16, r15
     960:	0f 70       	andi	r16, 0x0F	; 15
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     962:	8b e2       	ldi	r24, 0x2B	; 43
     964:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     966:	be 01       	movw	r22, r28
     968:	6f 5f       	subi	r22, 0xFF	; 255
     96a:	7f 4f       	sbci	r23, 0xFF	; 255
     96c:	80 ea       	ldi	r24, 0xA0	; 160
     96e:	99 e0       	ldi	r25, 0x09	; 9
     970:	53 d2       	rcall	.+1190   	; 0xe18 <usart_spi_select_device>
     972:	81 e0       	ldi	r24, 0x01	; 1
     974:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     978:	e0 ea       	ldi	r30, 0xA0	; 160
     97a:	f9 e0       	ldi	r31, 0x09	; 9
     97c:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     97e:	85 ff       	sbrs	r24, 5
     980:	fd cf       	rjmp	.-6      	; 0x97c <gfx_mono_st7565r_put_byte+0xcc>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     982:	00 93 a0 09 	sts	0x09A0, r16	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     986:	e0 ea       	ldi	r30, 0xA0	; 160
     988:	f9 e0       	ldi	r31, 0x09	; 9
     98a:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     98c:	86 ff       	sbrs	r24, 6
     98e:	fd cf       	rjmp	.-6      	; 0x98a <gfx_mono_st7565r_put_byte+0xda>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     990:	e0 ea       	ldi	r30, 0xA0	; 160
     992:	f9 e0       	ldi	r31, 0x09	; 9
     994:	80 e4       	ldi	r24, 0x40	; 64
     996:	81 83       	std	Z+1, r24	; 0x01
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     998:	80 81       	ld	r24, Z
     99a:	be 01       	movw	r22, r28
     99c:	6f 5f       	subi	r22, 0xFF	; 255
     99e:	7f 4f       	sbci	r23, 0xFF	; 255
     9a0:	80 ea       	ldi	r24, 0xA0	; 160
     9a2:	99 e0       	ldi	r25, 0x09	; 9
     9a4:	4f d2       	rcall	.+1182   	; 0xe44 <usart_spi_deselect_device>
 * \param data the data to write
 */
static inline void st7565r_write_data(uint8_t data)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     9a6:	8b e2       	ldi	r24, 0x2B	; 43
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     9a8:	89 83       	std	Y+1, r24	; 0x01
     9aa:	be 01       	movw	r22, r28
     9ac:	6f 5f       	subi	r22, 0xFF	; 255
     9ae:	7f 4f       	sbci	r23, 0xFF	; 255
     9b0:	80 ea       	ldi	r24, 0xA0	; 160
     9b2:	99 e0       	ldi	r25, 0x09	; 9
     9b4:	31 d2       	rcall	.+1122   	; 0xe18 <usart_spi_select_device>
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
     9b6:	81 e0       	ldi	r24, 0x01	; 1
     9b8:	80 93 65 06 	sts	0x0665, r24	; 0x800665 <__TEXT_REGION_LENGTH__+0x700665>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     9bc:	e0 ea       	ldi	r30, 0xA0	; 160
     9be:	f9 e0       	ldi	r31, 0x09	; 9
     9c0:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     9c2:	85 ff       	sbrs	r24, 5
     9c4:	fd cf       	rjmp	.-6      	; 0x9c0 <gfx_mono_st7565r_put_byte+0x110>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     9c6:	10 93 a0 09 	sts	0x09A0, r17	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     9ca:	e0 ea       	ldi	r30, 0xA0	; 160
     9cc:	f9 e0       	ldi	r31, 0x09	; 9
     9ce:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     9d0:	86 ff       	sbrs	r24, 6
     9d2:	fd cf       	rjmp	.-6      	; 0x9ce <gfx_mono_st7565r_put_byte+0x11e>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     9d4:	e0 ea       	ldi	r30, 0xA0	; 160
     9d6:	f9 e0       	ldi	r31, 0x09	; 9
     9d8:	80 e4       	ldi	r24, 0x40	; 64
     9da:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     9dc:	80 81       	ld	r24, Z
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
     9de:	81 e0       	ldi	r24, 0x01	; 1
     9e0:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
	ioport_set_pin_high(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, data);
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     9e4:	be 01       	movw	r22, r28
     9e6:	6f 5f       	subi	r22, 0xFF	; 255
     9e8:	7f 4f       	sbci	r23, 0xFF	; 255
     9ea:	80 ea       	ldi	r24, 0xA0	; 160
     9ec:	99 e0       	ldi	r25, 0x09	; 9
     9ee:	2a d2       	rcall	.+1108   	; 0xe44 <usart_spi_deselect_device>

	st7565r_set_page_address(page);
	st7565r_set_column_address(column);

	st7565r_write_data(data);
}
     9f0:	0f 90       	pop	r0
     9f2:	df 91       	pop	r29
     9f4:	cf 91       	pop	r28
     9f6:	1f 91       	pop	r17
     9f8:	0f 91       	pop	r16
     9fa:	ff 90       	pop	r15
     9fc:	08 95       	ret

000009fe <gfx_mono_st7565r_init>:
 * It will also write the graphic controller RAM to all zeroes.
 *
 * \note This function will clear the contents of the display.
 */
void gfx_mono_st7565r_init(void)
{
     9fe:	0f 93       	push	r16
     a00:	1f 93       	push	r17
     a02:	cf 93       	push	r28
     a04:	df 93       	push	r29
     a06:	1f 92       	push	r1
     a08:	cd b7       	in	r28, 0x3d	; 61
     a0a:	de b7       	in	r29, 0x3e	; 62
	uint8_t page;
	uint8_t column;

#ifdef CONFIG_ST7565R_FRAMEBUFFER
	gfx_mono_set_framebuffer(framebuffer);
     a0c:	82 eb       	ldi	r24, 0xB2	; 178
     a0e:	90 e2       	ldi	r25, 0x20	; 32
     a10:	70 d0       	rcall	.+224    	; 0xaf2 <gfx_mono_set_framebuffer>
#endif

	/* Initialize the low-level display controller. */
	st7565r_init();
     a12:	74 dd       	rcall	.-1304   	; 0x4fc <st7565r_init>
     a14:	8b e2       	ldi	r24, 0x2B	; 43
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     a16:	89 83       	std	Y+1, r24	; 0x01
     a18:	be 01       	movw	r22, r28
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     a1a:	6f 5f       	subi	r22, 0xFF	; 255
     a1c:	7f 4f       	sbci	r23, 0xFF	; 255
     a1e:	80 ea       	ldi	r24, 0xA0	; 160
     a20:	99 e0       	ldi	r25, 0x09	; 9
     a22:	fa d1       	rcall	.+1012   	; 0xe18 <usart_spi_select_device>
     a24:	81 e0       	ldi	r24, 0x01	; 1
     a26:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
     a2a:	e0 ea       	ldi	r30, 0xA0	; 160
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     a2c:	f9 e0       	ldi	r31, 0x09	; 9
     a2e:	81 81       	ldd	r24, Z+1	; 0x01
     a30:	85 ff       	sbrs	r24, 5
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     a32:	fd cf       	rjmp	.-6      	; 0xa2e <gfx_mono_st7565r_init+0x30>
     a34:	80 e4       	ldi	r24, 0x40	; 64
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     a36:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
     a3a:	e0 ea       	ldi	r30, 0xA0	; 160
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     a3c:	f9 e0       	ldi	r31, 0x09	; 9
     a3e:	81 81       	ldd	r24, Z+1	; 0x01
     a40:	86 ff       	sbrs	r24, 6
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     a42:	fd cf       	rjmp	.-6      	; 0xa3e <gfx_mono_st7565r_init+0x40>
     a44:	e0 ea       	ldi	r30, 0xA0	; 160
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     a46:	f9 e0       	ldi	r31, 0x09	; 9
     a48:	80 e4       	ldi	r24, 0x40	; 64
     a4a:	81 83       	std	Z+1, r24	; 0x01
     a4c:	80 81       	ld	r24, Z
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     a4e:	be 01       	movw	r22, r28
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     a50:	6f 5f       	subi	r22, 0xFF	; 255
     a52:	7f 4f       	sbci	r23, 0xFF	; 255
     a54:	80 ea       	ldi	r24, 0xA0	; 160
     a56:	99 e0       	ldi	r25, 0x09	; 9
     a58:	f5 d1       	rcall	.+1002   	; 0xe44 <usart_spi_deselect_device>
     a5a:	00 e0       	ldi	r16, 0x00	; 0

	/* Clear the contents of the display.
	 * If using a framebuffer (SPI interface) it will both clear the
	 * controller memory and the framebuffer.
	 */
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
     a5c:	0a c0       	rjmp	.+20     	; 0xa72 <gfx_mono_st7565r_init+0x74>
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
			gfx_mono_put_byte(page, column, 0x00);
     a5e:	40 e0       	ldi	r20, 0x00	; 0
     a60:	61 2f       	mov	r22, r17
     a62:	80 2f       	mov	r24, r16
     a64:	25 df       	rcall	.-438    	; 0x8b0 <gfx_mono_st7565r_put_byte>
     a66:	1f 5f       	subi	r17, 0xFF	; 255
	/* Clear the contents of the display.
	 * If using a framebuffer (SPI interface) it will both clear the
	 * controller memory and the framebuffer.
	 */
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
     a68:	10 38       	cpi	r17, 0x80	; 128
     a6a:	c9 f7       	brne	.-14     	; 0xa5e <gfx_mono_st7565r_init+0x60>
     a6c:	0f 5f       	subi	r16, 0xFF	; 255

	/* Clear the contents of the display.
	 * If using a framebuffer (SPI interface) it will both clear the
	 * controller memory and the framebuffer.
	 */
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
     a6e:	04 30       	cpi	r16, 0x04	; 4
     a70:	11 f0       	breq	.+4      	; 0xa76 <gfx_mono_st7565r_init+0x78>
     a72:	10 e0       	ldi	r17, 0x00	; 0
 * It will also write the graphic controller RAM to all zeroes.
 *
 * \note This function will clear the contents of the display.
 */
void gfx_mono_st7565r_init(void)
{
     a74:	f4 cf       	rjmp	.-24     	; 0xa5e <gfx_mono_st7565r_init+0x60>
     a76:	0f 90       	pop	r0
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
			gfx_mono_put_byte(page, column, 0x00);
		}
	}
}
     a78:	df 91       	pop	r29
     a7a:	cf 91       	pop	r28
     a7c:	1f 91       	pop	r17
     a7e:	0f 91       	pop	r16
     a80:	08 95       	ret

00000a82 <gfx_mono_st7565r_draw_pixel>:
     a82:	ff 92       	push	r15
	gfx_mono_st7565r_draw_pixel(10, 10, GFX_PIXEL_XOR);
\endcode
 */
void gfx_mono_st7565r_draw_pixel(gfx_coord_t x, gfx_coord_t y,
		gfx_coord_t color)
{
     a84:	0f 93       	push	r16
     a86:	1f 93       	push	r17
     a88:	cf 93       	push	r28
     a8a:	df 93       	push	r29
	uint8_t page;
	uint8_t pixel_mask;
	uint8_t pixel_value;

	/* Discard pixels drawn outside the screen */
	if ((x > GFX_MONO_LCD_WIDTH - 1) || (y > GFX_MONO_LCD_HEIGHT - 1)) {
     a8c:	88 23       	and	r24, r24
     a8e:	4c f1       	brlt	.+82     	; 0xae2 <gfx_mono_st7565r_draw_pixel+0x60>
     a90:	60 32       	cpi	r22, 0x20	; 32
     a92:	38 f5       	brcc	.+78     	; 0xae2 <gfx_mono_st7565r_draw_pixel+0x60>
     a94:	d4 2f       	mov	r29, r20
     a96:	c8 2f       	mov	r28, r24
		return;
	}

	page = y / GFX_MONO_LCD_PIXELS_PER_BYTE;
     a98:	f6 2e       	mov	r15, r22
     a9a:	f6 94       	lsr	r15
     a9c:	f6 94       	lsr	r15
     a9e:	f6 94       	lsr	r15
	pixel_mask = (1 << (y - (page * 8)));
     aa0:	70 e0       	ldi	r23, 0x00	; 0
     aa2:	88 e0       	ldi	r24, 0x08	; 8
     aa4:	f8 9e       	mul	r15, r24
     aa6:	60 19       	sub	r22, r0
     aa8:	71 09       	sbc	r23, r1
     aaa:	11 24       	eor	r1, r1
     aac:	81 e0       	ldi	r24, 0x01	; 1
     aae:	90 e0       	ldi	r25, 0x00	; 0
     ab0:	8c 01       	movw	r16, r24
     ab2:	02 c0       	rjmp	.+4      	; 0xab8 <gfx_mono_st7565r_draw_pixel+0x36>
     ab4:	00 0f       	add	r16, r16
     ab6:	11 1f       	adc	r17, r17
     ab8:	6a 95       	dec	r22
     aba:	e2 f7       	brpl	.-8      	; 0xab4 <gfx_mono_st7565r_draw_pixel+0x32>
\endcode
 */
uint8_t gfx_mono_st7565r_get_byte(gfx_coord_t page, gfx_coord_t column)
{
#ifdef CONFIG_ST7565R_FRAMEBUFFER
	return gfx_mono_framebuffer_get_byte(page, column);
     abc:	6c 2f       	mov	r22, r28
     abe:	8f 2d       	mov	r24, r15
     ac0:	2b d0       	rcall	.+86     	; 0xb18 <gfx_mono_framebuffer_get_byte>
	 * requested action on this pixel before writing the page back to the
	 * display.
	 */
	pixel_value = gfx_mono_get_byte(page, x);

	switch (color) {
     ac2:	d1 30       	cpi	r29, 0x01	; 1
     ac4:	21 f0       	breq	.+8      	; 0xace <gfx_mono_st7565r_draw_pixel+0x4c>
     ac6:	28 f0       	brcs	.+10     	; 0xad2 <gfx_mono_st7565r_draw_pixel+0x50>
     ac8:	d2 30       	cpi	r29, 0x02	; 2
     aca:	31 f0       	breq	.+12     	; 0xad8 <gfx_mono_st7565r_draw_pixel+0x56>
     acc:	06 c0       	rjmp	.+12     	; 0xada <gfx_mono_st7565r_draw_pixel+0x58>
	case GFX_PIXEL_SET:
		pixel_value |= pixel_mask;
     ace:	80 2b       	or	r24, r16
		break;
     ad0:	04 c0       	rjmp	.+8      	; 0xada <gfx_mono_st7565r_draw_pixel+0x58>

	case GFX_PIXEL_CLR:
		pixel_value &= ~pixel_mask;
     ad2:	00 95       	com	r16
     ad4:	80 23       	and	r24, r16
		break;
     ad6:	01 c0       	rjmp	.+2      	; 0xada <gfx_mono_st7565r_draw_pixel+0x58>

	case GFX_PIXEL_XOR:
		pixel_value ^= pixel_mask;
     ad8:	80 27       	eor	r24, r16

	default:
		break;
	}

	gfx_mono_put_byte(page, x, pixel_value);
     ada:	48 2f       	mov	r20, r24
     adc:	6c 2f       	mov	r22, r28
     ade:	8f 2d       	mov	r24, r15
     ae0:	e7 de       	rcall	.-562    	; 0x8b0 <gfx_mono_st7565r_put_byte>
}
     ae2:	df 91       	pop	r29
     ae4:	cf 91       	pop	r28
     ae6:	1f 91       	pop	r17
     ae8:	0f 91       	pop	r16
     aea:	ff 90       	pop	r15
     aec:	08 95       	ret

00000aee <gfx_mono_st7565r_get_byte>:
\endcode
 */
uint8_t gfx_mono_st7565r_get_byte(gfx_coord_t page, gfx_coord_t column)
{
#ifdef CONFIG_ST7565R_FRAMEBUFFER
	return gfx_mono_framebuffer_get_byte(page, column);
     aee:	14 c0       	rjmp	.+40     	; 0xb18 <gfx_mono_framebuffer_get_byte>
	st7565r_set_column_address(column);

	return st7565r_read_data();

#endif
}
     af0:	08 95       	ret

00000af2 <gfx_mono_set_framebuffer>:
	gfx_coord_t *framebuffer_pt = fbpointer +
			((page * GFX_MONO_LCD_WIDTH) + column);
	do {
		*data++ = *framebuffer_pt++;
	} while (--width > 0);
}
     af2:	80 93 b2 22 	sts	0x22B2, r24	; 0x8022b2 <fbpointer>
     af6:	90 93 b3 22 	sts	0x22B3, r25	; 0x8022b3 <fbpointer+0x1>
     afa:	08 95       	ret

00000afc <gfx_mono_framebuffer_put_byte>:
\endcode
 */
void gfx_mono_framebuffer_put_byte(gfx_coord_t page, gfx_coord_t column,
		uint8_t data)
{
	*(fbpointer + (page * GFX_MONO_LCD_WIDTH) + column) = data;
     afc:	20 91 b2 22 	lds	r18, 0x22B2	; 0x8022b2 <fbpointer>
     b00:	30 91 b3 22 	lds	r19, 0x22B3	; 0x8022b3 <fbpointer+0x1>
     b04:	90 e8       	ldi	r25, 0x80	; 128
     b06:	89 9f       	mul	r24, r25
     b08:	20 0d       	add	r18, r0
     b0a:	31 1d       	adc	r19, r1
     b0c:	11 24       	eor	r1, r1
     b0e:	f9 01       	movw	r30, r18
     b10:	e6 0f       	add	r30, r22
     b12:	f1 1d       	adc	r31, r1
     b14:	40 83       	st	Z, r20
     b16:	08 95       	ret

00000b18 <gfx_mono_framebuffer_get_byte>:
	data = gfx_mono_framebuffer_get_byte(0, 0);
\endcode
 */
uint8_t gfx_mono_framebuffer_get_byte(gfx_coord_t page, gfx_coord_t column)
{
	return *(fbpointer + (page * GFX_MONO_LCD_WIDTH) + column);
     b18:	20 91 b2 22 	lds	r18, 0x22B2	; 0x8022b2 <fbpointer>
     b1c:	30 91 b3 22 	lds	r19, 0x22B3	; 0x8022b3 <fbpointer+0x1>
     b20:	90 e8       	ldi	r25, 0x80	; 128
     b22:	89 9f       	mul	r24, r25
     b24:	20 0d       	add	r18, r0
     b26:	31 1d       	adc	r19, r1
     b28:	11 24       	eor	r1, r1
     b2a:	f9 01       	movw	r30, r18
     b2c:	e6 0f       	add	r30, r22
     b2e:	f1 1d       	adc	r31, r1
}
     b30:	80 81       	ld	r24, Z
     b32:	08 95       	ret

00000b34 <gfx_mono_generic_draw_horizontal_line>:
	gfx_mono_draw_horizontal_line(x, y, width, color);
	gfx_mono_draw_horizontal_line(x, y + height - 1, width, color);

	gfx_mono_draw_vertical_line(x, y, height, color);
	gfx_mono_draw_vertical_line(x + width - 1, y, height, color);
}
     b34:	ff 92       	push	r15
     b36:	0f 93       	push	r16
     b38:	1f 93       	push	r17
     b3a:	cf 93       	push	r28
     b3c:	df 93       	push	r29
     b3e:	e4 2f       	mov	r30, r20
     b40:	f0 e0       	ldi	r31, 0x00	; 0
     b42:	e8 0f       	add	r30, r24
     b44:	f1 1d       	adc	r31, r1
     b46:	e1 38       	cpi	r30, 0x81	; 129
     b48:	f1 05       	cpc	r31, r1
     b4a:	1c f0       	brlt	.+6      	; 0xb52 <gfx_mono_generic_draw_horizontal_line+0x1e>
     b4c:	c0 e8       	ldi	r28, 0x80	; 128
     b4e:	4c 2f       	mov	r20, r28
     b50:	48 1b       	sub	r20, r24
     b52:	44 23       	and	r20, r20
     b54:	09 f4       	brne	.+2      	; 0xb58 <gfx_mono_generic_draw_horizontal_line+0x24>
     b56:	4a c0       	rjmp	.+148    	; 0xbec <gfx_mono_generic_draw_horizontal_line+0xb8>
     b58:	d6 2f       	mov	r29, r22
     b5a:	d6 95       	lsr	r29
     b5c:	d6 95       	lsr	r29
     b5e:	d6 95       	lsr	r29
     b60:	70 e0       	ldi	r23, 0x00	; 0
     b62:	98 e0       	ldi	r25, 0x08	; 8
     b64:	d9 9f       	mul	r29, r25
     b66:	60 19       	sub	r22, r0
     b68:	71 09       	sbc	r23, r1
     b6a:	11 24       	eor	r1, r1
     b6c:	e1 e0       	ldi	r30, 0x01	; 1
     b6e:	f0 e0       	ldi	r31, 0x00	; 0
     b70:	df 01       	movw	r26, r30
     b72:	02 c0       	rjmp	.+4      	; 0xb78 <gfx_mono_generic_draw_horizontal_line+0x44>
     b74:	aa 0f       	add	r26, r26
     b76:	bb 1f       	adc	r27, r27
     b78:	6a 95       	dec	r22
     b7a:	e2 f7       	brpl	.-8      	; 0xb74 <gfx_mono_generic_draw_horizontal_line+0x40>
     b7c:	fa 2e       	mov	r15, r26
     b7e:	21 30       	cpi	r18, 0x01	; 1
     b80:	21 f0       	breq	.+8      	; 0xb8a <gfx_mono_generic_draw_horizontal_line+0x56>
     b82:	98 f0       	brcs	.+38     	; 0xbaa <gfx_mono_generic_draw_horizontal_line+0x76>
     b84:	22 30       	cpi	r18, 0x02	; 2
     b86:	19 f1       	breq	.+70     	; 0xbce <gfx_mono_generic_draw_horizontal_line+0x9a>
     b88:	31 c0       	rjmp	.+98     	; 0xbec <gfx_mono_generic_draw_horizontal_line+0xb8>
     b8a:	c4 2f       	mov	r28, r20
     b8c:	1f ef       	ldi	r17, 0xFF	; 255
     b8e:	18 0f       	add	r17, r24
     b90:	01 2f       	mov	r16, r17
     b92:	0c 0f       	add	r16, r28
     b94:	60 2f       	mov	r22, r16
     b96:	8d 2f       	mov	r24, r29
     b98:	aa df       	rcall	.-172    	; 0xaee <gfx_mono_st7565r_get_byte>
     b9a:	4f 2d       	mov	r20, r15
     b9c:	48 2b       	or	r20, r24
     b9e:	60 2f       	mov	r22, r16
     ba0:	8d 2f       	mov	r24, r29
     ba2:	86 de       	rcall	.-756    	; 0x8b0 <gfx_mono_st7565r_put_byte>
     ba4:	c1 50       	subi	r28, 0x01	; 1
     ba6:	a1 f7       	brne	.-24     	; 0xb90 <gfx_mono_generic_draw_horizontal_line+0x5c>
     ba8:	21 c0       	rjmp	.+66     	; 0xbec <gfx_mono_generic_draw_horizontal_line+0xb8>
     baa:	c4 2f       	mov	r28, r20
     bac:	1f ef       	ldi	r17, 0xFF	; 255
     bae:	18 0f       	add	r17, r24
     bb0:	fa 2e       	mov	r15, r26
     bb2:	f0 94       	com	r15
     bb4:	01 2f       	mov	r16, r17
     bb6:	0c 0f       	add	r16, r28
     bb8:	60 2f       	mov	r22, r16
     bba:	8d 2f       	mov	r24, r29
     bbc:	98 df       	rcall	.-208    	; 0xaee <gfx_mono_st7565r_get_byte>
     bbe:	4f 2d       	mov	r20, r15
     bc0:	48 23       	and	r20, r24
     bc2:	60 2f       	mov	r22, r16
     bc4:	8d 2f       	mov	r24, r29
     bc6:	74 de       	rcall	.-792    	; 0x8b0 <gfx_mono_st7565r_put_byte>
     bc8:	c1 50       	subi	r28, 0x01	; 1
     bca:	a1 f7       	brne	.-24     	; 0xbb4 <gfx_mono_generic_draw_horizontal_line+0x80>
     bcc:	0f c0       	rjmp	.+30     	; 0xbec <gfx_mono_generic_draw_horizontal_line+0xb8>
     bce:	c4 2f       	mov	r28, r20
     bd0:	1f ef       	ldi	r17, 0xFF	; 255
     bd2:	18 0f       	add	r17, r24
     bd4:	01 2f       	mov	r16, r17
     bd6:	0c 0f       	add	r16, r28
     bd8:	60 2f       	mov	r22, r16
     bda:	8d 2f       	mov	r24, r29
     bdc:	88 df       	rcall	.-240    	; 0xaee <gfx_mono_st7565r_get_byte>
     bde:	4f 2d       	mov	r20, r15
     be0:	48 27       	eor	r20, r24
     be2:	60 2f       	mov	r22, r16
     be4:	8d 2f       	mov	r24, r29
     be6:	64 de       	rcall	.-824    	; 0x8b0 <gfx_mono_st7565r_put_byte>
     be8:	c1 50       	subi	r28, 0x01	; 1
     bea:	a1 f7       	brne	.-24     	; 0xbd4 <gfx_mono_generic_draw_horizontal_line+0xa0>
     bec:	df 91       	pop	r29
     bee:	cf 91       	pop	r28
     bf0:	1f 91       	pop	r17
     bf2:	0f 91       	pop	r16
     bf4:	ff 90       	pop	r15
     bf6:	08 95       	ret

00000bf8 <gfx_mono_generic_draw_filled_rect>:
 * \param  color       Pixel operation of the line
 */
void gfx_mono_generic_draw_filled_rect(gfx_coord_t x, gfx_coord_t y,
		gfx_coord_t width, gfx_coord_t height,
		enum gfx_mono_color color)
{
     bf8:	ff 92       	push	r15
     bfa:	0f 93       	push	r16
     bfc:	1f 93       	push	r17
     bfe:	cf 93       	push	r28
     c00:	df 93       	push	r29
	if (height == 0) {
     c02:	22 23       	and	r18, r18
     c04:	69 f0       	breq	.+26     	; 0xc20 <gfx_mono_generic_draw_filled_rect+0x28>
     c06:	f4 2e       	mov	r15, r20
     c08:	18 2f       	mov	r17, r24
     c0a:	c2 2f       	mov	r28, r18
		/* Nothing to do. Move along. */
		return;
	}

	while (height-- > 0) {
		gfx_mono_draw_horizontal_line(x, y + height, width, color);
     c0c:	df ef       	ldi	r29, 0xFF	; 255
     c0e:	d6 0f       	add	r29, r22
     c10:	6d 2f       	mov	r22, r29
     c12:	6c 0f       	add	r22, r28
     c14:	20 2f       	mov	r18, r16
     c16:	4f 2d       	mov	r20, r15
     c18:	81 2f       	mov	r24, r17
     c1a:	8c df       	rcall	.-232    	; 0xb34 <gfx_mono_generic_draw_horizontal_line>
     c1c:	c1 50       	subi	r28, 0x01	; 1
	if (height == 0) {
		/* Nothing to do. Move along. */
		return;
	}

	while (height-- > 0) {
     c1e:	c1 f7       	brne	.-16     	; 0xc10 <gfx_mono_generic_draw_filled_rect+0x18>
		gfx_mono_draw_horizontal_line(x, y + height, width, color);
	}
}
     c20:	df 91       	pop	r29
     c22:	cf 91       	pop	r28
     c24:	1f 91       	pop	r17
     c26:	0f 91       	pop	r16
     c28:	ff 90       	pop	r15
     c2a:	08 95       	ret

00000c2c <gfx_mono_draw_char>:
 * \param y        Y coordinate on screen.
 * \param font     Font to draw character in
 */
void gfx_mono_draw_char(const char c, const gfx_coord_t x, const gfx_coord_t y,
		const struct font *font)
{
     c2c:	af 92       	push	r10
     c2e:	bf 92       	push	r11
     c30:	cf 92       	push	r12
     c32:	df 92       	push	r13
     c34:	ef 92       	push	r14
     c36:	ff 92       	push	r15
     c38:	0f 93       	push	r16
     c3a:	1f 93       	push	r17
     c3c:	cf 93       	push	r28
     c3e:	df 93       	push	r29
     c40:	c8 2f       	mov	r28, r24
     c42:	e6 2e       	mov	r14, r22
     c44:	b4 2e       	mov	r11, r20
     c46:	69 01       	movw	r12, r18
	gfx_mono_draw_filled_rect(x, y, font->width, font->height,
     c48:	00 e0       	ldi	r16, 0x00	; 0
     c4a:	f9 01       	movw	r30, r18
     c4c:	24 81       	ldd	r18, Z+4	; 0x04
     c4e:	43 81       	ldd	r20, Z+3	; 0x03
     c50:	6b 2d       	mov	r22, r11
     c52:	8e 2d       	mov	r24, r14
     c54:	d1 df       	rcall	.-94     	; 0xbf8 <gfx_mono_generic_draw_filled_rect>
			GFX_PIXEL_CLR);

	switch (font->type) {
     c56:	f6 01       	movw	r30, r12
     c58:	80 81       	ld	r24, Z
     c5a:	81 11       	cpse	r24, r1
     c5c:	39 c0       	rjmp	.+114    	; 0xcd0 <gfx_mono_draw_char+0xa4>
	Assert(font != NULL);

	gfx_coord_t inc_x = x;
	gfx_coord_t inc_y = y;

	char_row_size = font->width / CONFIG_FONT_PIXELS_PER_BYTE;
     c5e:	83 81       	ldd	r24, Z+3	; 0x03
     c60:	28 2f       	mov	r18, r24
     c62:	26 95       	lsr	r18
     c64:	26 95       	lsr	r18
     c66:	26 95       	lsr	r18
	if (font->width % CONFIG_FONT_PIXELS_PER_BYTE) {
     c68:	87 70       	andi	r24, 0x07	; 7
     c6a:	09 f0       	breq	.+2      	; 0xc6e <gfx_mono_draw_char+0x42>
		char_row_size++;
     c6c:	2f 5f       	subi	r18, 0xFF	; 255
	}

	glyph_data_offset = char_row_size * font->height *
     c6e:	f6 01       	movw	r30, r12
     c70:	a4 80       	ldd	r10, Z+4	; 0x04
			((uint8_t)ch - font->first_char);
	glyph_data = font->data.progmem + glyph_data_offset;
     c72:	8c 2f       	mov	r24, r28
     c74:	90 e0       	ldi	r25, 0x00	; 0
     c76:	35 81       	ldd	r19, Z+5	; 0x05
     c78:	83 1b       	sub	r24, r19
     c7a:	91 09       	sbc	r25, r1
     c7c:	2a 9d       	mul	r18, r10
     c7e:	90 01       	movw	r18, r0
     c80:	11 24       	eor	r1, r1
     c82:	82 9f       	mul	r24, r18
     c84:	a0 01       	movw	r20, r0
     c86:	83 9f       	mul	r24, r19
     c88:	50 0d       	add	r21, r0
     c8a:	92 9f       	mul	r25, r18
     c8c:	50 0d       	add	r21, r0
     c8e:	11 24       	eor	r1, r1
     c90:	01 81       	ldd	r16, Z+1	; 0x01
     c92:	12 81       	ldd	r17, Z+2	; 0x02
     c94:	04 0f       	add	r16, r20
     c96:	15 1f       	adc	r17, r21
	rows_left = font->height;

	do {
		uint8_t glyph_byte = 0;
		uint8_t pixelsToDraw = font->width;
     c98:	f6 01       	movw	r30, r12
     c9a:	f3 80       	ldd	r15, Z+3	; 0x03

		for (i = 0; i < pixelsToDraw; i++) {
     c9c:	ff 20       	and	r15, r15
     c9e:	a1 f0       	breq	.+40     	; 0xcc8 <gfx_mono_draw_char+0x9c>
     ca0:	d0 e0       	ldi	r29, 0x00	; 0
     ca2:	c0 e0       	ldi	r28, 0x00	; 0
     ca4:	8e 2d       	mov	r24, r14
     ca6:	8c 0f       	add	r24, r28
			if (i % CONFIG_FONT_PIXELS_PER_BYTE == 0) {
     ca8:	9c 2f       	mov	r25, r28
     caa:	97 70       	andi	r25, 0x07	; 7
     cac:	21 f4       	brne	.+8      	; 0xcb6 <gfx_mono_draw_char+0x8a>
				glyph_byte = PROGMEM_READ_BYTE(glyph_data);
     cae:	f8 01       	movw	r30, r16
     cb0:	d4 91       	lpm	r29, Z
				glyph_data++;
     cb2:	0f 5f       	subi	r16, 0xFF	; 255
     cb4:	1f 4f       	sbci	r17, 0xFF	; 255
			}

			if ((glyph_byte & 0x80)) {
     cb6:	dd 23       	and	r29, r29
     cb8:	1c f4       	brge	.+6      	; 0xcc0 <gfx_mono_draw_char+0x94>
				gfx_mono_draw_pixel(inc_x, inc_y,
     cba:	41 e0       	ldi	r20, 0x01	; 1
     cbc:	6b 2d       	mov	r22, r11
     cbe:	e1 de       	rcall	.-574    	; 0xa82 <gfx_mono_st7565r_draw_pixel>
						GFX_PIXEL_SET);
			}

			inc_x += 1;
			glyph_byte <<= 1;
     cc0:	dd 0f       	add	r29, r29

	do {
		uint8_t glyph_byte = 0;
		uint8_t pixelsToDraw = font->width;

		for (i = 0; i < pixelsToDraw; i++) {
     cc2:	cf 5f       	subi	r28, 0xFF	; 255
     cc4:	fc 12       	cpse	r15, r28
     cc6:	ee cf       	rjmp	.-36     	; 0xca4 <gfx_mono_draw_char+0x78>

			inc_x += 1;
			glyph_byte <<= 1;
		}

		inc_y += 1;
     cc8:	b3 94       	inc	r11
		inc_x = x;
		rows_left--;
     cca:	aa 94       	dec	r10
	} while (rows_left > 0);
     ccc:	a1 10       	cpse	r10, r1
     cce:	e4 cf       	rjmp	.-56     	; 0xc98 <gfx_mono_draw_char+0x6c>
	default:
		/* Unsupported mode, call assert */
		Assert(false);
		break;
	}
}
     cd0:	df 91       	pop	r29
     cd2:	cf 91       	pop	r28
     cd4:	1f 91       	pop	r17
     cd6:	0f 91       	pop	r16
     cd8:	ff 90       	pop	r15
     cda:	ef 90       	pop	r14
     cdc:	df 90       	pop	r13
     cde:	cf 90       	pop	r12
     ce0:	bf 90       	pop	r11
     ce2:	af 90       	pop	r10
     ce4:	08 95       	ret

00000ce6 <gfx_mono_draw_string>:
 * \param y         Y coordinate on screen.
 * \param font      Font to draw string in
 */
void gfx_mono_draw_string(const char *str, gfx_coord_t x, gfx_coord_t y,
		const struct font *font)
{
     ce6:	df 92       	push	r13
     ce8:	ef 92       	push	r14
     cea:	ff 92       	push	r15
     cec:	0f 93       	push	r16
     cee:	1f 93       	push	r17
     cf0:	cf 93       	push	r28
     cf2:	df 93       	push	r29
     cf4:	d6 2e       	mov	r13, r22
     cf6:	04 2f       	mov	r16, r20
     cf8:	79 01       	movw	r14, r18
     cfa:	ec 01       	movw	r28, r24
     cfc:	16 2f       	mov	r17, r22
	Assert(font != NULL);

	/* Draw characters until trailing null byte */
	do {
		/* Handle '\n' as newline, draw normal characters. */
		if (*str == '\n') {
     cfe:	89 91       	ld	r24, Y+
     d00:	8a 30       	cpi	r24, 0x0A	; 10
     d02:	31 f4       	brne	.+12     	; 0xd10 <gfx_mono_draw_string+0x2a>
			x = start_of_string_position_x;
			y += font->height + 1;
     d04:	f7 01       	movw	r30, r14
     d06:	84 81       	ldd	r24, Z+4	; 0x04
     d08:	8f 5f       	subi	r24, 0xFF	; 255
     d0a:	08 0f       	add	r16, r24

	/* Draw characters until trailing null byte */
	do {
		/* Handle '\n' as newline, draw normal characters. */
		if (*str == '\n') {
			x = start_of_string_position_x;
     d0c:	1d 2d       	mov	r17, r13
     d0e:	09 c0       	rjmp	.+18     	; 0xd22 <gfx_mono_draw_string+0x3c>
			y += font->height + 1;
		} else if (*str == '\r') {
     d10:	8d 30       	cpi	r24, 0x0D	; 13
     d12:	39 f0       	breq	.+14     	; 0xd22 <gfx_mono_draw_string+0x3c>
			/* Skip '\r' characters. */
		} else {
			gfx_mono_draw_char(*str, x, y, font);
     d14:	97 01       	movw	r18, r14
     d16:	40 2f       	mov	r20, r16
     d18:	61 2f       	mov	r22, r17
     d1a:	88 df       	rcall	.-240    	; 0xc2c <gfx_mono_draw_char>
			x += font->width;
     d1c:	f7 01       	movw	r30, r14
     d1e:	83 81       	ldd	r24, Z+3	; 0x03
     d20:	18 0f       	add	r17, r24
		}
	} while (*(++str));
     d22:	88 81       	ld	r24, Y
     d24:	81 11       	cpse	r24, r1
     d26:	eb cf       	rjmp	.-42     	; 0xcfe <gfx_mono_draw_string+0x18>
}
     d28:	df 91       	pop	r29
     d2a:	cf 91       	pop	r28
     d2c:	1f 91       	pop	r17
     d2e:	0f 91       	pop	r16
     d30:	ff 90       	pop	r15
     d32:	ef 90       	pop	r14
     d34:	df 90       	pop	r13
     d36:	08 95       	ret

00000d38 <ioport_configure_port_pin>:
#include "ioport_compat.h"

#if defined(IOPORT_XMEGA_COMPAT)
void ioport_configure_port_pin(void *port, pin_mask_t pin_mask,
		port_pin_flags_t flags)
{
     d38:	cf 93       	push	r28
     d3a:	df 93       	push	r29
     d3c:	fc 01       	movw	r30, r24
	uint8_t pin;

	for (pin = 0; pin < 8; pin++) {
		if (pin_mask & (1 << pin)) {
			*((uint8_t *)port + PORT_PIN0CTRL + pin) = flags >> 8;
     d3e:	20 e0       	ldi	r18, 0x00	; 0
     d40:	30 e0       	ldi	r19, 0x00	; 0
		port_pin_flags_t flags)
{
	uint8_t pin;

	for (pin = 0; pin < 8; pin++) {
		if (pin_mask & (1 << pin)) {
     d42:	c6 2f       	mov	r28, r22
     d44:	d0 e0       	ldi	r29, 0x00	; 0
     d46:	de 01       	movw	r26, r28
     d48:	02 2e       	mov	r0, r18
     d4a:	02 c0       	rjmp	.+4      	; 0xd50 <ioport_configure_port_pin+0x18>
     d4c:	b5 95       	asr	r27
     d4e:	a7 95       	ror	r26
     d50:	0a 94       	dec	r0
     d52:	e2 f7       	brpl	.-8      	; 0xd4c <ioport_configure_port_pin+0x14>
     d54:	a0 fd       	sbrc	r26, 0
			*((uint8_t *)port + PORT_PIN0CTRL + pin) = flags >> 8;
     d56:	50 8b       	std	Z+16, r21	; 0x10
     d58:	2f 5f       	subi	r18, 0xFF	; 255
     d5a:	3f 4f       	sbci	r19, 0xFF	; 255
     d5c:	31 96       	adiw	r30, 0x01	; 1
void ioport_configure_port_pin(void *port, pin_mask_t pin_mask,
		port_pin_flags_t flags)
{
	uint8_t pin;

	for (pin = 0; pin < 8; pin++) {
     d5e:	28 30       	cpi	r18, 0x08	; 8
     d60:	31 05       	cpc	r19, r1
     d62:	89 f7       	brne	.-30     	; 0xd46 <ioport_configure_port_pin+0xe>
		if (pin_mask & (1 << pin)) {
			*((uint8_t *)port + PORT_PIN0CTRL + pin) = flags >> 8;
		}
	}
	/* Select direction and initial pin state */
	if (flags & IOPORT_DIR_OUTPUT) {
     d64:	40 ff       	sbrs	r20, 0
     d66:	0a c0       	rjmp	.+20     	; 0xd7c <ioport_configure_port_pin+0x44>
		if (flags & IOPORT_INIT_HIGH) {
     d68:	41 ff       	sbrs	r20, 1
     d6a:	03 c0       	rjmp	.+6      	; 0xd72 <ioport_configure_port_pin+0x3a>
			*((uint8_t *)port + PORT_OUTSET) = pin_mask;
     d6c:	fc 01       	movw	r30, r24
     d6e:	65 83       	std	Z+5, r22	; 0x05
     d70:	02 c0       	rjmp	.+4      	; 0xd76 <ioport_configure_port_pin+0x3e>
		} else {
			*((uint8_t *)port + PORT_OUTCLR) = pin_mask;
     d72:	fc 01       	movw	r30, r24
     d74:	66 83       	std	Z+6, r22	; 0x06
		}

		*((uint8_t *)port + PORT_DIRSET) = pin_mask;
     d76:	fc 01       	movw	r30, r24
     d78:	61 83       	std	Z+1, r22	; 0x01
     d7a:	02 c0       	rjmp	.+4      	; 0xd80 <ioport_configure_port_pin+0x48>
	} else {
		*((uint8_t *)port + PORT_DIRCLR) = pin_mask;
     d7c:	fc 01       	movw	r30, r24
     d7e:	62 83       	std	Z+2, r22	; 0x02
	}
}
     d80:	df 91       	pop	r29
     d82:	cf 91       	pop	r28
     d84:	08 95       	ret

00000d86 <usart_spi_init>:
     d86:	80 3a       	cpi	r24, 0xA0	; 160
     d88:	28 e0       	ldi	r18, 0x08	; 8
     d8a:	92 07       	cpc	r25, r18
     d8c:	21 f4       	brne	.+8      	; 0xd96 <usart_spi_init+0x10>
     d8e:	60 e1       	ldi	r22, 0x10	; 16
     d90:	83 e0       	ldi	r24, 0x03	; 3
     d92:	78 cd       	rjmp	.-1296   	; 0x884 <sysclk_enable_module>
     d94:	08 95       	ret
     d96:	80 3b       	cpi	r24, 0xB0	; 176
     d98:	28 e0       	ldi	r18, 0x08	; 8
     d9a:	92 07       	cpc	r25, r18
     d9c:	21 f4       	brne	.+8      	; 0xda6 <usart_spi_init+0x20>
     d9e:	60 e2       	ldi	r22, 0x20	; 32
     da0:	83 e0       	ldi	r24, 0x03	; 3
     da2:	70 cd       	rjmp	.-1312   	; 0x884 <sysclk_enable_module>
     da4:	08 95       	ret
     da6:	80 3a       	cpi	r24, 0xA0	; 160
     da8:	29 e0       	ldi	r18, 0x09	; 9
     daa:	92 07       	cpc	r25, r18
     dac:	21 f4       	brne	.+8      	; 0xdb6 <usart_spi_init+0x30>
     dae:	60 e1       	ldi	r22, 0x10	; 16
     db0:	84 e0       	ldi	r24, 0x04	; 4
     db2:	68 cd       	rjmp	.-1328   	; 0x884 <sysclk_enable_module>
     db4:	08 95       	ret
     db6:	80 3b       	cpi	r24, 0xB0	; 176
     db8:	29 e0       	ldi	r18, 0x09	; 9
     dba:	92 07       	cpc	r25, r18
     dbc:	21 f4       	brne	.+8      	; 0xdc6 <usart_spi_init+0x40>
     dbe:	60 e2       	ldi	r22, 0x20	; 32
     dc0:	84 e0       	ldi	r24, 0x04	; 4
     dc2:	60 cd       	rjmp	.-1344   	; 0x884 <sysclk_enable_module>
     dc4:	08 95       	ret
     dc6:	80 3a       	cpi	r24, 0xA0	; 160
     dc8:	2a e0       	ldi	r18, 0x0A	; 10
     dca:	92 07       	cpc	r25, r18
     dcc:	21 f4       	brne	.+8      	; 0xdd6 <usart_spi_init+0x50>
     dce:	60 e1       	ldi	r22, 0x10	; 16
     dd0:	85 e0       	ldi	r24, 0x05	; 5
     dd2:	58 cd       	rjmp	.-1360   	; 0x884 <sysclk_enable_module>
     dd4:	08 95       	ret
     dd6:	80 3a       	cpi	r24, 0xA0	; 160
     dd8:	9b 40       	sbci	r25, 0x0B	; 11
     dda:	19 f4       	brne	.+6      	; 0xde2 <usart_spi_init+0x5c>
     ddc:	60 e1       	ldi	r22, 0x10	; 16
     dde:	86 e0       	ldi	r24, 0x06	; 6
     de0:	51 cd       	rjmp	.-1374   	; 0x884 <sysclk_enable_module>
     de2:	08 95       	ret

00000de4 <usart_spi_setup_device>:
     de4:	0f 93       	push	r16
     de6:	1f 93       	push	r17
     de8:	cf 93       	push	r28
     dea:	df 93       	push	r29
     dec:	00 d0       	rcall	.+0      	; 0xdee <usart_spi_setup_device+0xa>
     dee:	00 d0       	rcall	.+0      	; 0xdf0 <usart_spi_setup_device+0xc>
     df0:	cd b7       	in	r28, 0x3d	; 61
     df2:	de b7       	in	r29, 0x3e	; 62
     df4:	09 83       	std	Y+1, r16	; 0x01
     df6:	1a 83       	std	Y+2, r17	; 0x02
     df8:	2b 83       	std	Y+3, r18	; 0x03
     dfa:	3c 83       	std	Y+4, r19	; 0x04
     dfc:	4d 83       	std	Y+5, r20	; 0x05
     dfe:	1e 82       	std	Y+6, r1	; 0x06
     e00:	be 01       	movw	r22, r28
     e02:	6f 5f       	subi	r22, 0xFF	; 255
     e04:	7f 4f       	sbci	r23, 0xFF	; 255
     e06:	03 d1       	rcall	.+518    	; 0x100e <usart_init_spi>
     e08:	26 96       	adiw	r28, 0x06	; 6
     e0a:	cd bf       	out	0x3d, r28	; 61
     e0c:	de bf       	out	0x3e, r29	; 62
     e0e:	df 91       	pop	r29
     e10:	cf 91       	pop	r28
     e12:	1f 91       	pop	r17
     e14:	0f 91       	pop	r16
     e16:	08 95       	ret

00000e18 <usart_spi_select_device>:
     e18:	fb 01       	movw	r30, r22
     e1a:	80 81       	ld	r24, Z
     e1c:	e8 2f       	mov	r30, r24
     e1e:	e6 95       	lsr	r30
     e20:	e6 95       	lsr	r30
     e22:	e6 95       	lsr	r30
     e24:	40 e2       	ldi	r20, 0x20	; 32
     e26:	e4 9f       	mul	r30, r20
     e28:	f0 01       	movw	r30, r0
     e2a:	11 24       	eor	r1, r1
     e2c:	fa 5f       	subi	r31, 0xFA	; 250
     e2e:	87 70       	andi	r24, 0x07	; 7
     e30:	21 e0       	ldi	r18, 0x01	; 1
     e32:	30 e0       	ldi	r19, 0x00	; 0
     e34:	a9 01       	movw	r20, r18
     e36:	02 c0       	rjmp	.+4      	; 0xe3c <usart_spi_select_device+0x24>
     e38:	44 0f       	add	r20, r20
     e3a:	55 1f       	adc	r21, r21
     e3c:	8a 95       	dec	r24
     e3e:	e2 f7       	brpl	.-8      	; 0xe38 <usart_spi_select_device+0x20>
     e40:	46 83       	std	Z+6, r20	; 0x06
     e42:	08 95       	ret

00000e44 <usart_spi_deselect_device>:
     e44:	fb 01       	movw	r30, r22
     e46:	80 81       	ld	r24, Z
     e48:	e8 2f       	mov	r30, r24
     e4a:	e6 95       	lsr	r30
     e4c:	e6 95       	lsr	r30
     e4e:	e6 95       	lsr	r30
     e50:	40 e2       	ldi	r20, 0x20	; 32
     e52:	e4 9f       	mul	r30, r20
     e54:	f0 01       	movw	r30, r0
     e56:	11 24       	eor	r1, r1
     e58:	fa 5f       	subi	r31, 0xFA	; 250
     e5a:	87 70       	andi	r24, 0x07	; 7
     e5c:	21 e0       	ldi	r18, 0x01	; 1
     e5e:	30 e0       	ldi	r19, 0x00	; 0
     e60:	a9 01       	movw	r20, r18
     e62:	02 c0       	rjmp	.+4      	; 0xe68 <usart_spi_deselect_device+0x24>
     e64:	44 0f       	add	r20, r20
     e66:	55 1f       	adc	r21, r21
     e68:	8a 95       	dec	r24
     e6a:	e2 f7       	brpl	.-8      	; 0xe64 <usart_spi_deselect_device+0x20>
     e6c:	45 83       	std	Z+5, r20	; 0x05
     e6e:	08 95       	ret

00000e70 <board_init>:
     e70:	43 e0       	ldi	r20, 0x03	; 3
     e72:	50 e0       	ldi	r21, 0x00	; 0
     e74:	61 e0       	ldi	r22, 0x01	; 1
     e76:	80 ee       	ldi	r24, 0xE0	; 224
     e78:	97 e0       	ldi	r25, 0x07	; 7
     e7a:	5e df       	rcall	.-324    	; 0xd38 <ioport_configure_port_pin>
     e7c:	43 e0       	ldi	r20, 0x03	; 3
     e7e:	50 e0       	ldi	r21, 0x00	; 0
     e80:	62 e0       	ldi	r22, 0x02	; 2
     e82:	80 ee       	ldi	r24, 0xE0	; 224
     e84:	97 e0       	ldi	r25, 0x07	; 7
     e86:	58 df       	rcall	.-336    	; 0xd38 <ioport_configure_port_pin>
     e88:	43 e0       	ldi	r20, 0x03	; 3
     e8a:	50 e0       	ldi	r21, 0x00	; 0
     e8c:	60 e1       	ldi	r22, 0x10	; 16
     e8e:	80 e6       	ldi	r24, 0x60	; 96
     e90:	96 e0       	ldi	r25, 0x06	; 6
     e92:	52 df       	rcall	.-348    	; 0xd38 <ioport_configure_port_pin>
     e94:	41 e0       	ldi	r20, 0x01	; 1
     e96:	50 e4       	ldi	r21, 0x40	; 64
     e98:	60 e2       	ldi	r22, 0x20	; 32
     e9a:	80 e6       	ldi	r24, 0x60	; 96
     e9c:	96 e0       	ldi	r25, 0x06	; 6
     e9e:	4c df       	rcall	.-360    	; 0xd38 <ioport_configure_port_pin>
     ea0:	40 e0       	ldi	r20, 0x00	; 0
     ea2:	5b e1       	ldi	r21, 0x1B	; 27
     ea4:	60 e2       	ldi	r22, 0x20	; 32
     ea6:	80 e8       	ldi	r24, 0x80	; 128
     ea8:	96 e0       	ldi	r25, 0x06	; 6
     eaa:	46 df       	rcall	.-372    	; 0xd38 <ioport_configure_port_pin>
     eac:	40 e0       	ldi	r20, 0x00	; 0
     eae:	5b e1       	ldi	r21, 0x1B	; 27
     eb0:	62 e0       	ldi	r22, 0x02	; 2
     eb2:	80 ea       	ldi	r24, 0xA0	; 160
     eb4:	96 e0       	ldi	r25, 0x06	; 6
     eb6:	40 df       	rcall	.-384    	; 0xd38 <ioport_configure_port_pin>
     eb8:	40 e0       	ldi	r20, 0x00	; 0
     eba:	5b e1       	ldi	r21, 0x1B	; 27
     ebc:	64 e0       	ldi	r22, 0x04	; 4
     ebe:	80 ea       	ldi	r24, 0xA0	; 160
     ec0:	96 e0       	ldi	r25, 0x06	; 6
     ec2:	3a df       	rcall	.-396    	; 0xd38 <ioport_configure_port_pin>
     ec4:	43 e0       	ldi	r20, 0x03	; 3
     ec6:	50 e0       	ldi	r21, 0x00	; 0
     ec8:	62 e0       	ldi	r22, 0x02	; 2
     eca:	80 e6       	ldi	r24, 0x60	; 96
     ecc:	96 e0       	ldi	r25, 0x06	; 6
     ece:	34 df       	rcall	.-408    	; 0xd38 <ioport_configure_port_pin>
     ed0:	43 e0       	ldi	r20, 0x03	; 3
     ed2:	50 e0       	ldi	r21, 0x00	; 0
     ed4:	68 e0       	ldi	r22, 0x08	; 8
     ed6:	80 e6       	ldi	r24, 0x60	; 96
     ed8:	96 e0       	ldi	r25, 0x06	; 6
     eda:	2e df       	rcall	.-420    	; 0xd38 <ioport_configure_port_pin>
     edc:	43 e0       	ldi	r20, 0x03	; 3
     ede:	50 e0       	ldi	r21, 0x00	; 0
     ee0:	68 e0       	ldi	r22, 0x08	; 8
     ee2:	80 ea       	ldi	r24, 0xA0	; 160
     ee4:	96 e0       	ldi	r25, 0x06	; 6
     ee6:	28 df       	rcall	.-432    	; 0xd38 <ioport_configure_port_pin>
     ee8:	43 e0       	ldi	r20, 0x03	; 3
     eea:	50 e0       	ldi	r21, 0x00	; 0
     eec:	61 e0       	ldi	r22, 0x01	; 1
     eee:	80 e6       	ldi	r24, 0x60	; 96
     ef0:	96 e0       	ldi	r25, 0x06	; 6
     ef2:	22 df       	rcall	.-444    	; 0xd38 <ioport_configure_port_pin>
     ef4:	43 e0       	ldi	r20, 0x03	; 3
     ef6:	50 e0       	ldi	r21, 0x00	; 0
     ef8:	68 e0       	ldi	r22, 0x08	; 8
     efa:	80 e0       	ldi	r24, 0x00	; 0
     efc:	96 e0       	ldi	r25, 0x06	; 6
     efe:	1c df       	rcall	.-456    	; 0xd38 <ioport_configure_port_pin>
     f00:	41 e0       	ldi	r20, 0x01	; 1
     f02:	50 e0       	ldi	r21, 0x00	; 0
     f04:	60 e1       	ldi	r22, 0x10	; 16
     f06:	80 e8       	ldi	r24, 0x80	; 128
     f08:	96 e0       	ldi	r25, 0x06	; 6
     f0a:	16 df       	rcall	.-468    	; 0xd38 <ioport_configure_port_pin>
     f0c:	43 e0       	ldi	r20, 0x03	; 3
     f0e:	50 e0       	ldi	r21, 0x00	; 0
     f10:	62 e0       	ldi	r22, 0x02	; 2
     f12:	80 e6       	ldi	r24, 0x60	; 96
     f14:	96 e0       	ldi	r25, 0x06	; 6
     f16:	10 df       	rcall	.-480    	; 0xd38 <ioport_configure_port_pin>
     f18:	43 e0       	ldi	r20, 0x03	; 3
     f1a:	50 e0       	ldi	r21, 0x00	; 0
     f1c:	68 e0       	ldi	r22, 0x08	; 8
     f1e:	80 e6       	ldi	r24, 0x60	; 96
     f20:	96 e0       	ldi	r25, 0x06	; 6
     f22:	0a df       	rcall	.-492    	; 0xd38 <ioport_configure_port_pin>
     f24:	40 e0       	ldi	r20, 0x00	; 0
     f26:	50 e0       	ldi	r21, 0x00	; 0
     f28:	64 e0       	ldi	r22, 0x04	; 4
     f2a:	80 e6       	ldi	r24, 0x60	; 96
     f2c:	96 e0       	ldi	r25, 0x06	; 6
     f2e:	04 df       	rcall	.-504    	; 0xd38 <ioport_configure_port_pin>
     f30:	43 e0       	ldi	r20, 0x03	; 3
     f32:	50 e0       	ldi	r21, 0x00	; 0
     f34:	60 e1       	ldi	r22, 0x10	; 16
     f36:	80 ea       	ldi	r24, 0xA0	; 160
     f38:	96 e0       	ldi	r25, 0x06	; 6
     f3a:	fe de       	rcall	.-516    	; 0xd38 <ioport_configure_port_pin>
     f3c:	40 e0       	ldi	r20, 0x00	; 0
     f3e:	50 e0       	ldi	r21, 0x00	; 0
     f40:	61 e0       	ldi	r22, 0x01	; 1
     f42:	80 e0       	ldi	r24, 0x00	; 0
     f44:	96 e0       	ldi	r25, 0x06	; 6
     f46:	f8 de       	rcall	.-528    	; 0xd38 <ioport_configure_port_pin>
     f48:	40 e0       	ldi	r20, 0x00	; 0
     f4a:	50 e0       	ldi	r21, 0x00	; 0
     f4c:	64 e0       	ldi	r22, 0x04	; 4
     f4e:	80 e0       	ldi	r24, 0x00	; 0
     f50:	96 e0       	ldi	r25, 0x06	; 6
     f52:	f2 de       	rcall	.-540    	; 0xd38 <ioport_configure_port_pin>
     f54:	40 e0       	ldi	r20, 0x00	; 0
     f56:	50 e0       	ldi	r21, 0x00	; 0
     f58:	62 e0       	ldi	r22, 0x02	; 2
     f5a:	80 e2       	ldi	r24, 0x20	; 32
     f5c:	96 e0       	ldi	r25, 0x06	; 6
     f5e:	ec de       	rcall	.-552    	; 0xd38 <ioport_configure_port_pin>
     f60:	43 e0       	ldi	r20, 0x03	; 3
     f62:	50 e0       	ldi	r21, 0x00	; 0
     f64:	68 e0       	ldi	r22, 0x08	; 8
     f66:	80 e4       	ldi	r24, 0x40	; 64
     f68:	96 e0       	ldi	r25, 0x06	; 6
     f6a:	e6 de       	rcall	.-564    	; 0xd38 <ioport_configure_port_pin>
     f6c:	40 e0       	ldi	r20, 0x00	; 0
     f6e:	50 e0       	ldi	r21, 0x00	; 0
     f70:	64 e0       	ldi	r22, 0x04	; 4
     f72:	80 e4       	ldi	r24, 0x40	; 64
     f74:	96 e0       	ldi	r25, 0x06	; 6
     f76:	e0 de       	rcall	.-576    	; 0xd38 <ioport_configure_port_pin>
     f78:	43 e0       	ldi	r20, 0x03	; 3
     f7a:	50 e0       	ldi	r21, 0x00	; 0
     f7c:	68 e0       	ldi	r22, 0x08	; 8
     f7e:	80 e6       	ldi	r24, 0x60	; 96
     f80:	96 e0       	ldi	r25, 0x06	; 6
     f82:	da de       	rcall	.-588    	; 0xd38 <ioport_configure_port_pin>
     f84:	40 e0       	ldi	r20, 0x00	; 0
     f86:	50 e0       	ldi	r21, 0x00	; 0
     f88:	64 e0       	ldi	r22, 0x04	; 4
     f8a:	80 e6       	ldi	r24, 0x60	; 96
     f8c:	96 e0       	ldi	r25, 0x06	; 6
     f8e:	d4 de       	rcall	.-600    	; 0xd38 <ioport_configure_port_pin>
     f90:	43 e0       	ldi	r20, 0x03	; 3
     f92:	50 e0       	ldi	r21, 0x00	; 0
     f94:	68 e0       	ldi	r22, 0x08	; 8
     f96:	80 e8       	ldi	r24, 0x80	; 128
     f98:	96 e0       	ldi	r25, 0x06	; 6
     f9a:	ce de       	rcall	.-612    	; 0xd38 <ioport_configure_port_pin>
     f9c:	40 e0       	ldi	r20, 0x00	; 0
     f9e:	50 e0       	ldi	r21, 0x00	; 0
     fa0:	64 e0       	ldi	r22, 0x04	; 4
     fa2:	80 e8       	ldi	r24, 0x80	; 128
     fa4:	96 e0       	ldi	r25, 0x06	; 6
     fa6:	c8 ce       	rjmp	.-624    	; 0xd38 <ioport_configure_port_pin>
     fa8:	08 95       	ret

00000faa <usart_spi_set_baudrate>:
     faa:	cf 92       	push	r12
     fac:	df 92       	push	r13
     fae:	ef 92       	push	r14
     fb0:	ff 92       	push	r15
     fb2:	0f 93       	push	r16
     fb4:	1f 93       	push	r17
     fb6:	cf 93       	push	r28
     fb8:	df 93       	push	r29
     fba:	ec 01       	movw	r28, r24
     fbc:	d9 01       	movw	r26, r18
     fbe:	c8 01       	movw	r24, r16
     fc0:	b6 95       	lsr	r27
     fc2:	a7 95       	ror	r26
     fc4:	97 95       	ror	r25
     fc6:	87 95       	ror	r24
     fc8:	48 17       	cp	r20, r24
     fca:	59 07       	cpc	r21, r25
     fcc:	6a 07       	cpc	r22, r26
     fce:	7b 07       	cpc	r23, r27
     fd0:	78 f4       	brcc	.+30     	; 0xff0 <usart_spi_set_baudrate+0x46>
     fd2:	6a 01       	movw	r12, r20
     fd4:	7b 01       	movw	r14, r22
     fd6:	cc 0c       	add	r12, r12
     fd8:	dd 1c       	adc	r13, r13
     fda:	ee 1c       	adc	r14, r14
     fdc:	ff 1c       	adc	r15, r15
     fde:	c9 01       	movw	r24, r18
     fe0:	b8 01       	movw	r22, r16
     fe2:	a7 01       	movw	r20, r14
     fe4:	96 01       	movw	r18, r12
     fe6:	0e 94 36 17 	call	0x2e6c	; 0x2e6c <__udivmodsi4>
     fea:	21 50       	subi	r18, 0x01	; 1
     fec:	31 09       	sbc	r19, r1
     fee:	02 c0       	rjmp	.+4      	; 0xff4 <usart_spi_set_baudrate+0x4a>
     ff0:	20 e0       	ldi	r18, 0x00	; 0
     ff2:	30 e0       	ldi	r19, 0x00	; 0
     ff4:	83 2f       	mov	r24, r19
     ff6:	8f 70       	andi	r24, 0x0F	; 15
     ff8:	8f 83       	std	Y+7, r24	; 0x07
     ffa:	2e 83       	std	Y+6, r18	; 0x06
     ffc:	df 91       	pop	r29
     ffe:	cf 91       	pop	r28
    1000:	1f 91       	pop	r17
    1002:	0f 91       	pop	r16
    1004:	ff 90       	pop	r15
    1006:	ef 90       	pop	r14
    1008:	df 90       	pop	r13
    100a:	cf 90       	pop	r12
    100c:	08 95       	ret

0000100e <usart_init_spi>:
    100e:	df 92       	push	r13
    1010:	ef 92       	push	r14
    1012:	ff 92       	push	r15
    1014:	0f 93       	push	r16
    1016:	1f 93       	push	r17
    1018:	cf 93       	push	r28
    101a:	df 93       	push	r29
    101c:	1f 92       	push	r1
    101e:	cd b7       	in	r28, 0x3d	; 61
    1020:	de b7       	in	r29, 0x3e	; 62
    1022:	7c 01       	movw	r14, r24
    1024:	8b 01       	movw	r16, r22
    1026:	00 97       	sbiw	r24, 0x00	; 0
    1028:	09 f4       	brne	.+2      	; 0x102c <usart_init_spi+0x1e>
    102a:	b2 c1       	rjmp	.+868    	; 0x1390 <usart_init_spi+0x382>
    102c:	80 3c       	cpi	r24, 0xC0	; 192
    102e:	91 05       	cpc	r25, r1
    1030:	21 f4       	brne	.+8      	; 0x103a <usart_init_spi+0x2c>
    1032:	60 e1       	ldi	r22, 0x10	; 16
    1034:	80 e0       	ldi	r24, 0x00	; 0
    1036:	26 dc       	rcall	.-1972   	; 0x884 <sysclk_enable_module>
    1038:	ab c1       	rjmp	.+854    	; 0x1390 <usart_init_spi+0x382>
    103a:	80 e8       	ldi	r24, 0x80	; 128
    103c:	e8 16       	cp	r14, r24
    103e:	81 e0       	ldi	r24, 0x01	; 1
    1040:	f8 06       	cpc	r15, r24
    1042:	21 f4       	brne	.+8      	; 0x104c <usart_init_spi+0x3e>
    1044:	62 e0       	ldi	r22, 0x02	; 2
    1046:	80 e0       	ldi	r24, 0x00	; 0
    1048:	1d dc       	rcall	.-1990   	; 0x884 <sysclk_enable_module>
    104a:	a2 c1       	rjmp	.+836    	; 0x1390 <usart_init_spi+0x382>
    104c:	e1 14       	cp	r14, r1
    104e:	e1 e0       	ldi	r30, 0x01	; 1
    1050:	fe 06       	cpc	r15, r30
    1052:	21 f4       	brne	.+8      	; 0x105c <usart_init_spi+0x4e>
    1054:	61 e0       	ldi	r22, 0x01	; 1
    1056:	80 e0       	ldi	r24, 0x00	; 0
    1058:	15 dc       	rcall	.-2006   	; 0x884 <sysclk_enable_module>
    105a:	9a c1       	rjmp	.+820    	; 0x1390 <usart_init_spi+0x382>
    105c:	f0 e8       	ldi	r31, 0x80	; 128
    105e:	ef 16       	cp	r14, r31
    1060:	f3 e0       	ldi	r31, 0x03	; 3
    1062:	ff 06       	cpc	r15, r31
    1064:	21 f4       	brne	.+8      	; 0x106e <usart_init_spi+0x60>
    1066:	61 e0       	ldi	r22, 0x01	; 1
    1068:	81 e0       	ldi	r24, 0x01	; 1
    106a:	0c dc       	rcall	.-2024   	; 0x884 <sysclk_enable_module>
    106c:	91 c1       	rjmp	.+802    	; 0x1390 <usart_init_spi+0x382>
    106e:	30 e9       	ldi	r19, 0x90	; 144
    1070:	e3 16       	cp	r14, r19
    1072:	33 e0       	ldi	r19, 0x03	; 3
    1074:	f3 06       	cpc	r15, r19
    1076:	21 f4       	brne	.+8      	; 0x1080 <usart_init_spi+0x72>
    1078:	61 e0       	ldi	r22, 0x01	; 1
    107a:	82 e0       	ldi	r24, 0x02	; 2
    107c:	03 dc       	rcall	.-2042   	; 0x884 <sysclk_enable_module>
    107e:	88 c1       	rjmp	.+784    	; 0x1390 <usart_init_spi+0x382>
    1080:	e1 14       	cp	r14, r1
    1082:	82 e0       	ldi	r24, 0x02	; 2
    1084:	f8 06       	cpc	r15, r24
    1086:	21 f4       	brne	.+8      	; 0x1090 <usart_init_spi+0x82>
    1088:	62 e0       	ldi	r22, 0x02	; 2
    108a:	81 e0       	ldi	r24, 0x01	; 1
    108c:	fb db       	rcall	.-2058   	; 0x884 <sysclk_enable_module>
    108e:	80 c1       	rjmp	.+768    	; 0x1390 <usart_init_spi+0x382>
    1090:	e0 e4       	ldi	r30, 0x40	; 64
    1092:	ee 16       	cp	r14, r30
    1094:	e2 e0       	ldi	r30, 0x02	; 2
    1096:	fe 06       	cpc	r15, r30
    1098:	21 f4       	brne	.+8      	; 0x10a2 <usart_init_spi+0x94>
    109a:	62 e0       	ldi	r22, 0x02	; 2
    109c:	82 e0       	ldi	r24, 0x02	; 2
    109e:	f2 db       	rcall	.-2076   	; 0x884 <sysclk_enable_module>
    10a0:	77 c1       	rjmp	.+750    	; 0x1390 <usart_init_spi+0x382>
    10a2:	f0 e2       	ldi	r31, 0x20	; 32
    10a4:	ef 16       	cp	r14, r31
    10a6:	f3 e0       	ldi	r31, 0x03	; 3
    10a8:	ff 06       	cpc	r15, r31
    10aa:	21 f4       	brne	.+8      	; 0x10b4 <usart_init_spi+0xa6>
    10ac:	64 e0       	ldi	r22, 0x04	; 4
    10ae:	82 e0       	ldi	r24, 0x02	; 2
    10b0:	e9 db       	rcall	.-2094   	; 0x884 <sysclk_enable_module>
    10b2:	6e c1       	rjmp	.+732    	; 0x1390 <usart_init_spi+0x382>
    10b4:	e1 14       	cp	r14, r1
    10b6:	38 e0       	ldi	r19, 0x08	; 8
    10b8:	f3 06       	cpc	r15, r19
    10ba:	21 f4       	brne	.+8      	; 0x10c4 <usart_init_spi+0xb6>
    10bc:	61 e0       	ldi	r22, 0x01	; 1
    10be:	83 e0       	ldi	r24, 0x03	; 3
    10c0:	e1 db       	rcall	.-2110   	; 0x884 <sysclk_enable_module>
    10c2:	66 c1       	rjmp	.+716    	; 0x1390 <usart_init_spi+0x382>
    10c4:	e1 14       	cp	r14, r1
    10c6:	89 e0       	ldi	r24, 0x09	; 9
    10c8:	f8 06       	cpc	r15, r24
    10ca:	21 f4       	brne	.+8      	; 0x10d4 <usart_init_spi+0xc6>
    10cc:	61 e0       	ldi	r22, 0x01	; 1
    10ce:	84 e0       	ldi	r24, 0x04	; 4
    10d0:	d9 db       	rcall	.-2126   	; 0x884 <sysclk_enable_module>
    10d2:	5e c1       	rjmp	.+700    	; 0x1390 <usart_init_spi+0x382>
    10d4:	e1 14       	cp	r14, r1
    10d6:	ea e0       	ldi	r30, 0x0A	; 10
    10d8:	fe 06       	cpc	r15, r30
    10da:	21 f4       	brne	.+8      	; 0x10e4 <usart_init_spi+0xd6>
    10dc:	61 e0       	ldi	r22, 0x01	; 1
    10de:	85 e0       	ldi	r24, 0x05	; 5
    10e0:	d1 db       	rcall	.-2142   	; 0x884 <sysclk_enable_module>
    10e2:	56 c1       	rjmp	.+684    	; 0x1390 <usart_init_spi+0x382>
    10e4:	e1 14       	cp	r14, r1
    10e6:	fb e0       	ldi	r31, 0x0B	; 11
    10e8:	ff 06       	cpc	r15, r31
    10ea:	21 f4       	brne	.+8      	; 0x10f4 <usart_init_spi+0xe6>
    10ec:	61 e0       	ldi	r22, 0x01	; 1
    10ee:	86 e0       	ldi	r24, 0x06	; 6
    10f0:	c9 db       	rcall	.-2158   	; 0x884 <sysclk_enable_module>
    10f2:	4e c1       	rjmp	.+668    	; 0x1390 <usart_init_spi+0x382>
    10f4:	30 e4       	ldi	r19, 0x40	; 64
    10f6:	e3 16       	cp	r14, r19
    10f8:	38 e0       	ldi	r19, 0x08	; 8
    10fa:	f3 06       	cpc	r15, r19
    10fc:	21 f4       	brne	.+8      	; 0x1106 <usart_init_spi+0xf8>
    10fe:	62 e0       	ldi	r22, 0x02	; 2
    1100:	83 e0       	ldi	r24, 0x03	; 3
    1102:	c0 db       	rcall	.-2176   	; 0x884 <sysclk_enable_module>
    1104:	45 c1       	rjmp	.+650    	; 0x1390 <usart_init_spi+0x382>
    1106:	80 e4       	ldi	r24, 0x40	; 64
    1108:	e8 16       	cp	r14, r24
    110a:	89 e0       	ldi	r24, 0x09	; 9
    110c:	f8 06       	cpc	r15, r24
    110e:	21 f4       	brne	.+8      	; 0x1118 <usart_init_spi+0x10a>
    1110:	62 e0       	ldi	r22, 0x02	; 2
    1112:	84 e0       	ldi	r24, 0x04	; 4
    1114:	b7 db       	rcall	.-2194   	; 0x884 <sysclk_enable_module>
    1116:	3c c1       	rjmp	.+632    	; 0x1390 <usart_init_spi+0x382>
    1118:	e0 e4       	ldi	r30, 0x40	; 64
    111a:	ee 16       	cp	r14, r30
    111c:	ea e0       	ldi	r30, 0x0A	; 10
    111e:	fe 06       	cpc	r15, r30
    1120:	21 f4       	brne	.+8      	; 0x112a <usart_init_spi+0x11c>
    1122:	62 e0       	ldi	r22, 0x02	; 2
    1124:	85 e0       	ldi	r24, 0x05	; 5
    1126:	ae db       	rcall	.-2212   	; 0x884 <sysclk_enable_module>
    1128:	33 c1       	rjmp	.+614    	; 0x1390 <usart_init_spi+0x382>
    112a:	f0 e9       	ldi	r31, 0x90	; 144
    112c:	ef 16       	cp	r14, r31
    112e:	f8 e0       	ldi	r31, 0x08	; 8
    1130:	ff 06       	cpc	r15, r31
    1132:	21 f4       	brne	.+8      	; 0x113c <usart_init_spi+0x12e>
    1134:	64 e0       	ldi	r22, 0x04	; 4
    1136:	83 e0       	ldi	r24, 0x03	; 3
    1138:	a5 db       	rcall	.-2230   	; 0x884 <sysclk_enable_module>
    113a:	2a c1       	rjmp	.+596    	; 0x1390 <usart_init_spi+0x382>
    113c:	30 e9       	ldi	r19, 0x90	; 144
    113e:	e3 16       	cp	r14, r19
    1140:	39 e0       	ldi	r19, 0x09	; 9
    1142:	f3 06       	cpc	r15, r19
    1144:	21 f4       	brne	.+8      	; 0x114e <usart_init_spi+0x140>
    1146:	64 e0       	ldi	r22, 0x04	; 4
    1148:	84 e0       	ldi	r24, 0x04	; 4
    114a:	9c db       	rcall	.-2248   	; 0x884 <sysclk_enable_module>
    114c:	21 c1       	rjmp	.+578    	; 0x1390 <usart_init_spi+0x382>
    114e:	80 e9       	ldi	r24, 0x90	; 144
    1150:	e8 16       	cp	r14, r24
    1152:	8a e0       	ldi	r24, 0x0A	; 10
    1154:	f8 06       	cpc	r15, r24
    1156:	21 f4       	brne	.+8      	; 0x1160 <usart_init_spi+0x152>
    1158:	64 e0       	ldi	r22, 0x04	; 4
    115a:	85 e0       	ldi	r24, 0x05	; 5
    115c:	93 db       	rcall	.-2266   	; 0x884 <sysclk_enable_module>
    115e:	18 c1       	rjmp	.+560    	; 0x1390 <usart_init_spi+0x382>
    1160:	e0 e9       	ldi	r30, 0x90	; 144
    1162:	ee 16       	cp	r14, r30
    1164:	eb e0       	ldi	r30, 0x0B	; 11
    1166:	fe 06       	cpc	r15, r30
    1168:	21 f4       	brne	.+8      	; 0x1172 <usart_init_spi+0x164>
    116a:	64 e0       	ldi	r22, 0x04	; 4
    116c:	86 e0       	ldi	r24, 0x06	; 6
    116e:	8a db       	rcall	.-2284   	; 0x884 <sysclk_enable_module>
    1170:	0f c1       	rjmp	.+542    	; 0x1390 <usart_init_spi+0x382>
    1172:	f0 ec       	ldi	r31, 0xC0	; 192
    1174:	ef 16       	cp	r14, r31
    1176:	f8 e0       	ldi	r31, 0x08	; 8
    1178:	ff 06       	cpc	r15, r31
    117a:	21 f4       	brne	.+8      	; 0x1184 <usart_init_spi+0x176>
    117c:	68 e0       	ldi	r22, 0x08	; 8
    117e:	83 e0       	ldi	r24, 0x03	; 3
    1180:	81 db       	rcall	.-2302   	; 0x884 <sysclk_enable_module>
    1182:	06 c1       	rjmp	.+524    	; 0x1390 <usart_init_spi+0x382>
    1184:	30 ec       	ldi	r19, 0xC0	; 192
    1186:	e3 16       	cp	r14, r19
    1188:	39 e0       	ldi	r19, 0x09	; 9
    118a:	f3 06       	cpc	r15, r19
    118c:	21 f4       	brne	.+8      	; 0x1196 <usart_init_spi+0x188>
    118e:	68 e0       	ldi	r22, 0x08	; 8
    1190:	84 e0       	ldi	r24, 0x04	; 4
    1192:	78 db       	rcall	.-2320   	; 0x884 <sysclk_enable_module>
    1194:	fd c0       	rjmp	.+506    	; 0x1390 <usart_init_spi+0x382>
    1196:	80 ea       	ldi	r24, 0xA0	; 160
    1198:	e8 16       	cp	r14, r24
    119a:	88 e0       	ldi	r24, 0x08	; 8
    119c:	f8 06       	cpc	r15, r24
    119e:	61 f4       	brne	.+24     	; 0x11b8 <usart_init_spi+0x1aa>
    11a0:	60 e1       	ldi	r22, 0x10	; 16
    11a2:	83 e0       	ldi	r24, 0x03	; 3
    11a4:	6f db       	rcall	.-2338   	; 0x884 <sysclk_enable_module>
    11a6:	e0 ea       	ldi	r30, 0xA0	; 160
    11a8:	f8 e0       	ldi	r31, 0x08	; 8
    11aa:	84 81       	ldd	r24, Z+4	; 0x04
    11ac:	8f 7e       	andi	r24, 0xEF	; 239
    11ae:	84 83       	std	Z+4, r24	; 0x04
    11b0:	f8 01       	movw	r30, r16
    11b2:	24 81       	ldd	r18, Z+4	; 0x04
    11b4:	22 50       	subi	r18, 0x02	; 2
    11b6:	4c c0       	rjmp	.+152    	; 0x1250 <usart_init_spi+0x242>
    11b8:	f0 ea       	ldi	r31, 0xA0	; 160
    11ba:	ef 16       	cp	r14, r31
    11bc:	f9 e0       	ldi	r31, 0x09	; 9
    11be:	ff 06       	cpc	r15, r31
    11c0:	21 f4       	brne	.+8      	; 0x11ca <usart_init_spi+0x1bc>
    11c2:	60 e1       	ldi	r22, 0x10	; 16
    11c4:	84 e0       	ldi	r24, 0x04	; 4
    11c6:	5e db       	rcall	.-2372   	; 0x884 <sysclk_enable_module>
    11c8:	e3 c0       	rjmp	.+454    	; 0x1390 <usart_init_spi+0x382>
    11ca:	30 ea       	ldi	r19, 0xA0	; 160
    11cc:	e3 16       	cp	r14, r19
    11ce:	3a e0       	ldi	r19, 0x0A	; 10
    11d0:	f3 06       	cpc	r15, r19
    11d2:	21 f4       	brne	.+8      	; 0x11dc <usart_init_spi+0x1ce>
    11d4:	60 e1       	ldi	r22, 0x10	; 16
    11d6:	85 e0       	ldi	r24, 0x05	; 5
    11d8:	55 db       	rcall	.-2390   	; 0x884 <sysclk_enable_module>
    11da:	da c0       	rjmp	.+436    	; 0x1390 <usart_init_spi+0x382>
    11dc:	80 ea       	ldi	r24, 0xA0	; 160
    11de:	e8 16       	cp	r14, r24
    11e0:	8b e0       	ldi	r24, 0x0B	; 11
    11e2:	f8 06       	cpc	r15, r24
    11e4:	21 f4       	brne	.+8      	; 0x11ee <usart_init_spi+0x1e0>
    11e6:	60 e1       	ldi	r22, 0x10	; 16
    11e8:	86 e0       	ldi	r24, 0x06	; 6
    11ea:	4c db       	rcall	.-2408   	; 0x884 <sysclk_enable_module>
    11ec:	d1 c0       	rjmp	.+418    	; 0x1390 <usart_init_spi+0x382>
    11ee:	e0 eb       	ldi	r30, 0xB0	; 176
    11f0:	ee 16       	cp	r14, r30
    11f2:	e8 e0       	ldi	r30, 0x08	; 8
    11f4:	fe 06       	cpc	r15, r30
    11f6:	21 f4       	brne	.+8      	; 0x1200 <usart_init_spi+0x1f2>
    11f8:	60 e2       	ldi	r22, 0x20	; 32
    11fa:	83 e0       	ldi	r24, 0x03	; 3
    11fc:	43 db       	rcall	.-2426   	; 0x884 <sysclk_enable_module>
    11fe:	c8 c0       	rjmp	.+400    	; 0x1390 <usart_init_spi+0x382>
    1200:	f0 eb       	ldi	r31, 0xB0	; 176
    1202:	ef 16       	cp	r14, r31
    1204:	f9 e0       	ldi	r31, 0x09	; 9
    1206:	ff 06       	cpc	r15, r31
    1208:	21 f4       	brne	.+8      	; 0x1212 <usart_init_spi+0x204>
    120a:	60 e2       	ldi	r22, 0x20	; 32
    120c:	84 e0       	ldi	r24, 0x04	; 4
    120e:	3a db       	rcall	.-2444   	; 0x884 <sysclk_enable_module>
    1210:	bf c0       	rjmp	.+382    	; 0x1390 <usart_init_spi+0x382>
    1212:	30 e8       	ldi	r19, 0x80	; 128
    1214:	e3 16       	cp	r14, r19
    1216:	34 e0       	ldi	r19, 0x04	; 4
    1218:	f3 06       	cpc	r15, r19
    121a:	21 f4       	brne	.+8      	; 0x1224 <usart_init_spi+0x216>
    121c:	60 e4       	ldi	r22, 0x40	; 64
    121e:	83 e0       	ldi	r24, 0x03	; 3
    1220:	31 db       	rcall	.-2462   	; 0x884 <sysclk_enable_module>
    1222:	b6 c0       	rjmp	.+364    	; 0x1390 <usart_init_spi+0x382>
    1224:	80 ea       	ldi	r24, 0xA0	; 160
    1226:	e8 16       	cp	r14, r24
    1228:	84 e0       	ldi	r24, 0x04	; 4
    122a:	f8 06       	cpc	r15, r24
    122c:	21 f4       	brne	.+8      	; 0x1236 <usart_init_spi+0x228>
    122e:	60 e4       	ldi	r22, 0x40	; 64
    1230:	85 e0       	ldi	r24, 0x05	; 5
    1232:	28 db       	rcall	.-2480   	; 0x884 <sysclk_enable_module>
    1234:	ad c0       	rjmp	.+346    	; 0x1390 <usart_init_spi+0x382>
    1236:	f7 01       	movw	r30, r14
    1238:	84 81       	ldd	r24, Z+4	; 0x04
    123a:	8f 7e       	andi	r24, 0xEF	; 239
    123c:	84 83       	std	Z+4, r24	; 0x04
    123e:	fb 01       	movw	r30, r22
    1240:	24 81       	ldd	r18, Z+4	; 0x04
    1242:	22 50       	subi	r18, 0x02	; 2
    1244:	c7 01       	movw	r24, r14
    1246:	f0 ea       	ldi	r31, 0xA0	; 160
    1248:	ef 16       	cp	r14, r31
    124a:	f8 e0       	ldi	r31, 0x08	; 8
    124c:	ff 06       	cpc	r15, r31
    124e:	49 f4       	brne	.+18     	; 0x1262 <usart_init_spi+0x254>
    1250:	80 91 4e 06 	lds	r24, 0x064E	; 0x80064e <__TEXT_REGION_LENGTH__+0x70064e>
    1254:	84 fd       	sbrc	r24, 4
    1256:	a5 c0       	rjmp	.+330    	; 0x13a2 <usart_init_spi+0x394>
    1258:	0f 2e       	mov	r0, r31
    125a:	f1 e1       	ldi	r31, 0x11	; 17
    125c:	df 2e       	mov	r13, r31
    125e:	f0 2d       	mov	r31, r0
    1260:	a4 c0       	rjmp	.+328    	; 0x13aa <usart_init_spi+0x39c>
    1262:	80 3b       	cpi	r24, 0xB0	; 176
    1264:	38 e0       	ldi	r19, 0x08	; 8
    1266:	93 07       	cpc	r25, r19
    1268:	91 f0       	breq	.+36     	; 0x128e <usart_init_spi+0x280>
    126a:	80 3a       	cpi	r24, 0xA0	; 160
    126c:	e9 e0       	ldi	r30, 0x09	; 9
    126e:	9e 07       	cpc	r25, r30
    1270:	49 f4       	brne	.+18     	; 0x1284 <usart_init_spi+0x276>
    1272:	30 91 6e 06 	lds	r19, 0x066E	; 0x80066e <__TEXT_REGION_LENGTH__+0x70066e>
    1276:	34 fd       	sbrc	r19, 4
    1278:	9b c0       	rjmp	.+310    	; 0x13b0 <usart_init_spi+0x3a2>
    127a:	0f 2e       	mov	r0, r31
    127c:	f9 e1       	ldi	r31, 0x19	; 25
    127e:	df 2e       	mov	r13, r31
    1280:	f0 2d       	mov	r31, r0
    1282:	16 c0       	rjmp	.+44     	; 0x12b0 <usart_init_spi+0x2a2>
    1284:	80 3b       	cpi	r24, 0xB0	; 176
    1286:	f9 e0       	ldi	r31, 0x09	; 9
    1288:	9f 07       	cpc	r25, r31
    128a:	f1 f0       	breq	.+60     	; 0x12c8 <usart_init_spi+0x2ba>
    128c:	04 c0       	rjmp	.+8      	; 0x1296 <usart_init_spi+0x288>
    128e:	0f 2e       	mov	r0, r31
    1290:	f5 e1       	ldi	r31, 0x15	; 21
    1292:	df 2e       	mov	r13, r31
    1294:	f0 2d       	mov	r31, r0
    1296:	80 3a       	cpi	r24, 0xA0	; 160
    1298:	3a e0       	ldi	r19, 0x0A	; 10
    129a:	93 07       	cpc	r25, r19
    129c:	49 f4       	brne	.+18     	; 0x12b0 <usart_init_spi+0x2a2>
    129e:	80 91 8e 06 	lds	r24, 0x068E	; 0x80068e <__TEXT_REGION_LENGTH__+0x70068e>
    12a2:	84 fd       	sbrc	r24, 4
    12a4:	8a c0       	rjmp	.+276    	; 0x13ba <usart_init_spi+0x3ac>
    12a6:	0f 2e       	mov	r0, r31
    12a8:	f1 e2       	ldi	r31, 0x21	; 33
    12aa:	df 2e       	mov	r13, r31
    12ac:	f0 2d       	mov	r31, r0
    12ae:	15 c0       	rjmp	.+42     	; 0x12da <usart_init_spi+0x2cc>
    12b0:	80 3a       	cpi	r24, 0xA0	; 160
    12b2:	9b 40       	sbci	r25, 0x0B	; 11
    12b4:	91 f4       	brne	.+36     	; 0x12da <usart_init_spi+0x2cc>
    12b6:	80 91 ae 06 	lds	r24, 0x06AE	; 0x8006ae <__TEXT_REGION_LENGTH__+0x7006ae>
    12ba:	84 fd       	sbrc	r24, 4
    12bc:	0a c0       	rjmp	.+20     	; 0x12d2 <usart_init_spi+0x2c4>
    12be:	0f 2e       	mov	r0, r31
    12c0:	f9 e2       	ldi	r31, 0x29	; 41
    12c2:	df 2e       	mov	r13, r31
    12c4:	f0 2d       	mov	r31, r0
    12c6:	09 c0       	rjmp	.+18     	; 0x12da <usart_init_spi+0x2cc>
    12c8:	0f 2e       	mov	r0, r31
    12ca:	fd e1       	ldi	r31, 0x1D	; 29
    12cc:	df 2e       	mov	r13, r31
    12ce:	f0 2d       	mov	r31, r0
    12d0:	04 c0       	rjmp	.+8      	; 0x12da <usart_init_spi+0x2cc>
    12d2:	0f 2e       	mov	r0, r31
    12d4:	fd e2       	ldi	r31, 0x2D	; 45
    12d6:	df 2e       	mov	r13, r31
    12d8:	f0 2d       	mov	r31, r0
    12da:	ed 2d       	mov	r30, r13
    12dc:	e6 95       	lsr	r30
    12de:	e6 95       	lsr	r30
    12e0:	e6 95       	lsr	r30
    12e2:	30 e2       	ldi	r19, 0x20	; 32
    12e4:	e3 9f       	mul	r30, r19
    12e6:	f0 01       	movw	r30, r0
    12e8:	11 24       	eor	r1, r1
    12ea:	fa 5f       	subi	r31, 0xFA	; 250
    12ec:	3d 2d       	mov	r19, r13
    12ee:	37 70       	andi	r19, 0x07	; 7
    12f0:	81 e0       	ldi	r24, 0x01	; 1
    12f2:	90 e0       	ldi	r25, 0x00	; 0
    12f4:	03 2e       	mov	r0, r19
    12f6:	02 c0       	rjmp	.+4      	; 0x12fc <usart_init_spi+0x2ee>
    12f8:	88 0f       	add	r24, r24
    12fa:	99 1f       	adc	r25, r25
    12fc:	0a 94       	dec	r0
    12fe:	e2 f7       	brpl	.-8      	; 0x12f8 <usart_init_spi+0x2ea>
    1300:	81 83       	std	Z+1, r24	; 0x01
    1302:	22 30       	cpi	r18, 0x02	; 2
    1304:	10 f0       	brcs	.+4      	; 0x130a <usart_init_spi+0x2fc>
    1306:	40 e0       	ldi	r20, 0x00	; 0
    1308:	01 c0       	rjmp	.+2      	; 0x130c <usart_init_spi+0x2fe>
    130a:	40 e4       	ldi	r20, 0x40	; 64
    130c:	df 01       	movw	r26, r30
    130e:	50 96       	adiw	r26, 0x10	; 16
    1310:	a3 0f       	add	r26, r19
    1312:	b1 1d       	adc	r27, r1
    1314:	9f b7       	in	r25, 0x3f	; 63
    1316:	99 83       	std	Y+1, r25	; 0x01
    1318:	f8 94       	cli
    131a:	39 81       	ldd	r19, Y+1	; 0x01
    131c:	2c 91       	ld	r18, X
    131e:	27 70       	andi	r18, 0x07	; 7
    1320:	2c 93       	st	X, r18
    1322:	9c 91       	ld	r25, X
    1324:	94 2b       	or	r25, r20
    1326:	9c 93       	st	X, r25
    1328:	3f bf       	out	0x3f, r19	; 63
    132a:	85 83       	std	Z+5, r24	; 0x05
    132c:	f7 01       	movw	r30, r14
    132e:	85 81       	ldd	r24, Z+5	; 0x05
    1330:	80 6c       	ori	r24, 0xC0	; 192
    1332:	85 83       	std	Z+5, r24	; 0x05
    1334:	f8 01       	movw	r30, r16
    1336:	84 81       	ldd	r24, Z+4	; 0x04
    1338:	8d 7f       	andi	r24, 0xFD	; 253
    133a:	81 30       	cpi	r24, 0x01	; 1
    133c:	29 f4       	brne	.+10     	; 0x1348 <usart_init_spi+0x33a>
    133e:	f7 01       	movw	r30, r14
    1340:	85 81       	ldd	r24, Z+5	; 0x05
    1342:	82 60       	ori	r24, 0x02	; 2
    1344:	85 83       	std	Z+5, r24	; 0x05
    1346:	04 c0       	rjmp	.+8      	; 0x1350 <usart_init_spi+0x342>
    1348:	f7 01       	movw	r30, r14
    134a:	85 81       	ldd	r24, Z+5	; 0x05
    134c:	8d 7f       	andi	r24, 0xFD	; 253
    134e:	85 83       	std	Z+5, r24	; 0x05
    1350:	f8 01       	movw	r30, r16
    1352:	85 81       	ldd	r24, Z+5	; 0x05
    1354:	88 23       	and	r24, r24
    1356:	29 f0       	breq	.+10     	; 0x1362 <usart_init_spi+0x354>
    1358:	f7 01       	movw	r30, r14
    135a:	85 81       	ldd	r24, Z+5	; 0x05
    135c:	84 60       	ori	r24, 0x04	; 4
    135e:	85 83       	std	Z+5, r24	; 0x05
    1360:	04 c0       	rjmp	.+8      	; 0x136a <usart_init_spi+0x35c>
    1362:	f7 01       	movw	r30, r14
    1364:	85 81       	ldd	r24, Z+5	; 0x05
    1366:	8b 7f       	andi	r24, 0xFB	; 251
    1368:	85 83       	std	Z+5, r24	; 0x05
    136a:	f8 01       	movw	r30, r16
    136c:	40 81       	ld	r20, Z
    136e:	51 81       	ldd	r21, Z+1	; 0x01
    1370:	62 81       	ldd	r22, Z+2	; 0x02
    1372:	73 81       	ldd	r23, Z+3	; 0x03
    1374:	00 e8       	ldi	r16, 0x80	; 128
    1376:	14 e8       	ldi	r17, 0x84	; 132
    1378:	2e e1       	ldi	r18, 0x1E	; 30
    137a:	30 e0       	ldi	r19, 0x00	; 0
    137c:	c7 01       	movw	r24, r14
    137e:	15 de       	rcall	.-982    	; 0xfaa <usart_spi_set_baudrate>
    1380:	f7 01       	movw	r30, r14
    1382:	84 81       	ldd	r24, Z+4	; 0x04
    1384:	88 60       	ori	r24, 0x08	; 8
    1386:	84 83       	std	Z+4, r24	; 0x04
    1388:	84 81       	ldd	r24, Z+4	; 0x04
    138a:	80 61       	ori	r24, 0x10	; 16
    138c:	84 83       	std	Z+4, r24	; 0x04
    138e:	1a c0       	rjmp	.+52     	; 0x13c4 <usart_init_spi+0x3b6>
    1390:	f7 01       	movw	r30, r14
    1392:	84 81       	ldd	r24, Z+4	; 0x04
    1394:	8f 7e       	andi	r24, 0xEF	; 239
    1396:	84 83       	std	Z+4, r24	; 0x04
    1398:	f8 01       	movw	r30, r16
    139a:	24 81       	ldd	r18, Z+4	; 0x04
    139c:	22 50       	subi	r18, 0x02	; 2
    139e:	c7 01       	movw	r24, r14
    13a0:	60 cf       	rjmp	.-320    	; 0x1262 <usart_init_spi+0x254>
    13a2:	0f 2e       	mov	r0, r31
    13a4:	f5 e1       	ldi	r31, 0x15	; 21
    13a6:	df 2e       	mov	r13, r31
    13a8:	f0 2d       	mov	r31, r0
    13aa:	80 ea       	ldi	r24, 0xA0	; 160
    13ac:	98 e0       	ldi	r25, 0x08	; 8
    13ae:	6a cf       	rjmp	.-300    	; 0x1284 <usart_init_spi+0x276>
    13b0:	0f 2e       	mov	r0, r31
    13b2:	fd e1       	ldi	r31, 0x1D	; 29
    13b4:	df 2e       	mov	r13, r31
    13b6:	f0 2d       	mov	r31, r0
    13b8:	7b cf       	rjmp	.-266    	; 0x12b0 <usart_init_spi+0x2a2>
    13ba:	0f 2e       	mov	r0, r31
    13bc:	f5 e2       	ldi	r31, 0x25	; 37
    13be:	df 2e       	mov	r13, r31
    13c0:	f0 2d       	mov	r31, r0
    13c2:	8b cf       	rjmp	.-234    	; 0x12da <usart_init_spi+0x2cc>
    13c4:	0f 90       	pop	r0
    13c6:	df 91       	pop	r29
    13c8:	cf 91       	pop	r28
    13ca:	1f 91       	pop	r17
    13cc:	0f 91       	pop	r16
    13ce:	ff 90       	pop	r15
    13d0:	ef 90       	pop	r14
    13d2:	df 90       	pop	r13
    13d4:	08 95       	ret

000013d6 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    13d6:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    13d8:	03 96       	adiw	r24, 0x03	; 3
    13da:	81 83       	std	Z+1, r24	; 0x01
    13dc:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    13de:	2f ef       	ldi	r18, 0xFF	; 255
    13e0:	3f ef       	ldi	r19, 0xFF	; 255
    13e2:	23 83       	std	Z+3, r18	; 0x03
    13e4:	34 83       	std	Z+4, r19	; 0x04

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    13e6:	85 83       	std	Z+5, r24	; 0x05
    13e8:	96 83       	std	Z+6, r25	; 0x06
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    13ea:	87 83       	std	Z+7, r24	; 0x07
    13ec:	90 87       	std	Z+8, r25	; 0x08

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    13ee:	10 82       	st	Z, r1
    13f0:	08 95       	ret

000013f2 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    13f2:	fc 01       	movw	r30, r24
    13f4:	10 86       	std	Z+8, r1	; 0x08
    13f6:	11 86       	std	Z+9, r1	; 0x09
    13f8:	08 95       	ret

000013fa <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    13fa:	cf 93       	push	r28
    13fc:	df 93       	push	r29
    13fe:	9c 01       	movw	r18, r24
    1400:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    1402:	dc 01       	movw	r26, r24
    1404:	11 96       	adiw	r26, 0x01	; 1
    1406:	cd 91       	ld	r28, X+
    1408:	dc 91       	ld	r29, X
    140a:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    140c:	c2 83       	std	Z+2, r28	; 0x02
    140e:	d3 83       	std	Z+3, r29	; 0x03
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1410:	8c 81       	ldd	r24, Y+4	; 0x04
    1412:	9d 81       	ldd	r25, Y+5	; 0x05
    1414:	84 83       	std	Z+4, r24	; 0x04
    1416:	95 83       	std	Z+5, r25	; 0x05
	pxIndex->pxPrevious->pxNext = pxNewListItem;
    1418:	8c 81       	ldd	r24, Y+4	; 0x04
    141a:	9d 81       	ldd	r25, Y+5	; 0x05
    141c:	dc 01       	movw	r26, r24
    141e:	12 96       	adiw	r26, 0x02	; 2
    1420:	6d 93       	st	X+, r22
    1422:	7c 93       	st	X, r23
    1424:	13 97       	sbiw	r26, 0x03	; 3
	pxIndex->pxPrevious = pxNewListItem;
    1426:	6c 83       	std	Y+4, r22	; 0x04
    1428:	7d 83       	std	Y+5, r23	; 0x05

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    142a:	20 87       	std	Z+8, r18	; 0x08
    142c:	31 87       	std	Z+9, r19	; 0x09

	( pxList->uxNumberOfItems )++;
    142e:	f9 01       	movw	r30, r18
    1430:	80 81       	ld	r24, Z
    1432:	8f 5f       	subi	r24, 0xFF	; 255
    1434:	80 83       	st	Z, r24
}
    1436:	df 91       	pop	r29
    1438:	cf 91       	pop	r28
    143a:	08 95       	ret

0000143c <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    143c:	cf 93       	push	r28
    143e:	df 93       	push	r29
    1440:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1442:	48 81       	ld	r20, Y
    1444:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1446:	4f 3f       	cpi	r20, 0xFF	; 255
    1448:	2f ef       	ldi	r18, 0xFF	; 255
    144a:	52 07       	cpc	r21, r18
    144c:	21 f4       	brne	.+8      	; 0x1456 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    144e:	fc 01       	movw	r30, r24
    1450:	a7 81       	ldd	r26, Z+7	; 0x07
    1452:	b0 85       	ldd	r27, Z+8	; 0x08
    1454:	0d c0       	rjmp	.+26     	; 0x1470 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1456:	dc 01       	movw	r26, r24
    1458:	13 96       	adiw	r26, 0x03	; 3
    145a:	01 c0       	rjmp	.+2      	; 0x145e <vListInsert+0x22>
    145c:	df 01       	movw	r26, r30
    145e:	12 96       	adiw	r26, 0x02	; 2
    1460:	ed 91       	ld	r30, X+
    1462:	fc 91       	ld	r31, X
    1464:	13 97       	sbiw	r26, 0x03	; 3
    1466:	20 81       	ld	r18, Z
    1468:	31 81       	ldd	r19, Z+1	; 0x01
    146a:	42 17       	cp	r20, r18
    146c:	53 07       	cpc	r21, r19
    146e:	b0 f7       	brcc	.-20     	; 0x145c <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1470:	12 96       	adiw	r26, 0x02	; 2
    1472:	ed 91       	ld	r30, X+
    1474:	fc 91       	ld	r31, X
    1476:	13 97       	sbiw	r26, 0x03	; 3
    1478:	ea 83       	std	Y+2, r30	; 0x02
    147a:	fb 83       	std	Y+3, r31	; 0x03
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    147c:	c4 83       	std	Z+4, r28	; 0x04
    147e:	d5 83       	std	Z+5, r29	; 0x05
	pxNewListItem->pxPrevious = pxIterator;
    1480:	ac 83       	std	Y+4, r26	; 0x04
    1482:	bd 83       	std	Y+5, r27	; 0x05
	pxIterator->pxNext = pxNewListItem;
    1484:	12 96       	adiw	r26, 0x02	; 2
    1486:	cd 93       	st	X+, r28
    1488:	dc 93       	st	X, r29
    148a:	13 97       	sbiw	r26, 0x03	; 3

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    148c:	88 87       	std	Y+8, r24	; 0x08
    148e:	99 87       	std	Y+9, r25	; 0x09

	( pxList->uxNumberOfItems )++;
    1490:	fc 01       	movw	r30, r24
    1492:	20 81       	ld	r18, Z
    1494:	2f 5f       	subi	r18, 0xFF	; 255
    1496:	20 83       	st	Z, r18
}
    1498:	df 91       	pop	r29
    149a:	cf 91       	pop	r28
    149c:	08 95       	ret

0000149e <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    149e:	cf 93       	push	r28
    14a0:	df 93       	push	r29
    14a2:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    14a4:	a0 85       	ldd	r26, Z+8	; 0x08
    14a6:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    14a8:	c2 81       	ldd	r28, Z+2	; 0x02
    14aa:	d3 81       	ldd	r29, Z+3	; 0x03
    14ac:	84 81       	ldd	r24, Z+4	; 0x04
    14ae:	95 81       	ldd	r25, Z+5	; 0x05
    14b0:	8c 83       	std	Y+4, r24	; 0x04
    14b2:	9d 83       	std	Y+5, r25	; 0x05
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    14b4:	c4 81       	ldd	r28, Z+4	; 0x04
    14b6:	d5 81       	ldd	r29, Z+5	; 0x05
    14b8:	82 81       	ldd	r24, Z+2	; 0x02
    14ba:	93 81       	ldd	r25, Z+3	; 0x03
    14bc:	8a 83       	std	Y+2, r24	; 0x02
    14be:	9b 83       	std	Y+3, r25	; 0x03

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    14c0:	11 96       	adiw	r26, 0x01	; 1
    14c2:	8d 91       	ld	r24, X+
    14c4:	9c 91       	ld	r25, X
    14c6:	12 97       	sbiw	r26, 0x02	; 2
    14c8:	e8 17       	cp	r30, r24
    14ca:	f9 07       	cpc	r31, r25
    14cc:	31 f4       	brne	.+12     	; 0x14da <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    14ce:	84 81       	ldd	r24, Z+4	; 0x04
    14d0:	95 81       	ldd	r25, Z+5	; 0x05
    14d2:	11 96       	adiw	r26, 0x01	; 1
    14d4:	8d 93       	st	X+, r24
    14d6:	9c 93       	st	X, r25
    14d8:	12 97       	sbiw	r26, 0x02	; 2
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    14da:	10 86       	std	Z+8, r1	; 0x08
    14dc:	11 86       	std	Z+9, r1	; 0x09
	( pxList->uxNumberOfItems )--;
    14de:	8c 91       	ld	r24, X
    14e0:	81 50       	subi	r24, 0x01	; 1
    14e2:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
    14e4:	df 91       	pop	r29
    14e6:	cf 91       	pop	r28
    14e8:	08 95       	ret

000014ea <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    14ea:	0f 93       	push	r16
    14ec:	1f 93       	push	r17
    14ee:	8b 01       	movw	r16, r22
uint16_t usAddress;

    /* Place a few bytes of known values on the bottom of the stack.
    This is just useful for debugging. */

    *pxTopOfStack = 0x11;
    14f0:	71 e1       	ldi	r23, 0x11	; 17
    14f2:	fc 01       	movw	r30, r24
    14f4:	70 83       	st	Z, r23
    pxTopOfStack--;
    *pxTopOfStack = 0x22;
    14f6:	31 97       	sbiw	r30, 0x01	; 1
    14f8:	62 e2       	ldi	r22, 0x22	; 34
    14fa:	60 83       	st	Z, r22
    pxTopOfStack--;
    *pxTopOfStack = 0x33;
    14fc:	31 97       	sbiw	r30, 0x01	; 1
    14fe:	23 e3       	ldi	r18, 0x33	; 51
    1500:	20 83       	st	Z, r18

    /*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

    /* The start of the task code will be popped off the stack last, so place
    it on first. */
    ulAddress = ( uint32_t ) pxCode;
    1502:	01 2e       	mov	r0, r17
    1504:	00 0c       	add	r0, r0
    1506:	22 0b       	sbc	r18, r18
    1508:	33 0b       	sbc	r19, r19
    *pxTopOfStack = ( StackType_t ) ( ulAddress & ( uint32_t ) 0x000000ff );
    150a:	31 97       	sbiw	r30, 0x01	; 1
    150c:	00 83       	st	Z, r16
    pxTopOfStack--;

    ulAddress >>= 8;
    *pxTopOfStack = ( StackType_t ) ( ulAddress & ( uint32_t ) 0x000000ff );
    150e:	31 97       	sbiw	r30, 0x01	; 1
    1510:	10 83       	st	Z, r17
    pxTopOfStack--;

#ifdef __AVR_3_BYTE_PC__
    ulAddress >>= 8;
    *pxTopOfStack = ( StackType_t ) ( ulAddress & ( uint32_t ) 0x000000ff );
    1512:	31 97       	sbiw	r30, 0x01	; 1
    1514:	20 83       	st	Z, r18

    /* Next simulate the stack as if after a call to portSAVE_CONTEXT().
    portSAVE_CONTEXT places the flags on the stack immediately after r0
    to ensure the interrupts get disabled as soon as possible, and so ensuring
    the stack use is minimal should a context switch interrupt occur. */
    *pxTopOfStack = ( StackType_t ) 0x00;   /* R0 */
    1516:	31 97       	sbiw	r30, 0x01	; 1
    1518:	10 82       	st	Z, r1
    pxTopOfStack--;
    *pxTopOfStack = portFLAGS_INT_ENABLED;
    151a:	31 97       	sbiw	r30, 0x01	; 1
    151c:	20 e8       	ldi	r18, 0x80	; 128
    151e:	20 83       	st	Z, r18
    pxTopOfStack--;

    /* Now the remaining registers.   The compiler expects R1 to be 0. */
    *pxTopOfStack = ( StackType_t ) 0x00;   /* R1 */
    1520:	31 97       	sbiw	r30, 0x01	; 1
    1522:	10 82       	st	Z, r1
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x02;   /* R2 */
    1524:	31 97       	sbiw	r30, 0x01	; 1
    1526:	22 e0       	ldi	r18, 0x02	; 2
    1528:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x03;   /* R3 */
    152a:	31 97       	sbiw	r30, 0x01	; 1
    152c:	23 e0       	ldi	r18, 0x03	; 3
    152e:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x04;   /* R4 */
    1530:	31 97       	sbiw	r30, 0x01	; 1
    1532:	24 e0       	ldi	r18, 0x04	; 4
    1534:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x05;   /* R5 */
    1536:	31 97       	sbiw	r30, 0x01	; 1
    1538:	25 e0       	ldi	r18, 0x05	; 5
    153a:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x06;   /* R6 */
    153c:	31 97       	sbiw	r30, 0x01	; 1
    153e:	26 e0       	ldi	r18, 0x06	; 6
    1540:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x07;   /* R7 */
    1542:	31 97       	sbiw	r30, 0x01	; 1
    1544:	27 e0       	ldi	r18, 0x07	; 7
    1546:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x08;   /* R8 */
    1548:	31 97       	sbiw	r30, 0x01	; 1
    154a:	28 e0       	ldi	r18, 0x08	; 8
    154c:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x09;   /* R9 */
    154e:	31 97       	sbiw	r30, 0x01	; 1
    1550:	29 e0       	ldi	r18, 0x09	; 9
    1552:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x10;   /* R10 */
    1554:	31 97       	sbiw	r30, 0x01	; 1
    1556:	20 e1       	ldi	r18, 0x10	; 16
    1558:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x11;   /* R11 */
    155a:	31 97       	sbiw	r30, 0x01	; 1
    155c:	70 83       	st	Z, r23
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x12;   /* R12 */
    155e:	31 97       	sbiw	r30, 0x01	; 1
    1560:	22 e1       	ldi	r18, 0x12	; 18
    1562:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x13;   /* R13 */
    1564:	31 97       	sbiw	r30, 0x01	; 1
    1566:	23 e1       	ldi	r18, 0x13	; 19
    1568:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x14;   /* R14 */
    156a:	31 97       	sbiw	r30, 0x01	; 1
    156c:	24 e1       	ldi	r18, 0x14	; 20
    156e:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x15;   /* R15 */
    1570:	31 97       	sbiw	r30, 0x01	; 1
    1572:	25 e1       	ldi	r18, 0x15	; 21
    1574:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x16;   /* R16 */
    1576:	31 97       	sbiw	r30, 0x01	; 1
    1578:	26 e1       	ldi	r18, 0x16	; 22
    157a:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x17;   /* R17 */
    157c:	31 97       	sbiw	r30, 0x01	; 1
    157e:	27 e1       	ldi	r18, 0x17	; 23
    1580:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x18;   /* R18 */
    1582:	31 97       	sbiw	r30, 0x01	; 1
    1584:	28 e1       	ldi	r18, 0x18	; 24
    1586:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x19;   /* R19 */
    1588:	31 97       	sbiw	r30, 0x01	; 1
    158a:	29 e1       	ldi	r18, 0x19	; 25
    158c:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x20;   /* R20 */
    158e:	31 97       	sbiw	r30, 0x01	; 1
    1590:	20 e2       	ldi	r18, 0x20	; 32
    1592:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x21;   /* R21 */
    1594:	31 97       	sbiw	r30, 0x01	; 1
    1596:	21 e2       	ldi	r18, 0x21	; 33
    1598:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x22;   /* R22 */
    159a:	31 97       	sbiw	r30, 0x01	; 1
    159c:	60 83       	st	Z, r22
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x23;   /* R23 */
    159e:	31 97       	sbiw	r30, 0x01	; 1
    15a0:	23 e2       	ldi	r18, 0x23	; 35
    15a2:	20 83       	st	Z, r18
    pxTopOfStack--;

    /* Place the parameter on the stack in the expected location. */
    usAddress = ( uint16_t ) pvParameters;
    *pxTopOfStack = ( StackType_t ) ( usAddress & ( uint32_t ) 0x000000ff );
    15a4:	31 97       	sbiw	r30, 0x01	; 1
    15a6:	40 83       	st	Z, r20
    pxTopOfStack--;

    usAddress >>= 8;
    *pxTopOfStack = ( StackType_t ) ( usAddress & ( uint32_t ) 0x000000ff );
    15a8:	31 97       	sbiw	r30, 0x01	; 1
    15aa:	50 83       	st	Z, r21
    pxTopOfStack--;

    *pxTopOfStack = ( StackType_t ) 0x26;   /* R26 X */
    15ac:	31 97       	sbiw	r30, 0x01	; 1
    15ae:	26 e2       	ldi	r18, 0x26	; 38
    15b0:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x27;   /* R27 */
    15b2:	31 97       	sbiw	r30, 0x01	; 1
    15b4:	27 e2       	ldi	r18, 0x27	; 39
    15b6:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x28;   /* R28 Y */
    15b8:	31 97       	sbiw	r30, 0x01	; 1
    15ba:	28 e2       	ldi	r18, 0x28	; 40
    15bc:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x29;   /* R29 */
    15be:	31 97       	sbiw	r30, 0x01	; 1
    15c0:	29 e2       	ldi	r18, 0x29	; 41
    15c2:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x30;   /* R30 Z */
    15c4:	31 97       	sbiw	r30, 0x01	; 1
    15c6:	20 e3       	ldi	r18, 0x30	; 48
    15c8:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x31;   /* R31 */
    15ca:	31 97       	sbiw	r30, 0x01	; 1
    15cc:	21 e3       	ldi	r18, 0x31	; 49
    15ce:	20 83       	st	Z, r18
    pxTopOfStack--;

    /*lint +e950 +e611 +e923 */

    return pxTopOfStack;
}
    15d0:	87 97       	sbiw	r24, 0x27	; 39
    15d2:	1f 91       	pop	r17
    15d4:	0f 91       	pop	r16
    15d6:	08 95       	ret

000015d8 <xPortStartScheduler>:
 * Setup timer generate a tick interrupt.
 */
static void prvSetupTimerInterrupt(void)
{
    // disable global interrupt for a moment
    cli();
    15d8:	f8 94       	cli

    {
        //enable TC0 clock source, high resolution
        PR.PRPC &= ~(PR_TC0_bm | PR_HIRES_bm);
    15da:	e0 e7       	ldi	r30, 0x70	; 112
    15dc:	f0 e0       	ldi	r31, 0x00	; 0
    15de:	83 81       	ldd	r24, Z+3	; 0x03
    15e0:	8a 7f       	andi	r24, 0xFA	; 250
    15e2:	83 83       	std	Z+3, r24	; 0x03

        //set period of counter
        TCC0.PER = configCPU_CLOCK_HZ / configTICK_RATE_HZ / 1;
    15e4:	e0 e0       	ldi	r30, 0x00	; 0
    15e6:	f8 e0       	ldi	r31, 0x08	; 8
    15e8:	80 e0       	ldi	r24, 0x00	; 0
    15ea:	9a ef       	ldi	r25, 0xFA	; 250
    15ec:	86 a3       	std	Z+38, r24	; 0x26
    15ee:	97 a3       	std	Z+39, r25	; 0x27

        //enable interrupt and set low level
        TCC0.INTCTRLA = TC_OVFINTLVL_LO_gc;
    15f0:	91 e0       	ldi	r25, 0x01	; 1
    15f2:	96 83       	std	Z+6, r25	; 0x06

        //enable low-level interrupt
        PMIC.CTRL |= PMIC_LOLVLEN_bm;
    15f4:	a0 ea       	ldi	r26, 0xA0	; 160
    15f6:	b0 e0       	ldi	r27, 0x00	; 0
    15f8:	12 96       	adiw	r26, 0x02	; 2
    15fa:	8c 91       	ld	r24, X
    15fc:	12 97       	sbiw	r26, 0x02	; 2
    15fe:	81 60       	ori	r24, 0x01	; 1
    1600:	12 96       	adiw	r26, 0x02	; 2
    1602:	8c 93       	st	X, r24

        //select (start) the clock source
        TCC0.CTRLA = TC_CLKSEL_DIV1_gc;
    1604:	90 83       	st	Z, r25

    }

    // enable global interrupt
    sei();
    1606:	78 94       	sei
{
    /* Setup the hardware to generate the tick. */
    prvSetupTimerInterrupt();

    /* Restore the context of the first task that is going to run. */
    portRESTORE_CONTEXT();
    1608:	a0 91 0a 23 	lds	r26, 0x230A	; 0x80230a <pxCurrentTCB>
    160c:	b0 91 0b 23 	lds	r27, 0x230B	; 0x80230b <pxCurrentTCB+0x1>
    1610:	0d 90       	ld	r0, X+
    1612:	0d be       	out	0x3d, r0	; 61
    1614:	0d 90       	ld	r0, X+
    1616:	0e be       	out	0x3e, r0	; 62
    1618:	ff 91       	pop	r31
    161a:	ef 91       	pop	r30
    161c:	df 91       	pop	r29
    161e:	cf 91       	pop	r28
    1620:	bf 91       	pop	r27
    1622:	af 91       	pop	r26
    1624:	9f 91       	pop	r25
    1626:	8f 91       	pop	r24
    1628:	7f 91       	pop	r23
    162a:	6f 91       	pop	r22
    162c:	5f 91       	pop	r21
    162e:	4f 91       	pop	r20
    1630:	3f 91       	pop	r19
    1632:	2f 91       	pop	r18
    1634:	1f 91       	pop	r17
    1636:	0f 91       	pop	r16
    1638:	ff 90       	pop	r15
    163a:	ef 90       	pop	r14
    163c:	df 90       	pop	r13
    163e:	cf 90       	pop	r12
    1640:	bf 90       	pop	r11
    1642:	af 90       	pop	r10
    1644:	9f 90       	pop	r9
    1646:	8f 90       	pop	r8
    1648:	7f 90       	pop	r7
    164a:	6f 90       	pop	r6
    164c:	5f 90       	pop	r5
    164e:	4f 90       	pop	r4
    1650:	3f 90       	pop	r3
    1652:	2f 90       	pop	r2
    1654:	1f 90       	pop	r1
    1656:	0f 90       	pop	r0
    1658:	0f be       	out	0x3f, r0	; 63
    165a:	0f 90       	pop	r0

    /* Simulate a function call end as generated by the compiler.  We will now
    jump to the start of the task the context of which we have just restored. */
    asm volatile ( "ret" );
    165c:	08 95       	ret

    /* Should not get here. */
    return pdTRUE;
}
    165e:	81 e0       	ldi	r24, 0x01	; 1
    1660:	08 95       	ret

00001662 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
    portSAVE_CONTEXT();
    1662:	0f 92       	push	r0
    1664:	0f b6       	in	r0, 0x3f	; 63
    1666:	f8 94       	cli
    1668:	0f 92       	push	r0
    166a:	1f 92       	push	r1
    166c:	11 24       	eor	r1, r1
    166e:	2f 92       	push	r2
    1670:	3f 92       	push	r3
    1672:	4f 92       	push	r4
    1674:	5f 92       	push	r5
    1676:	6f 92       	push	r6
    1678:	7f 92       	push	r7
    167a:	8f 92       	push	r8
    167c:	9f 92       	push	r9
    167e:	af 92       	push	r10
    1680:	bf 92       	push	r11
    1682:	cf 92       	push	r12
    1684:	df 92       	push	r13
    1686:	ef 92       	push	r14
    1688:	ff 92       	push	r15
    168a:	0f 93       	push	r16
    168c:	1f 93       	push	r17
    168e:	2f 93       	push	r18
    1690:	3f 93       	push	r19
    1692:	4f 93       	push	r20
    1694:	5f 93       	push	r21
    1696:	6f 93       	push	r22
    1698:	7f 93       	push	r23
    169a:	8f 93       	push	r24
    169c:	9f 93       	push	r25
    169e:	af 93       	push	r26
    16a0:	bf 93       	push	r27
    16a2:	cf 93       	push	r28
    16a4:	df 93       	push	r29
    16a6:	ef 93       	push	r30
    16a8:	ff 93       	push	r31
    16aa:	a0 91 0a 23 	lds	r26, 0x230A	; 0x80230a <pxCurrentTCB>
    16ae:	b0 91 0b 23 	lds	r27, 0x230B	; 0x80230b <pxCurrentTCB+0x1>
    16b2:	0d b6       	in	r0, 0x3d	; 61
    16b4:	0d 92       	st	X+, r0
    16b6:	0e b6       	in	r0, 0x3e	; 62
    16b8:	0d 92       	st	X+, r0
    vTaskSwitchContext();
    16ba:	07 d6       	rcall	.+3086   	; 0x22ca <vTaskSwitchContext>
    portRESTORE_CONTEXT();
    16bc:	a0 91 0a 23 	lds	r26, 0x230A	; 0x80230a <pxCurrentTCB>
    16c0:	b0 91 0b 23 	lds	r27, 0x230B	; 0x80230b <pxCurrentTCB+0x1>
    16c4:	0d 90       	ld	r0, X+
    16c6:	0d be       	out	0x3d, r0	; 61
    16c8:	0d 90       	ld	r0, X+
    16ca:	0e be       	out	0x3e, r0	; 62
    16cc:	ff 91       	pop	r31
    16ce:	ef 91       	pop	r30
    16d0:	df 91       	pop	r29
    16d2:	cf 91       	pop	r28
    16d4:	bf 91       	pop	r27
    16d6:	af 91       	pop	r26
    16d8:	9f 91       	pop	r25
    16da:	8f 91       	pop	r24
    16dc:	7f 91       	pop	r23
    16de:	6f 91       	pop	r22
    16e0:	5f 91       	pop	r21
    16e2:	4f 91       	pop	r20
    16e4:	3f 91       	pop	r19
    16e6:	2f 91       	pop	r18
    16e8:	1f 91       	pop	r17
    16ea:	0f 91       	pop	r16
    16ec:	ff 90       	pop	r15
    16ee:	ef 90       	pop	r14
    16f0:	df 90       	pop	r13
    16f2:	cf 90       	pop	r12
    16f4:	bf 90       	pop	r11
    16f6:	af 90       	pop	r10
    16f8:	9f 90       	pop	r9
    16fa:	8f 90       	pop	r8
    16fc:	7f 90       	pop	r7
    16fe:	6f 90       	pop	r6
    1700:	5f 90       	pop	r5
    1702:	4f 90       	pop	r4
    1704:	3f 90       	pop	r3
    1706:	2f 90       	pop	r2
    1708:	1f 90       	pop	r1
    170a:	0f 90       	pop	r0
    170c:	0f be       	out	0x3f, r0	; 63
    170e:	0f 90       	pop	r0

    asm volatile ( "ret" );
    1710:	08 95       	ret

00001712 <__vector_14>:
         * Context switch function used by the tick.  This must be identical to
         * vPortYield() from the call to vTaskSwitchContext() onwards.  The only
         * difference from vPortYield() is the tick count is incremented as the
         * call comes from the tick ISR.
         */
        portSAVE_CONTEXT();
    1712:	0f 92       	push	r0
    1714:	0f b6       	in	r0, 0x3f	; 63
    1716:	f8 94       	cli
    1718:	0f 92       	push	r0
    171a:	1f 92       	push	r1
    171c:	11 24       	eor	r1, r1
    171e:	2f 92       	push	r2
    1720:	3f 92       	push	r3
    1722:	4f 92       	push	r4
    1724:	5f 92       	push	r5
    1726:	6f 92       	push	r6
    1728:	7f 92       	push	r7
    172a:	8f 92       	push	r8
    172c:	9f 92       	push	r9
    172e:	af 92       	push	r10
    1730:	bf 92       	push	r11
    1732:	cf 92       	push	r12
    1734:	df 92       	push	r13
    1736:	ef 92       	push	r14
    1738:	ff 92       	push	r15
    173a:	0f 93       	push	r16
    173c:	1f 93       	push	r17
    173e:	2f 93       	push	r18
    1740:	3f 93       	push	r19
    1742:	4f 93       	push	r20
    1744:	5f 93       	push	r21
    1746:	6f 93       	push	r22
    1748:	7f 93       	push	r23
    174a:	8f 93       	push	r24
    174c:	9f 93       	push	r25
    174e:	af 93       	push	r26
    1750:	bf 93       	push	r27
    1752:	cf 93       	push	r28
    1754:	df 93       	push	r29
    1756:	ef 93       	push	r30
    1758:	ff 93       	push	r31
    175a:	a0 91 0a 23 	lds	r26, 0x230A	; 0x80230a <pxCurrentTCB>
    175e:	b0 91 0b 23 	lds	r27, 0x230B	; 0x80230b <pxCurrentTCB+0x1>
    1762:	0d b6       	in	r0, 0x3d	; 61
    1764:	0d 92       	st	X+, r0
    1766:	0e b6       	in	r0, 0x3e	; 62
    1768:	0d 92       	st	X+, r0
        if( xTaskIncrementTick() != pdFALSE )
    176a:	44 d4       	rcall	.+2184   	; 0x1ff4 <xTaskIncrementTick>
    176c:	81 11       	cpse	r24, r1
        {
            vTaskSwitchContext();
    176e:	ad d5       	rcall	.+2906   	; 0x22ca <vTaskSwitchContext>
    1770:	a0 91 0a 23 	lds	r26, 0x230A	; 0x80230a <pxCurrentTCB>
        }
        portRESTORE_CONTEXT();
    1774:	b0 91 0b 23 	lds	r27, 0x230B	; 0x80230b <pxCurrentTCB+0x1>
    1778:	0d 90       	ld	r0, X+
    177a:	0d be       	out	0x3d, r0	; 61
    177c:	0d 90       	ld	r0, X+
    177e:	0e be       	out	0x3e, r0	; 62
    1780:	ff 91       	pop	r31
    1782:	ef 91       	pop	r30
    1784:	df 91       	pop	r29
    1786:	cf 91       	pop	r28
    1788:	bf 91       	pop	r27
    178a:	af 91       	pop	r26
    178c:	9f 91       	pop	r25
    178e:	8f 91       	pop	r24
    1790:	7f 91       	pop	r23
    1792:	6f 91       	pop	r22
    1794:	5f 91       	pop	r21
    1796:	4f 91       	pop	r20
    1798:	3f 91       	pop	r19
    179a:	2f 91       	pop	r18
    179c:	1f 91       	pop	r17
    179e:	0f 91       	pop	r16
    17a0:	ff 90       	pop	r15
    17a2:	ef 90       	pop	r14
    17a4:	df 90       	pop	r13
    17a6:	cf 90       	pop	r12
    17a8:	bf 90       	pop	r11
    17aa:	af 90       	pop	r10
    17ac:	9f 90       	pop	r9
    17ae:	8f 90       	pop	r8
    17b0:	7f 90       	pop	r7
    17b2:	6f 90       	pop	r6
    17b4:	5f 90       	pop	r5
    17b6:	4f 90       	pop	r4
    17b8:	3f 90       	pop	r3
    17ba:	2f 90       	pop	r2
    17bc:	1f 90       	pop	r1
    17be:	0f 90       	pop	r0
    17c0:	0f be       	out	0x3f, r0	; 63
    17c2:	0f 90       	pop	r0
    17c4:	18 95       	reti

000017c6 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    17c6:	cf 93       	push	r28
    17c8:	df 93       	push	r29
    17ca:	ec 01       	movw	r28, r24
void *pvReturn;

	vTaskSuspendAll();
    17cc:	03 d4       	rcall	.+2054   	; 0x1fd4 <vTaskSuspendAll>
	{
		pvReturn = malloc( xWantedSize );
    17ce:	ce 01       	movw	r24, r28
    17d0:	0e 94 60 17 	call	0x2ec0	; 0x2ec0 <malloc>
		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    17d4:	ec 01       	movw	r28, r24
    17d6:	e1 d4       	rcall	.+2498   	; 0x219a <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    17d8:	ce 01       	movw	r24, r28
    17da:	df 91       	pop	r29
    17dc:	cf 91       	pop	r28
    17de:	08 95       	ret

000017e0 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    17e0:	cf 93       	push	r28
    17e2:	df 93       	push	r29
	if( pv )
    17e4:	00 97       	sbiw	r24, 0x00	; 0
    17e6:	31 f0       	breq	.+12     	; 0x17f4 <vPortFree+0x14>
    17e8:	ec 01       	movw	r28, r24
	{
		vTaskSuspendAll();
    17ea:	f4 d3       	rcall	.+2024   	; 0x1fd4 <vTaskSuspendAll>
		{
			free( pv );
    17ec:	ce 01       	movw	r24, r28
    17ee:	0e 94 f8 17 	call	0x2ff0	; 0x2ff0 <free>
			traceFREE( pv, 0 );
		}
		( void ) xTaskResumeAll();
    17f2:	d3 d4       	rcall	.+2470   	; 0x219a <xTaskResumeAll>
	}
}
    17f4:	df 91       	pop	r29
    17f6:	cf 91       	pop	r28
    17f8:	08 95       	ret

000017fa <prvCopyDataToQueue>:
	{
		xReturn = pdFALSE;
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    17fa:	1f 93       	push	r17
    17fc:	cf 93       	push	r28
    17fe:	df 93       	push	r29
    1800:	ec 01       	movw	r28, r24
    1802:	14 2f       	mov	r17, r20
    1804:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1806:	44 23       	and	r20, r20
    1808:	d9 f1       	breq	.+118    	; 0x1880 <prvCopyDataToQueue+0x86>
    180a:	11 11       	cpse	r17, r1
    180c:	16 c0       	rjmp	.+44     	; 0x183a <prvCopyDataToQueue+0x40>
    180e:	50 e0       	ldi	r21, 0x00	; 0
    1810:	8c 81       	ldd	r24, Y+4	; 0x04
    1812:	9d 81       	ldd	r25, Y+5	; 0x05
    1814:	0e 94 81 18 	call	0x3102	; 0x3102 <memcpy>
    1818:	2c 8d       	ldd	r18, Y+28	; 0x1c
    181a:	8c 81       	ldd	r24, Y+4	; 0x04
    181c:	9d 81       	ldd	r25, Y+5	; 0x05
    181e:	82 0f       	add	r24, r18
    1820:	91 1d       	adc	r25, r1
    1822:	8c 83       	std	Y+4, r24	; 0x04
    1824:	9d 83       	std	Y+5, r25	; 0x05
    1826:	2a 81       	ldd	r18, Y+2	; 0x02
    1828:	3b 81       	ldd	r19, Y+3	; 0x03
    182a:	82 17       	cp	r24, r18
    182c:	93 07       	cpc	r25, r19
    182e:	40 f1       	brcs	.+80     	; 0x1880 <prvCopyDataToQueue+0x86>
    1830:	88 81       	ld	r24, Y
    1832:	99 81       	ldd	r25, Y+1	; 0x01
    1834:	8c 83       	std	Y+4, r24	; 0x04
    1836:	9d 83       	std	Y+5, r25	; 0x05
    1838:	23 c0       	rjmp	.+70     	; 0x1880 <prvCopyDataToQueue+0x86>
    183a:	50 e0       	ldi	r21, 0x00	; 0
    183c:	8e 81       	ldd	r24, Y+6	; 0x06
    183e:	9f 81       	ldd	r25, Y+7	; 0x07
    1840:	0e 94 81 18 	call	0x3102	; 0x3102 <memcpy>
    1844:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1846:	90 e0       	ldi	r25, 0x00	; 0
    1848:	91 95       	neg	r25
    184a:	81 95       	neg	r24
    184c:	91 09       	sbc	r25, r1
    184e:	2e 81       	ldd	r18, Y+6	; 0x06
    1850:	3f 81       	ldd	r19, Y+7	; 0x07
    1852:	28 0f       	add	r18, r24
    1854:	39 1f       	adc	r19, r25
    1856:	2e 83       	std	Y+6, r18	; 0x06
    1858:	3f 83       	std	Y+7, r19	; 0x07
    185a:	48 81       	ld	r20, Y
    185c:	59 81       	ldd	r21, Y+1	; 0x01
    185e:	24 17       	cp	r18, r20
    1860:	35 07       	cpc	r19, r21
    1862:	30 f4       	brcc	.+12     	; 0x1870 <prvCopyDataToQueue+0x76>
    1864:	2a 81       	ldd	r18, Y+2	; 0x02
    1866:	3b 81       	ldd	r19, Y+3	; 0x03
    1868:	82 0f       	add	r24, r18
    186a:	93 1f       	adc	r25, r19
    186c:	8e 83       	std	Y+6, r24	; 0x06
    186e:	9f 83       	std	Y+7, r25	; 0x07
    1870:	12 30       	cpi	r17, 0x02	; 2
    1872:	31 f4       	brne	.+12     	; 0x1880 <prvCopyDataToQueue+0x86>
    1874:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1876:	88 23       	and	r24, r24
    1878:	19 f0       	breq	.+6      	; 0x1880 <prvCopyDataToQueue+0x86>
    187a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    187c:	81 50       	subi	r24, 0x01	; 1
    187e:	8a 8f       	std	Y+26, r24	; 0x1a
    1880:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1882:	8f 5f       	subi	r24, 0xFF	; 255
    1884:	8a 8f       	std	Y+26, r24	; 0x1a
    1886:	80 e0       	ldi	r24, 0x00	; 0
    1888:	df 91       	pop	r29
    188a:	cf 91       	pop	r28
    188c:	1f 91       	pop	r17
    188e:	08 95       	ret

00001890 <prvCopyDataFromQueue>:
    1890:	fc 01       	movw	r30, r24
    1892:	44 8d       	ldd	r20, Z+28	; 0x1c
    1894:	44 23       	and	r20, r20
    1896:	a9 f0       	breq	.+42     	; 0x18c2 <prvCopyDataFromQueue+0x32>
    1898:	50 e0       	ldi	r21, 0x00	; 0
    189a:	26 81       	ldd	r18, Z+6	; 0x06
    189c:	37 81       	ldd	r19, Z+7	; 0x07
    189e:	24 0f       	add	r18, r20
    18a0:	35 1f       	adc	r19, r21
    18a2:	26 83       	std	Z+6, r18	; 0x06
    18a4:	37 83       	std	Z+7, r19	; 0x07
    18a6:	82 81       	ldd	r24, Z+2	; 0x02
    18a8:	93 81       	ldd	r25, Z+3	; 0x03
    18aa:	28 17       	cp	r18, r24
    18ac:	39 07       	cpc	r19, r25
    18ae:	20 f0       	brcs	.+8      	; 0x18b8 <prvCopyDataFromQueue+0x28>
    18b0:	80 81       	ld	r24, Z
    18b2:	91 81       	ldd	r25, Z+1	; 0x01
    18b4:	86 83       	std	Z+6, r24	; 0x06
    18b6:	97 83       	std	Z+7, r25	; 0x07
    18b8:	cb 01       	movw	r24, r22
    18ba:	66 81       	ldd	r22, Z+6	; 0x06
    18bc:	77 81       	ldd	r23, Z+7	; 0x07
    18be:	0c 94 81 18 	jmp	0x3102	; 0x3102 <memcpy>
    18c2:	08 95       	ret

000018c4 <prvUnlockQueue>:
    18c4:	0f 93       	push	r16
    18c6:	1f 93       	push	r17
    18c8:	cf 93       	push	r28
    18ca:	df 93       	push	r29
    18cc:	ec 01       	movw	r28, r24
    18ce:	0f b6       	in	r0, 0x3f	; 63
    18d0:	f8 94       	cli
    18d2:	0f 92       	push	r0
    18d4:	8e 8d       	ldd	r24, Y+30	; 0x1e
    18d6:	18 16       	cp	r1, r24
    18d8:	ac f4       	brge	.+42     	; 0x1904 <prvUnlockQueue+0x40>
    18da:	89 89       	ldd	r24, Y+17	; 0x11
    18dc:	81 11       	cpse	r24, r1
    18de:	05 c0       	rjmp	.+10     	; 0x18ea <prvUnlockQueue+0x26>
    18e0:	11 c0       	rjmp	.+34     	; 0x1904 <prvUnlockQueue+0x40>
    18e2:	89 89       	ldd	r24, Y+17	; 0x11
    18e4:	81 11       	cpse	r24, r1
    18e6:	04 c0       	rjmp	.+8      	; 0x18f0 <prvUnlockQueue+0x2c>
    18e8:	0d c0       	rjmp	.+26     	; 0x1904 <prvUnlockQueue+0x40>
    18ea:	8e 01       	movw	r16, r28
    18ec:	0f 5e       	subi	r16, 0xEF	; 239
    18ee:	1f 4f       	sbci	r17, 0xFF	; 255
    18f0:	c8 01       	movw	r24, r16
    18f2:	8c d5       	rcall	.+2840   	; 0x240c <xTaskRemoveFromEventList>
    18f4:	81 11       	cpse	r24, r1
    18f6:	0c d6       	rcall	.+3096   	; 0x2510 <vTaskMissedYield>
    18f8:	8e 8d       	ldd	r24, Y+30	; 0x1e
    18fa:	81 50       	subi	r24, 0x01	; 1
    18fc:	8e 8f       	std	Y+30, r24	; 0x1e
    18fe:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1900:	18 16       	cp	r1, r24
    1902:	7c f3       	brlt	.-34     	; 0x18e2 <prvUnlockQueue+0x1e>
    1904:	8f ef       	ldi	r24, 0xFF	; 255
    1906:	8e 8f       	std	Y+30, r24	; 0x1e
    1908:	0f 90       	pop	r0
    190a:	0f be       	out	0x3f, r0	; 63
    190c:	0f b6       	in	r0, 0x3f	; 63
    190e:	f8 94       	cli
    1910:	0f 92       	push	r0
    1912:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1914:	18 16       	cp	r1, r24
    1916:	ac f4       	brge	.+42     	; 0x1942 <prvUnlockQueue+0x7e>
    1918:	88 85       	ldd	r24, Y+8	; 0x08
    191a:	81 11       	cpse	r24, r1
    191c:	05 c0       	rjmp	.+10     	; 0x1928 <prvUnlockQueue+0x64>
    191e:	11 c0       	rjmp	.+34     	; 0x1942 <prvUnlockQueue+0x7e>
    1920:	88 85       	ldd	r24, Y+8	; 0x08
    1922:	81 11       	cpse	r24, r1
    1924:	04 c0       	rjmp	.+8      	; 0x192e <prvUnlockQueue+0x6a>
    1926:	0d c0       	rjmp	.+26     	; 0x1942 <prvUnlockQueue+0x7e>
    1928:	8e 01       	movw	r16, r28
    192a:	08 5f       	subi	r16, 0xF8	; 248
    192c:	1f 4f       	sbci	r17, 0xFF	; 255
    192e:	c8 01       	movw	r24, r16
    1930:	6d d5       	rcall	.+2778   	; 0x240c <xTaskRemoveFromEventList>
    1932:	81 11       	cpse	r24, r1
    1934:	ed d5       	rcall	.+3034   	; 0x2510 <vTaskMissedYield>
    1936:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1938:	81 50       	subi	r24, 0x01	; 1
    193a:	8d 8f       	std	Y+29, r24	; 0x1d
    193c:	8d 8d       	ldd	r24, Y+29	; 0x1d
    193e:	18 16       	cp	r1, r24
    1940:	7c f3       	brlt	.-34     	; 0x1920 <prvUnlockQueue+0x5c>
    1942:	8f ef       	ldi	r24, 0xFF	; 255
    1944:	8d 8f       	std	Y+29, r24	; 0x1d
    1946:	0f 90       	pop	r0
    1948:	0f be       	out	0x3f, r0	; 63
    194a:	df 91       	pop	r29
    194c:	cf 91       	pop	r28
    194e:	1f 91       	pop	r17
    1950:	0f 91       	pop	r16
    1952:	08 95       	ret

00001954 <xQueueGenericReset>:
    1954:	cf 93       	push	r28
    1956:	df 93       	push	r29
    1958:	ec 01       	movw	r28, r24
    195a:	0f b6       	in	r0, 0x3f	; 63
    195c:	f8 94       	cli
    195e:	0f 92       	push	r0
    1960:	48 81       	ld	r20, Y
    1962:	59 81       	ldd	r21, Y+1	; 0x01
    1964:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1966:	30 e0       	ldi	r19, 0x00	; 0
    1968:	7b 8d       	ldd	r23, Y+27	; 0x1b
    196a:	72 9f       	mul	r23, r18
    196c:	c0 01       	movw	r24, r0
    196e:	73 9f       	mul	r23, r19
    1970:	90 0d       	add	r25, r0
    1972:	11 24       	eor	r1, r1
    1974:	fa 01       	movw	r30, r20
    1976:	e8 0f       	add	r30, r24
    1978:	f9 1f       	adc	r31, r25
    197a:	ea 83       	std	Y+2, r30	; 0x02
    197c:	fb 83       	std	Y+3, r31	; 0x03
    197e:	1a 8e       	std	Y+26, r1	; 0x1a
    1980:	4c 83       	std	Y+4, r20	; 0x04
    1982:	5d 83       	std	Y+5, r21	; 0x05
    1984:	82 1b       	sub	r24, r18
    1986:	93 0b       	sbc	r25, r19
    1988:	84 0f       	add	r24, r20
    198a:	95 1f       	adc	r25, r21
    198c:	8e 83       	std	Y+6, r24	; 0x06
    198e:	9f 83       	std	Y+7, r25	; 0x07
    1990:	8f ef       	ldi	r24, 0xFF	; 255
    1992:	8d 8f       	std	Y+29, r24	; 0x1d
    1994:	8e 8f       	std	Y+30, r24	; 0x1e
    1996:	61 11       	cpse	r22, r1
    1998:	0a c0       	rjmp	.+20     	; 0x19ae <xQueueGenericReset+0x5a>
    199a:	88 85       	ldd	r24, Y+8	; 0x08
    199c:	88 23       	and	r24, r24
    199e:	69 f0       	breq	.+26     	; 0x19ba <xQueueGenericReset+0x66>
    19a0:	ce 01       	movw	r24, r28
    19a2:	08 96       	adiw	r24, 0x08	; 8
    19a4:	33 d5       	rcall	.+2662   	; 0x240c <xTaskRemoveFromEventList>
    19a6:	81 30       	cpi	r24, 0x01	; 1
    19a8:	41 f4       	brne	.+16     	; 0x19ba <xQueueGenericReset+0x66>
    19aa:	5b de       	rcall	.-842    	; 0x1662 <vPortYield>
    19ac:	06 c0       	rjmp	.+12     	; 0x19ba <xQueueGenericReset+0x66>
    19ae:	ce 01       	movw	r24, r28
    19b0:	08 96       	adiw	r24, 0x08	; 8
    19b2:	11 dd       	rcall	.-1502   	; 0x13d6 <vListInitialise>
    19b4:	ce 01       	movw	r24, r28
    19b6:	41 96       	adiw	r24, 0x11	; 17
    19b8:	0e dd       	rcall	.-1508   	; 0x13d6 <vListInitialise>
    19ba:	0f 90       	pop	r0
    19bc:	0f be       	out	0x3f, r0	; 63
    19be:	81 e0       	ldi	r24, 0x01	; 1
    19c0:	df 91       	pop	r29
    19c2:	cf 91       	pop	r28
    19c4:	08 95       	ret

000019c6 <xQueueGenericCreate>:
    19c6:	0f 93       	push	r16
    19c8:	1f 93       	push	r17
    19ca:	cf 93       	push	r28
    19cc:	df 93       	push	r29
    19ce:	08 2f       	mov	r16, r24
    19d0:	16 2f       	mov	r17, r22
    19d2:	66 23       	and	r22, r22
    19d4:	a9 f0       	breq	.+42     	; 0x1a00 <xQueueGenericCreate+0x3a>
    19d6:	86 9f       	mul	r24, r22
    19d8:	c0 01       	movw	r24, r0
    19da:	11 24       	eor	r1, r1
    19dc:	80 96       	adiw	r24, 0x20	; 32
    19de:	f3 de       	rcall	.-538    	; 0x17c6 <pvPortMalloc>
    19e0:	ec 01       	movw	r28, r24
    19e2:	00 97       	sbiw	r24, 0x00	; 0
    19e4:	21 f4       	brne	.+8      	; 0x19ee <xQueueGenericCreate+0x28>
    19e6:	12 c0       	rjmp	.+36     	; 0x1a0c <xQueueGenericCreate+0x46>
    19e8:	c8 83       	st	Y, r28
    19ea:	d9 83       	std	Y+1, r29	; 0x01
    19ec:	03 c0       	rjmp	.+6      	; 0x19f4 <xQueueGenericCreate+0x2e>
    19ee:	4f 96       	adiw	r24, 0x1f	; 31
    19f0:	88 83       	st	Y, r24
    19f2:	99 83       	std	Y+1, r25	; 0x01
    19f4:	0b 8f       	std	Y+27, r16	; 0x1b
    19f6:	1c 8f       	std	Y+28, r17	; 0x1c
    19f8:	61 e0       	ldi	r22, 0x01	; 1
    19fa:	ce 01       	movw	r24, r28
    19fc:	ab df       	rcall	.-170    	; 0x1954 <xQueueGenericReset>
    19fe:	06 c0       	rjmp	.+12     	; 0x1a0c <xQueueGenericCreate+0x46>
    1a00:	8f e1       	ldi	r24, 0x1F	; 31
    1a02:	90 e0       	ldi	r25, 0x00	; 0
    1a04:	e0 de       	rcall	.-576    	; 0x17c6 <pvPortMalloc>
    1a06:	ec 01       	movw	r28, r24
    1a08:	89 2b       	or	r24, r25
    1a0a:	71 f7       	brne	.-36     	; 0x19e8 <xQueueGenericCreate+0x22>
    1a0c:	ce 01       	movw	r24, r28
    1a0e:	df 91       	pop	r29
    1a10:	cf 91       	pop	r28
    1a12:	1f 91       	pop	r17
    1a14:	0f 91       	pop	r16
    1a16:	08 95       	ret

00001a18 <xQueueGenericSend>:
    1a18:	af 92       	push	r10
    1a1a:	bf 92       	push	r11
    1a1c:	cf 92       	push	r12
    1a1e:	df 92       	push	r13
    1a20:	ef 92       	push	r14
    1a22:	ff 92       	push	r15
    1a24:	0f 93       	push	r16
    1a26:	1f 93       	push	r17
    1a28:	cf 93       	push	r28
    1a2a:	df 93       	push	r29
    1a2c:	cd b7       	in	r28, 0x3d	; 61
    1a2e:	de b7       	in	r29, 0x3e	; 62
    1a30:	25 97       	sbiw	r28, 0x05	; 5
    1a32:	cd bf       	out	0x3d, r28	; 61
    1a34:	de bf       	out	0x3e, r29	; 62
    1a36:	8c 01       	movw	r16, r24
    1a38:	6b 01       	movw	r12, r22
    1a3a:	4c 83       	std	Y+4, r20	; 0x04
    1a3c:	5d 83       	std	Y+5, r21	; 0x05
    1a3e:	a2 2e       	mov	r10, r18
    1a40:	b1 2c       	mov	r11, r1
    1a42:	7c 01       	movw	r14, r24
    1a44:	88 e0       	ldi	r24, 0x08	; 8
    1a46:	e8 0e       	add	r14, r24
    1a48:	f1 1c       	adc	r15, r1
    1a4a:	0f b6       	in	r0, 0x3f	; 63
    1a4c:	f8 94       	cli
    1a4e:	0f 92       	push	r0
    1a50:	f8 01       	movw	r30, r16
    1a52:	92 8d       	ldd	r25, Z+26	; 0x1a
    1a54:	83 8d       	ldd	r24, Z+27	; 0x1b
    1a56:	98 17       	cp	r25, r24
    1a58:	18 f0       	brcs	.+6      	; 0x1a60 <xQueueGenericSend+0x48>
    1a5a:	f2 e0       	ldi	r31, 0x02	; 2
    1a5c:	af 12       	cpse	r10, r31
    1a5e:	15 c0       	rjmp	.+42     	; 0x1a8a <xQueueGenericSend+0x72>
    1a60:	4a 2d       	mov	r20, r10
    1a62:	b6 01       	movw	r22, r12
    1a64:	c8 01       	movw	r24, r16
    1a66:	c9 de       	rcall	.-622    	; 0x17fa <prvCopyDataToQueue>
    1a68:	f8 01       	movw	r30, r16
    1a6a:	91 89       	ldd	r25, Z+17	; 0x11
    1a6c:	99 23       	and	r25, r25
    1a6e:	39 f0       	breq	.+14     	; 0x1a7e <xQueueGenericSend+0x66>
    1a70:	c8 01       	movw	r24, r16
    1a72:	41 96       	adiw	r24, 0x11	; 17
    1a74:	cb d4       	rcall	.+2454   	; 0x240c <xTaskRemoveFromEventList>
    1a76:	81 30       	cpi	r24, 0x01	; 1
    1a78:	21 f4       	brne	.+8      	; 0x1a82 <xQueueGenericSend+0x6a>
    1a7a:	f3 dd       	rcall	.-1050   	; 0x1662 <vPortYield>
    1a7c:	02 c0       	rjmp	.+4      	; 0x1a82 <xQueueGenericSend+0x6a>
    1a7e:	81 11       	cpse	r24, r1
    1a80:	f0 dd       	rcall	.-1056   	; 0x1662 <vPortYield>
    1a82:	0f 90       	pop	r0
    1a84:	0f be       	out	0x3f, r0	; 63
    1a86:	81 e0       	ldi	r24, 0x01	; 1
    1a88:	46 c0       	rjmp	.+140    	; 0x1b16 <xQueueGenericSend+0xfe>
    1a8a:	8c 81       	ldd	r24, Y+4	; 0x04
    1a8c:	9d 81       	ldd	r25, Y+5	; 0x05
    1a8e:	89 2b       	or	r24, r25
    1a90:	21 f4       	brne	.+8      	; 0x1a9a <xQueueGenericSend+0x82>
    1a92:	0f 90       	pop	r0
    1a94:	0f be       	out	0x3f, r0	; 63
    1a96:	80 e0       	ldi	r24, 0x00	; 0
    1a98:	3e c0       	rjmp	.+124    	; 0x1b16 <xQueueGenericSend+0xfe>
    1a9a:	b1 10       	cpse	r11, r1
    1a9c:	05 c0       	rjmp	.+10     	; 0x1aa8 <xQueueGenericSend+0x90>
    1a9e:	ce 01       	movw	r24, r28
    1aa0:	01 96       	adiw	r24, 0x01	; 1
    1aa2:	fa d4       	rcall	.+2548   	; 0x2498 <vTaskSetTimeOutState>
    1aa4:	bb 24       	eor	r11, r11
    1aa6:	b3 94       	inc	r11
    1aa8:	0f 90       	pop	r0
    1aaa:	0f be       	out	0x3f, r0	; 63
    1aac:	93 d2       	rcall	.+1318   	; 0x1fd4 <vTaskSuspendAll>
    1aae:	0f b6       	in	r0, 0x3f	; 63
    1ab0:	f8 94       	cli
    1ab2:	0f 92       	push	r0
    1ab4:	f8 01       	movw	r30, r16
    1ab6:	85 8d       	ldd	r24, Z+29	; 0x1d
    1ab8:	8f 3f       	cpi	r24, 0xFF	; 255
    1aba:	09 f4       	brne	.+2      	; 0x1abe <xQueueGenericSend+0xa6>
    1abc:	15 8e       	std	Z+29, r1	; 0x1d
    1abe:	f8 01       	movw	r30, r16
    1ac0:	86 8d       	ldd	r24, Z+30	; 0x1e
    1ac2:	8f 3f       	cpi	r24, 0xFF	; 255
    1ac4:	09 f4       	brne	.+2      	; 0x1ac8 <xQueueGenericSend+0xb0>
    1ac6:	16 8e       	std	Z+30, r1	; 0x1e
    1ac8:	0f 90       	pop	r0
    1aca:	0f be       	out	0x3f, r0	; 63
    1acc:	be 01       	movw	r22, r28
    1ace:	6c 5f       	subi	r22, 0xFC	; 252
    1ad0:	7f 4f       	sbci	r23, 0xFF	; 255
    1ad2:	ce 01       	movw	r24, r28
    1ad4:	01 96       	adiw	r24, 0x01	; 1
    1ad6:	eb d4       	rcall	.+2518   	; 0x24ae <xTaskCheckForTimeOut>
    1ad8:	81 11       	cpse	r24, r1
    1ada:	19 c0       	rjmp	.+50     	; 0x1b0e <xQueueGenericSend+0xf6>
    1adc:	0f b6       	in	r0, 0x3f	; 63
    1ade:	f8 94       	cli
    1ae0:	0f 92       	push	r0
    1ae2:	f8 01       	movw	r30, r16
    1ae4:	92 8d       	ldd	r25, Z+26	; 0x1a
    1ae6:	0f 90       	pop	r0
    1ae8:	0f be       	out	0x3f, r0	; 63
    1aea:	83 8d       	ldd	r24, Z+27	; 0x1b
    1aec:	98 13       	cpse	r25, r24
    1aee:	0b c0       	rjmp	.+22     	; 0x1b06 <xQueueGenericSend+0xee>
    1af0:	6c 81       	ldd	r22, Y+4	; 0x04
    1af2:	7d 81       	ldd	r23, Y+5	; 0x05
    1af4:	c7 01       	movw	r24, r14
    1af6:	56 d4       	rcall	.+2220   	; 0x23a4 <vTaskPlaceOnEventList>
    1af8:	c8 01       	movw	r24, r16
    1afa:	e4 de       	rcall	.-568    	; 0x18c4 <prvUnlockQueue>
    1afc:	4e d3       	rcall	.+1692   	; 0x219a <xTaskResumeAll>
    1afe:	81 11       	cpse	r24, r1
    1b00:	a4 cf       	rjmp	.-184    	; 0x1a4a <xQueueGenericSend+0x32>
    1b02:	af dd       	rcall	.-1186   	; 0x1662 <vPortYield>
    1b04:	a2 cf       	rjmp	.-188    	; 0x1a4a <xQueueGenericSend+0x32>
    1b06:	c8 01       	movw	r24, r16
    1b08:	dd de       	rcall	.-582    	; 0x18c4 <prvUnlockQueue>
    1b0a:	47 d3       	rcall	.+1678   	; 0x219a <xTaskResumeAll>
    1b0c:	9e cf       	rjmp	.-196    	; 0x1a4a <xQueueGenericSend+0x32>
    1b0e:	c8 01       	movw	r24, r16
    1b10:	d9 de       	rcall	.-590    	; 0x18c4 <prvUnlockQueue>
    1b12:	43 d3       	rcall	.+1670   	; 0x219a <xTaskResumeAll>
    1b14:	80 e0       	ldi	r24, 0x00	; 0
    1b16:	25 96       	adiw	r28, 0x05	; 5
    1b18:	cd bf       	out	0x3d, r28	; 61
    1b1a:	de bf       	out	0x3e, r29	; 62
    1b1c:	df 91       	pop	r29
    1b1e:	cf 91       	pop	r28
    1b20:	1f 91       	pop	r17
    1b22:	0f 91       	pop	r16
    1b24:	ff 90       	pop	r15
    1b26:	ef 90       	pop	r14
    1b28:	df 90       	pop	r13
    1b2a:	cf 90       	pop	r12
    1b2c:	bf 90       	pop	r11
    1b2e:	af 90       	pop	r10
    1b30:	08 95       	ret

00001b32 <xQueueGenericSendFromISR>:
    1b32:	0f 93       	push	r16
    1b34:	1f 93       	push	r17
    1b36:	cf 93       	push	r28
    1b38:	df 93       	push	r29
    1b3a:	fa 01       	movw	r30, r20
    1b3c:	dc 01       	movw	r26, r24
    1b3e:	5a 96       	adiw	r26, 0x1a	; 26
    1b40:	5c 91       	ld	r21, X
    1b42:	5a 97       	sbiw	r26, 0x1a	; 26
    1b44:	5b 96       	adiw	r26, 0x1b	; 27
    1b46:	3c 91       	ld	r19, X
    1b48:	53 17       	cp	r21, r19
    1b4a:	10 f0       	brcs	.+4      	; 0x1b50 <xQueueGenericSendFromISR+0x1e>
    1b4c:	22 30       	cpi	r18, 0x02	; 2
    1b4e:	d9 f4       	brne	.+54     	; 0x1b86 <xQueueGenericSendFromISR+0x54>
    1b50:	42 2f       	mov	r20, r18
    1b52:	8f 01       	movw	r16, r30
    1b54:	ec 01       	movw	r28, r24
    1b56:	51 de       	rcall	.-862    	; 0x17fa <prvCopyDataToQueue>
    1b58:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1b5a:	8f 3f       	cpi	r24, 0xFF	; 255
    1b5c:	79 f4       	brne	.+30     	; 0x1b7c <xQueueGenericSendFromISR+0x4a>
    1b5e:	89 89       	ldd	r24, Y+17	; 0x11
    1b60:	88 23       	and	r24, r24
    1b62:	99 f0       	breq	.+38     	; 0x1b8a <xQueueGenericSendFromISR+0x58>
    1b64:	ce 01       	movw	r24, r28
    1b66:	41 96       	adiw	r24, 0x11	; 17
    1b68:	51 d4       	rcall	.+2210   	; 0x240c <xTaskRemoveFromEventList>
    1b6a:	88 23       	and	r24, r24
    1b6c:	81 f0       	breq	.+32     	; 0x1b8e <xQueueGenericSendFromISR+0x5c>
    1b6e:	01 15       	cp	r16, r1
    1b70:	11 05       	cpc	r17, r1
    1b72:	79 f0       	breq	.+30     	; 0x1b92 <xQueueGenericSendFromISR+0x60>
    1b74:	81 e0       	ldi	r24, 0x01	; 1
    1b76:	f8 01       	movw	r30, r16
    1b78:	80 83       	st	Z, r24
    1b7a:	0c c0       	rjmp	.+24     	; 0x1b94 <xQueueGenericSendFromISR+0x62>
    1b7c:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1b7e:	8f 5f       	subi	r24, 0xFF	; 255
    1b80:	8e 8f       	std	Y+30, r24	; 0x1e
    1b82:	81 e0       	ldi	r24, 0x01	; 1
    1b84:	07 c0       	rjmp	.+14     	; 0x1b94 <xQueueGenericSendFromISR+0x62>
    1b86:	80 e0       	ldi	r24, 0x00	; 0
    1b88:	05 c0       	rjmp	.+10     	; 0x1b94 <xQueueGenericSendFromISR+0x62>
    1b8a:	81 e0       	ldi	r24, 0x01	; 1
    1b8c:	03 c0       	rjmp	.+6      	; 0x1b94 <xQueueGenericSendFromISR+0x62>
    1b8e:	81 e0       	ldi	r24, 0x01	; 1
    1b90:	01 c0       	rjmp	.+2      	; 0x1b94 <xQueueGenericSendFromISR+0x62>
    1b92:	81 e0       	ldi	r24, 0x01	; 1
    1b94:	df 91       	pop	r29
    1b96:	cf 91       	pop	r28
    1b98:	1f 91       	pop	r17
    1b9a:	0f 91       	pop	r16
    1b9c:	08 95       	ret

00001b9e <xQueueGenericReceive>:
    1b9e:	af 92       	push	r10
    1ba0:	bf 92       	push	r11
    1ba2:	cf 92       	push	r12
    1ba4:	df 92       	push	r13
    1ba6:	ef 92       	push	r14
    1ba8:	ff 92       	push	r15
    1baa:	0f 93       	push	r16
    1bac:	1f 93       	push	r17
    1bae:	cf 93       	push	r28
    1bb0:	df 93       	push	r29
    1bb2:	cd b7       	in	r28, 0x3d	; 61
    1bb4:	de b7       	in	r29, 0x3e	; 62
    1bb6:	25 97       	sbiw	r28, 0x05	; 5
    1bb8:	cd bf       	out	0x3d, r28	; 61
    1bba:	de bf       	out	0x3e, r29	; 62
    1bbc:	8c 01       	movw	r16, r24
    1bbe:	6b 01       	movw	r12, r22
    1bc0:	4c 83       	std	Y+4, r20	; 0x04
    1bc2:	5d 83       	std	Y+5, r21	; 0x05
    1bc4:	a2 2e       	mov	r10, r18
    1bc6:	b1 2c       	mov	r11, r1
    1bc8:	7c 01       	movw	r14, r24
    1bca:	81 e1       	ldi	r24, 0x11	; 17
    1bcc:	e8 0e       	add	r14, r24
    1bce:	f1 1c       	adc	r15, r1
    1bd0:	0f b6       	in	r0, 0x3f	; 63
    1bd2:	f8 94       	cli
    1bd4:	0f 92       	push	r0
    1bd6:	f8 01       	movw	r30, r16
    1bd8:	82 8d       	ldd	r24, Z+26	; 0x1a
    1bda:	88 23       	and	r24, r24
    1bdc:	21 f1       	breq	.+72     	; 0x1c26 <xQueueGenericReceive+0x88>
    1bde:	e6 80       	ldd	r14, Z+6	; 0x06
    1be0:	f7 80       	ldd	r15, Z+7	; 0x07
    1be2:	b6 01       	movw	r22, r12
    1be4:	c8 01       	movw	r24, r16
    1be6:	54 de       	rcall	.-856    	; 0x1890 <prvCopyDataFromQueue>
    1be8:	a1 10       	cpse	r10, r1
    1bea:	0e c0       	rjmp	.+28     	; 0x1c08 <xQueueGenericReceive+0x6a>
    1bec:	f8 01       	movw	r30, r16
    1bee:	82 8d       	ldd	r24, Z+26	; 0x1a
    1bf0:	81 50       	subi	r24, 0x01	; 1
    1bf2:	82 8f       	std	Z+26, r24	; 0x1a
    1bf4:	80 85       	ldd	r24, Z+8	; 0x08
    1bf6:	88 23       	and	r24, r24
    1bf8:	91 f0       	breq	.+36     	; 0x1c1e <xQueueGenericReceive+0x80>
    1bfa:	c8 01       	movw	r24, r16
    1bfc:	08 96       	adiw	r24, 0x08	; 8
    1bfe:	06 d4       	rcall	.+2060   	; 0x240c <xTaskRemoveFromEventList>
    1c00:	81 30       	cpi	r24, 0x01	; 1
    1c02:	69 f4       	brne	.+26     	; 0x1c1e <xQueueGenericReceive+0x80>
    1c04:	2e dd       	rcall	.-1444   	; 0x1662 <vPortYield>
    1c06:	0b c0       	rjmp	.+22     	; 0x1c1e <xQueueGenericReceive+0x80>
    1c08:	f8 01       	movw	r30, r16
    1c0a:	e6 82       	std	Z+6, r14	; 0x06
    1c0c:	f7 82       	std	Z+7, r15	; 0x07
    1c0e:	81 89       	ldd	r24, Z+17	; 0x11
    1c10:	88 23       	and	r24, r24
    1c12:	29 f0       	breq	.+10     	; 0x1c1e <xQueueGenericReceive+0x80>
    1c14:	c8 01       	movw	r24, r16
    1c16:	41 96       	adiw	r24, 0x11	; 17
    1c18:	f9 d3       	rcall	.+2034   	; 0x240c <xTaskRemoveFromEventList>
    1c1a:	81 11       	cpse	r24, r1
    1c1c:	22 dd       	rcall	.-1468   	; 0x1662 <vPortYield>
    1c1e:	0f 90       	pop	r0
    1c20:	0f be       	out	0x3f, r0	; 63
    1c22:	81 e0       	ldi	r24, 0x01	; 1
    1c24:	45 c0       	rjmp	.+138    	; 0x1cb0 <xQueueGenericReceive+0x112>
    1c26:	8c 81       	ldd	r24, Y+4	; 0x04
    1c28:	9d 81       	ldd	r25, Y+5	; 0x05
    1c2a:	89 2b       	or	r24, r25
    1c2c:	21 f4       	brne	.+8      	; 0x1c36 <xQueueGenericReceive+0x98>
    1c2e:	0f 90       	pop	r0
    1c30:	0f be       	out	0x3f, r0	; 63
    1c32:	80 e0       	ldi	r24, 0x00	; 0
    1c34:	3d c0       	rjmp	.+122    	; 0x1cb0 <xQueueGenericReceive+0x112>
    1c36:	b1 10       	cpse	r11, r1
    1c38:	05 c0       	rjmp	.+10     	; 0x1c44 <xQueueGenericReceive+0xa6>
    1c3a:	ce 01       	movw	r24, r28
    1c3c:	01 96       	adiw	r24, 0x01	; 1
    1c3e:	2c d4       	rcall	.+2136   	; 0x2498 <vTaskSetTimeOutState>
    1c40:	bb 24       	eor	r11, r11
    1c42:	b3 94       	inc	r11
    1c44:	0f 90       	pop	r0
    1c46:	0f be       	out	0x3f, r0	; 63
    1c48:	c5 d1       	rcall	.+906    	; 0x1fd4 <vTaskSuspendAll>
    1c4a:	0f b6       	in	r0, 0x3f	; 63
    1c4c:	f8 94       	cli
    1c4e:	0f 92       	push	r0
    1c50:	f8 01       	movw	r30, r16
    1c52:	85 8d       	ldd	r24, Z+29	; 0x1d
    1c54:	8f 3f       	cpi	r24, 0xFF	; 255
    1c56:	09 f4       	brne	.+2      	; 0x1c5a <xQueueGenericReceive+0xbc>
    1c58:	15 8e       	std	Z+29, r1	; 0x1d
    1c5a:	f8 01       	movw	r30, r16
    1c5c:	86 8d       	ldd	r24, Z+30	; 0x1e
    1c5e:	8f 3f       	cpi	r24, 0xFF	; 255
    1c60:	09 f4       	brne	.+2      	; 0x1c64 <xQueueGenericReceive+0xc6>
    1c62:	16 8e       	std	Z+30, r1	; 0x1e
    1c64:	0f 90       	pop	r0
    1c66:	0f be       	out	0x3f, r0	; 63
    1c68:	be 01       	movw	r22, r28
    1c6a:	6c 5f       	subi	r22, 0xFC	; 252
    1c6c:	7f 4f       	sbci	r23, 0xFF	; 255
    1c6e:	ce 01       	movw	r24, r28
    1c70:	01 96       	adiw	r24, 0x01	; 1
    1c72:	1d d4       	rcall	.+2106   	; 0x24ae <xTaskCheckForTimeOut>
    1c74:	81 11       	cpse	r24, r1
    1c76:	18 c0       	rjmp	.+48     	; 0x1ca8 <xQueueGenericReceive+0x10a>
    1c78:	0f b6       	in	r0, 0x3f	; 63
    1c7a:	f8 94       	cli
    1c7c:	0f 92       	push	r0
    1c7e:	f8 01       	movw	r30, r16
    1c80:	82 8d       	ldd	r24, Z+26	; 0x1a
    1c82:	0f 90       	pop	r0
    1c84:	0f be       	out	0x3f, r0	; 63
    1c86:	81 11       	cpse	r24, r1
    1c88:	0b c0       	rjmp	.+22     	; 0x1ca0 <xQueueGenericReceive+0x102>
    1c8a:	6c 81       	ldd	r22, Y+4	; 0x04
    1c8c:	7d 81       	ldd	r23, Y+5	; 0x05
    1c8e:	c7 01       	movw	r24, r14
    1c90:	89 d3       	rcall	.+1810   	; 0x23a4 <vTaskPlaceOnEventList>
    1c92:	c8 01       	movw	r24, r16
    1c94:	17 de       	rcall	.-978    	; 0x18c4 <prvUnlockQueue>
    1c96:	81 d2       	rcall	.+1282   	; 0x219a <xTaskResumeAll>
    1c98:	81 11       	cpse	r24, r1
    1c9a:	9a cf       	rjmp	.-204    	; 0x1bd0 <xQueueGenericReceive+0x32>
    1c9c:	e2 dc       	rcall	.-1596   	; 0x1662 <vPortYield>
    1c9e:	98 cf       	rjmp	.-208    	; 0x1bd0 <xQueueGenericReceive+0x32>
    1ca0:	c8 01       	movw	r24, r16
    1ca2:	10 de       	rcall	.-992    	; 0x18c4 <prvUnlockQueue>
    1ca4:	7a d2       	rcall	.+1268   	; 0x219a <xTaskResumeAll>
    1ca6:	94 cf       	rjmp	.-216    	; 0x1bd0 <xQueueGenericReceive+0x32>
    1ca8:	c8 01       	movw	r24, r16
    1caa:	0c de       	rcall	.-1000   	; 0x18c4 <prvUnlockQueue>
    1cac:	76 d2       	rcall	.+1260   	; 0x219a <xTaskResumeAll>
    1cae:	80 e0       	ldi	r24, 0x00	; 0
    1cb0:	25 96       	adiw	r28, 0x05	; 5
    1cb2:	cd bf       	out	0x3d, r28	; 61
    1cb4:	de bf       	out	0x3e, r29	; 62
    1cb6:	df 91       	pop	r29
    1cb8:	cf 91       	pop	r28
    1cba:	1f 91       	pop	r17
    1cbc:	0f 91       	pop	r16
    1cbe:	ff 90       	pop	r15
    1cc0:	ef 90       	pop	r14
    1cc2:	df 90       	pop	r13
    1cc4:	cf 90       	pop	r12
    1cc6:	bf 90       	pop	r11
    1cc8:	af 90       	pop	r10
    1cca:	08 95       	ret

00001ccc <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait )
	{
    1ccc:	cf 93       	push	r28
    1cce:	df 93       	push	r29
    1cd0:	ec 01       	movw	r28, r24
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
    1cd2:	0f b6       	in	r0, 0x3f	; 63
    1cd4:	f8 94       	cli
    1cd6:	0f 92       	push	r0
    1cd8:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1cda:	8f 3f       	cpi	r24, 0xFF	; 255
    1cdc:	09 f4       	brne	.+2      	; 0x1ce0 <vQueueWaitForMessageRestricted+0x14>
    1cde:	1d 8e       	std	Y+29, r1	; 0x1d
    1ce0:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1ce2:	8f 3f       	cpi	r24, 0xFF	; 255
    1ce4:	09 f4       	brne	.+2      	; 0x1ce8 <vQueueWaitForMessageRestricted+0x1c>
    1ce6:	1e 8e       	std	Y+30, r1	; 0x1e
    1ce8:	0f 90       	pop	r0
    1cea:	0f be       	out	0x3f, r0	; 63
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    1cec:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1cee:	81 11       	cpse	r24, r1
    1cf0:	03 c0       	rjmp	.+6      	; 0x1cf8 <vQueueWaitForMessageRestricted+0x2c>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1cf2:	ce 01       	movw	r24, r28
    1cf4:	41 96       	adiw	r24, 0x11	; 17
    1cf6:	70 d3       	rcall	.+1760   	; 0x23d8 <vTaskPlaceOnEventListRestricted>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
    1cf8:	ce 01       	movw	r24, r28
    1cfa:	e4 dd       	rcall	.-1080   	; 0x18c4 <prvUnlockQueue>
	}
    1cfc:	df 91       	pop	r29
    1cfe:	cf 91       	pop	r28
    1d00:	08 95       	ret

00001d02 <prvIdleTask>:
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    1d02:	cd ed       	ldi	r28, 0xDD	; 221
    1d04:	d2 e2       	ldi	r29, 0x22	; 34
    1d06:	88 81       	ld	r24, Y
    1d08:	82 30       	cpi	r24, 0x02	; 2
    1d0a:	f0 f3       	brcs	.-4      	; 0x1d08 <prvIdleTask+0x6>
    1d0c:	aa dc       	rcall	.-1708   	; 0x1662 <vPortYield>
    1d0e:	fb cf       	rjmp	.-10     	; 0x1d06 <prvIdleTask+0x4>

00001d10 <prvAddCurrentTaskToDelayedList>:
    1d10:	cf 93       	push	r28
    1d12:	df 93       	push	r29
    1d14:	ec 01       	movw	r28, r24
    1d16:	e0 91 0a 23 	lds	r30, 0x230A	; 0x80230a <pxCurrentTCB>
    1d1a:	f0 91 0b 23 	lds	r31, 0x230B	; 0x80230b <pxCurrentTCB+0x1>
    1d1e:	82 83       	std	Z+2, r24	; 0x02
    1d20:	93 83       	std	Z+3, r25	; 0x03
    1d22:	80 91 bb 22 	lds	r24, 0x22BB	; 0x8022bb <xTickCount>
    1d26:	90 91 bc 22 	lds	r25, 0x22BC	; 0x8022bc <xTickCount+0x1>
    1d2a:	c8 17       	cp	r28, r24
    1d2c:	d9 07       	cpc	r29, r25
    1d2e:	60 f4       	brcc	.+24     	; 0x1d48 <prvAddCurrentTaskToDelayedList+0x38>
    1d30:	60 91 0a 23 	lds	r22, 0x230A	; 0x80230a <pxCurrentTCB>
    1d34:	70 91 0b 23 	lds	r23, 0x230B	; 0x80230b <pxCurrentTCB+0x1>
    1d38:	80 91 c7 22 	lds	r24, 0x22C7	; 0x8022c7 <pxOverflowDelayedTaskList>
    1d3c:	90 91 c8 22 	lds	r25, 0x22C8	; 0x8022c8 <pxOverflowDelayedTaskList+0x1>
    1d40:	6e 5f       	subi	r22, 0xFE	; 254
    1d42:	7f 4f       	sbci	r23, 0xFF	; 255
    1d44:	7b db       	rcall	.-2314   	; 0x143c <vListInsert>
    1d46:	16 c0       	rjmp	.+44     	; 0x1d74 <prvAddCurrentTaskToDelayedList+0x64>
    1d48:	60 91 0a 23 	lds	r22, 0x230A	; 0x80230a <pxCurrentTCB>
    1d4c:	70 91 0b 23 	lds	r23, 0x230B	; 0x80230b <pxCurrentTCB+0x1>
    1d50:	80 91 c9 22 	lds	r24, 0x22C9	; 0x8022c9 <pxDelayedTaskList>
    1d54:	90 91 ca 22 	lds	r25, 0x22CA	; 0x8022ca <pxDelayedTaskList+0x1>
    1d58:	6e 5f       	subi	r22, 0xFE	; 254
    1d5a:	7f 4f       	sbci	r23, 0xFF	; 255
    1d5c:	6f db       	rcall	.-2338   	; 0x143c <vListInsert>
    1d5e:	80 91 0d 20 	lds	r24, 0x200D	; 0x80200d <xNextTaskUnblockTime>
    1d62:	90 91 0e 20 	lds	r25, 0x200E	; 0x80200e <xNextTaskUnblockTime+0x1>
    1d66:	c8 17       	cp	r28, r24
    1d68:	d9 07       	cpc	r29, r25
    1d6a:	20 f4       	brcc	.+8      	; 0x1d74 <prvAddCurrentTaskToDelayedList+0x64>
    1d6c:	c0 93 0d 20 	sts	0x200D, r28	; 0x80200d <xNextTaskUnblockTime>
    1d70:	d0 93 0e 20 	sts	0x200E, r29	; 0x80200e <xNextTaskUnblockTime+0x1>
    1d74:	df 91       	pop	r29
    1d76:	cf 91       	pop	r28
    1d78:	08 95       	ret

00001d7a <xTaskGenericCreate>:
    1d7a:	4f 92       	push	r4
    1d7c:	5f 92       	push	r5
    1d7e:	6f 92       	push	r6
    1d80:	7f 92       	push	r7
    1d82:	8f 92       	push	r8
    1d84:	9f 92       	push	r9
    1d86:	af 92       	push	r10
    1d88:	bf 92       	push	r11
    1d8a:	cf 92       	push	r12
    1d8c:	df 92       	push	r13
    1d8e:	ef 92       	push	r14
    1d90:	ff 92       	push	r15
    1d92:	0f 93       	push	r16
    1d94:	1f 93       	push	r17
    1d96:	cf 93       	push	r28
    1d98:	df 93       	push	r29
    1d9a:	4c 01       	movw	r8, r24
    1d9c:	eb 01       	movw	r28, r22
    1d9e:	5a 01       	movw	r10, r20
    1da0:	29 01       	movw	r4, r18
    1da2:	c1 14       	cp	r12, r1
    1da4:	d1 04       	cpc	r13, r1
    1da6:	31 f4       	brne	.+12     	; 0x1db4 <xTaskGenericCreate+0x3a>
    1da8:	ca 01       	movw	r24, r20
    1daa:	0d dd       	rcall	.-1510   	; 0x17c6 <pvPortMalloc>
    1dac:	6c 01       	movw	r12, r24
    1dae:	89 2b       	or	r24, r25
    1db0:	09 f4       	brne	.+2      	; 0x1db4 <xTaskGenericCreate+0x3a>
    1db2:	d2 c0       	rjmp	.+420    	; 0x1f58 <xTaskGenericCreate+0x1de>
    1db4:	86 e2       	ldi	r24, 0x26	; 38
    1db6:	90 e0       	ldi	r25, 0x00	; 0
    1db8:	06 dd       	rcall	.-1524   	; 0x17c6 <pvPortMalloc>
    1dba:	3c 01       	movw	r6, r24
    1dbc:	00 97       	sbiw	r24, 0x00	; 0
    1dbe:	79 f0       	breq	.+30     	; 0x1dde <xTaskGenericCreate+0x64>
    1dc0:	fc 01       	movw	r30, r24
    1dc2:	c7 8a       	std	Z+23, r12	; 0x17
    1dc4:	d0 8e       	std	Z+24, r13	; 0x18
    1dc6:	f1 e0       	ldi	r31, 0x01	; 1
    1dc8:	af 1a       	sub	r10, r31
    1dca:	b1 08       	sbc	r11, r1
    1dcc:	ca 0c       	add	r12, r10
    1dce:	db 1c       	adc	r13, r11
    1dd0:	88 81       	ld	r24, Y
    1dd2:	f3 01       	movw	r30, r6
    1dd4:	81 8f       	std	Z+25, r24	; 0x19
    1dd6:	88 81       	ld	r24, Y
    1dd8:	81 11       	cpse	r24, r1
    1dda:	04 c0       	rjmp	.+8      	; 0x1de4 <xTaskGenericCreate+0x6a>
    1ddc:	13 c0       	rjmp	.+38     	; 0x1e04 <xTaskGenericCreate+0x8a>
    1dde:	c6 01       	movw	r24, r12
    1de0:	ff dc       	rcall	.-1538   	; 0x17e0 <vPortFree>
    1de2:	ba c0       	rjmp	.+372    	; 0x1f58 <xTaskGenericCreate+0x1de>
    1de4:	d3 01       	movw	r26, r6
    1de6:	5a 96       	adiw	r26, 0x1a	; 26
    1de8:	fe 01       	movw	r30, r28
    1dea:	31 96       	adiw	r30, 0x01	; 1
    1dec:	9e 01       	movw	r18, r28
    1dee:	28 5f       	subi	r18, 0xF8	; 248
    1df0:	3f 4f       	sbci	r19, 0xFF	; 255
    1df2:	ef 01       	movw	r28, r30
    1df4:	81 91       	ld	r24, Z+
    1df6:	8d 93       	st	X+, r24
    1df8:	88 81       	ld	r24, Y
    1dfa:	88 23       	and	r24, r24
    1dfc:	19 f0       	breq	.+6      	; 0x1e04 <xTaskGenericCreate+0x8a>
    1dfe:	2e 17       	cp	r18, r30
    1e00:	3f 07       	cpc	r19, r31
    1e02:	b9 f7       	brne	.-18     	; 0x1df2 <xTaskGenericCreate+0x78>
    1e04:	f3 01       	movw	r30, r6
    1e06:	10 a2       	std	Z+32, r1	; 0x20
    1e08:	10 2f       	mov	r17, r16
    1e0a:	05 30       	cpi	r16, 0x05	; 5
    1e0c:	08 f0       	brcs	.+2      	; 0x1e10 <xTaskGenericCreate+0x96>
    1e0e:	14 e0       	ldi	r17, 0x04	; 4
    1e10:	f3 01       	movw	r30, r6
    1e12:	16 8b       	std	Z+22, r17	; 0x16
    1e14:	e3 01       	movw	r28, r6
    1e16:	22 96       	adiw	r28, 0x02	; 2
    1e18:	ce 01       	movw	r24, r28
    1e1a:	eb da       	rcall	.-2602   	; 0x13f2 <vListInitialiseItem>
    1e1c:	c3 01       	movw	r24, r6
    1e1e:	0c 96       	adiw	r24, 0x0c	; 12
    1e20:	e8 da       	rcall	.-2608   	; 0x13f2 <vListInitialiseItem>
    1e22:	f3 01       	movw	r30, r6
    1e24:	60 86       	std	Z+8, r6	; 0x08
    1e26:	71 86       	std	Z+9, r7	; 0x09
    1e28:	85 e0       	ldi	r24, 0x05	; 5
    1e2a:	90 e0       	ldi	r25, 0x00	; 0
    1e2c:	81 1b       	sub	r24, r17
    1e2e:	91 09       	sbc	r25, r1
    1e30:	84 87       	std	Z+12, r24	; 0x0c
    1e32:	95 87       	std	Z+13, r25	; 0x0d
    1e34:	62 8a       	std	Z+18, r6	; 0x12
    1e36:	73 8a       	std	Z+19, r7	; 0x13
    1e38:	11 a2       	std	Z+33, r1	; 0x21
    1e3a:	12 a2       	std	Z+34, r1	; 0x22
    1e3c:	13 a2       	std	Z+35, r1	; 0x23
    1e3e:	14 a2       	std	Z+36, r1	; 0x24
    1e40:	15 a2       	std	Z+37, r1	; 0x25
    1e42:	a2 01       	movw	r20, r4
    1e44:	b4 01       	movw	r22, r8
    1e46:	c6 01       	movw	r24, r12
    1e48:	50 db       	rcall	.-2400   	; 0x14ea <pxPortInitialiseStack>
    1e4a:	f3 01       	movw	r30, r6
    1e4c:	80 83       	st	Z, r24
    1e4e:	91 83       	std	Z+1, r25	; 0x01
    1e50:	e1 14       	cp	r14, r1
    1e52:	f1 04       	cpc	r15, r1
    1e54:	19 f0       	breq	.+6      	; 0x1e5c <xTaskGenericCreate+0xe2>
    1e56:	f7 01       	movw	r30, r14
    1e58:	60 82       	st	Z, r6
    1e5a:	71 82       	std	Z+1, r7	; 0x01
    1e5c:	0f b6       	in	r0, 0x3f	; 63
    1e5e:	f8 94       	cli
    1e60:	0f 92       	push	r0
    1e62:	80 91 bd 22 	lds	r24, 0x22BD	; 0x8022bd <uxCurrentNumberOfTasks>
    1e66:	8f 5f       	subi	r24, 0xFF	; 255
    1e68:	80 93 bd 22 	sts	0x22BD, r24	; 0x8022bd <uxCurrentNumberOfTasks>
    1e6c:	80 91 0a 23 	lds	r24, 0x230A	; 0x80230a <pxCurrentTCB>
    1e70:	90 91 0b 23 	lds	r25, 0x230B	; 0x80230b <pxCurrentTCB+0x1>
    1e74:	89 2b       	or	r24, r25
    1e76:	91 f5       	brne	.+100    	; 0x1edc <xTaskGenericCreate+0x162>
    1e78:	60 92 0a 23 	sts	0x230A, r6	; 0x80230a <pxCurrentTCB>
    1e7c:	70 92 0b 23 	sts	0x230B, r7	; 0x80230b <pxCurrentTCB+0x1>
    1e80:	80 91 bd 22 	lds	r24, 0x22BD	; 0x8022bd <uxCurrentNumberOfTasks>
    1e84:	81 30       	cpi	r24, 0x01	; 1
    1e86:	c9 f5       	brne	.+114    	; 0x1efa <xTaskGenericCreate+0x180>
    1e88:	0f 2e       	mov	r0, r31
    1e8a:	fd ed       	ldi	r31, 0xDD	; 221
    1e8c:	ef 2e       	mov	r14, r31
    1e8e:	f2 e2       	ldi	r31, 0x22	; 34
    1e90:	ff 2e       	mov	r15, r31
    1e92:	f0 2d       	mov	r31, r0
    1e94:	0f 2e       	mov	r0, r31
    1e96:	fa e0       	ldi	r31, 0x0A	; 10
    1e98:	cf 2e       	mov	r12, r31
    1e9a:	f3 e2       	ldi	r31, 0x23	; 35
    1e9c:	df 2e       	mov	r13, r31
    1e9e:	f0 2d       	mov	r31, r0
    1ea0:	c7 01       	movw	r24, r14
    1ea2:	99 da       	rcall	.-2766   	; 0x13d6 <vListInitialise>
    1ea4:	f9 e0       	ldi	r31, 0x09	; 9
    1ea6:	ef 0e       	add	r14, r31
    1ea8:	f1 1c       	adc	r15, r1
    1eaa:	ec 14       	cp	r14, r12
    1eac:	fd 04       	cpc	r15, r13
    1eae:	c1 f7       	brne	.-16     	; 0x1ea0 <xTaskGenericCreate+0x126>
    1eb0:	84 ed       	ldi	r24, 0xD4	; 212
    1eb2:	92 e2       	ldi	r25, 0x22	; 34
    1eb4:	90 da       	rcall	.-2784   	; 0x13d6 <vListInitialise>
    1eb6:	8b ec       	ldi	r24, 0xCB	; 203
    1eb8:	92 e2       	ldi	r25, 0x22	; 34
    1eba:	8d da       	rcall	.-2790   	; 0x13d6 <vListInitialise>
    1ebc:	8e eb       	ldi	r24, 0xBE	; 190
    1ebe:	92 e2       	ldi	r25, 0x22	; 34
    1ec0:	8a da       	rcall	.-2796   	; 0x13d6 <vListInitialise>
    1ec2:	84 ed       	ldi	r24, 0xD4	; 212
    1ec4:	92 e2       	ldi	r25, 0x22	; 34
    1ec6:	80 93 c9 22 	sts	0x22C9, r24	; 0x8022c9 <pxDelayedTaskList>
    1eca:	90 93 ca 22 	sts	0x22CA, r25	; 0x8022ca <pxDelayedTaskList+0x1>
    1ece:	8b ec       	ldi	r24, 0xCB	; 203
    1ed0:	92 e2       	ldi	r25, 0x22	; 34
    1ed2:	80 93 c7 22 	sts	0x22C7, r24	; 0x8022c7 <pxOverflowDelayedTaskList>
    1ed6:	90 93 c8 22 	sts	0x22C8, r25	; 0x8022c8 <pxOverflowDelayedTaskList+0x1>
    1eda:	0f c0       	rjmp	.+30     	; 0x1efa <xTaskGenericCreate+0x180>
    1edc:	80 91 b9 22 	lds	r24, 0x22B9	; 0x8022b9 <xSchedulerRunning>
    1ee0:	81 11       	cpse	r24, r1
    1ee2:	0b c0       	rjmp	.+22     	; 0x1efa <xTaskGenericCreate+0x180>
    1ee4:	e0 91 0a 23 	lds	r30, 0x230A	; 0x80230a <pxCurrentTCB>
    1ee8:	f0 91 0b 23 	lds	r31, 0x230B	; 0x80230b <pxCurrentTCB+0x1>
    1eec:	86 89       	ldd	r24, Z+22	; 0x16
    1eee:	08 17       	cp	r16, r24
    1ef0:	20 f0       	brcs	.+8      	; 0x1efa <xTaskGenericCreate+0x180>
    1ef2:	60 92 0a 23 	sts	0x230A, r6	; 0x80230a <pxCurrentTCB>
    1ef6:	70 92 0b 23 	sts	0x230B, r7	; 0x80230b <pxCurrentTCB+0x1>
    1efa:	80 91 b5 22 	lds	r24, 0x22B5	; 0x8022b5 <uxTaskNumber>
    1efe:	8f 5f       	subi	r24, 0xFF	; 255
    1f00:	80 93 b5 22 	sts	0x22B5, r24	; 0x8022b5 <uxTaskNumber>
    1f04:	f3 01       	movw	r30, r6
    1f06:	86 89       	ldd	r24, Z+22	; 0x16
    1f08:	90 91 ba 22 	lds	r25, 0x22BA	; 0x8022ba <uxTopReadyPriority>
    1f0c:	98 17       	cp	r25, r24
    1f0e:	10 f4       	brcc	.+4      	; 0x1f14 <xTaskGenericCreate+0x19a>
    1f10:	80 93 ba 22 	sts	0x22BA, r24	; 0x8022ba <uxTopReadyPriority>
    1f14:	90 e0       	ldi	r25, 0x00	; 0
    1f16:	9c 01       	movw	r18, r24
    1f18:	22 0f       	add	r18, r18
    1f1a:	33 1f       	adc	r19, r19
    1f1c:	22 0f       	add	r18, r18
    1f1e:	33 1f       	adc	r19, r19
    1f20:	22 0f       	add	r18, r18
    1f22:	33 1f       	adc	r19, r19
    1f24:	82 0f       	add	r24, r18
    1f26:	93 1f       	adc	r25, r19
    1f28:	be 01       	movw	r22, r28
    1f2a:	83 52       	subi	r24, 0x23	; 35
    1f2c:	9d 4d       	sbci	r25, 0xDD	; 221
    1f2e:	65 da       	rcall	.-2870   	; 0x13fa <vListInsertEnd>
    1f30:	0f 90       	pop	r0
    1f32:	0f be       	out	0x3f, r0	; 63
    1f34:	80 91 b9 22 	lds	r24, 0x22B9	; 0x8022b9 <xSchedulerRunning>
    1f38:	88 23       	and	r24, r24
    1f3a:	51 f0       	breq	.+20     	; 0x1f50 <xTaskGenericCreate+0x1d6>
    1f3c:	e0 91 0a 23 	lds	r30, 0x230A	; 0x80230a <pxCurrentTCB>
    1f40:	f0 91 0b 23 	lds	r31, 0x230B	; 0x80230b <pxCurrentTCB+0x1>
    1f44:	86 89       	ldd	r24, Z+22	; 0x16
    1f46:	80 17       	cp	r24, r16
    1f48:	28 f4       	brcc	.+10     	; 0x1f54 <xTaskGenericCreate+0x1da>
    1f4a:	8b db       	rcall	.-2282   	; 0x1662 <vPortYield>
    1f4c:	81 e0       	ldi	r24, 0x01	; 1
    1f4e:	05 c0       	rjmp	.+10     	; 0x1f5a <xTaskGenericCreate+0x1e0>
    1f50:	81 e0       	ldi	r24, 0x01	; 1
    1f52:	03 c0       	rjmp	.+6      	; 0x1f5a <xTaskGenericCreate+0x1e0>
    1f54:	81 e0       	ldi	r24, 0x01	; 1
    1f56:	01 c0       	rjmp	.+2      	; 0x1f5a <xTaskGenericCreate+0x1e0>
    1f58:	8f ef       	ldi	r24, 0xFF	; 255
    1f5a:	df 91       	pop	r29
    1f5c:	cf 91       	pop	r28
    1f5e:	1f 91       	pop	r17
    1f60:	0f 91       	pop	r16
    1f62:	ff 90       	pop	r15
    1f64:	ef 90       	pop	r14
    1f66:	df 90       	pop	r13
    1f68:	cf 90       	pop	r12
    1f6a:	bf 90       	pop	r11
    1f6c:	af 90       	pop	r10
    1f6e:	9f 90       	pop	r9
    1f70:	8f 90       	pop	r8
    1f72:	7f 90       	pop	r7
    1f74:	6f 90       	pop	r6
    1f76:	5f 90       	pop	r5
    1f78:	4f 90       	pop	r4
    1f7a:	08 95       	ret

00001f7c <vTaskStartScheduler>:
    1f7c:	af 92       	push	r10
    1f7e:	bf 92       	push	r11
    1f80:	cf 92       	push	r12
    1f82:	df 92       	push	r13
    1f84:	ef 92       	push	r14
    1f86:	ff 92       	push	r15
    1f88:	0f 93       	push	r16
    1f8a:	a1 2c       	mov	r10, r1
    1f8c:	b1 2c       	mov	r11, r1
    1f8e:	c1 2c       	mov	r12, r1
    1f90:	d1 2c       	mov	r13, r1
    1f92:	e1 2c       	mov	r14, r1
    1f94:	f1 2c       	mov	r15, r1
    1f96:	00 e0       	ldi	r16, 0x00	; 0
    1f98:	20 e0       	ldi	r18, 0x00	; 0
    1f9a:	30 e0       	ldi	r19, 0x00	; 0
    1f9c:	45 e5       	ldi	r20, 0x55	; 85
    1f9e:	50 e0       	ldi	r21, 0x00	; 0
    1fa0:	6f e0       	ldi	r22, 0x0F	; 15
    1fa2:	70 e2       	ldi	r23, 0x20	; 32
    1fa4:	81 e8       	ldi	r24, 0x81	; 129
    1fa6:	9e e0       	ldi	r25, 0x0E	; 14
    1fa8:	e8 de       	rcall	.-560    	; 0x1d7a <xTaskGenericCreate>
    1faa:	81 30       	cpi	r24, 0x01	; 1
    1fac:	59 f4       	brne	.+22     	; 0x1fc4 <vTaskStartScheduler+0x48>
    1fae:	19 d3       	rcall	.+1586   	; 0x25e2 <xTimerCreateTimerTask>
    1fb0:	81 30       	cpi	r24, 0x01	; 1
    1fb2:	41 f4       	brne	.+16     	; 0x1fc4 <vTaskStartScheduler+0x48>
    1fb4:	f8 94       	cli
    1fb6:	80 93 b9 22 	sts	0x22B9, r24	; 0x8022b9 <xSchedulerRunning>
    1fba:	10 92 bb 22 	sts	0x22BB, r1	; 0x8022bb <xTickCount>
    1fbe:	10 92 bc 22 	sts	0x22BC, r1	; 0x8022bc <xTickCount+0x1>
    1fc2:	0a db       	rcall	.-2540   	; 0x15d8 <xPortStartScheduler>
    1fc4:	0f 91       	pop	r16
    1fc6:	ff 90       	pop	r15
    1fc8:	ef 90       	pop	r14
    1fca:	df 90       	pop	r13
    1fcc:	cf 90       	pop	r12
    1fce:	bf 90       	pop	r11
    1fd0:	af 90       	pop	r10
    1fd2:	08 95       	ret

00001fd4 <vTaskSuspendAll>:
    1fd4:	80 91 b4 22 	lds	r24, 0x22B4	; 0x8022b4 <uxSchedulerSuspended>
    1fd8:	8f 5f       	subi	r24, 0xFF	; 255
    1fda:	80 93 b4 22 	sts	0x22B4, r24	; 0x8022b4 <uxSchedulerSuspended>
    1fde:	08 95       	ret

00001fe0 <xTaskGetTickCount>:
    1fe0:	0f b6       	in	r0, 0x3f	; 63
    1fe2:	f8 94       	cli
    1fe4:	0f 92       	push	r0
    1fe6:	80 91 bb 22 	lds	r24, 0x22BB	; 0x8022bb <xTickCount>
    1fea:	90 91 bc 22 	lds	r25, 0x22BC	; 0x8022bc <xTickCount+0x1>
    1fee:	0f 90       	pop	r0
    1ff0:	0f be       	out	0x3f, r0	; 63
    1ff2:	08 95       	ret

00001ff4 <xTaskIncrementTick>:
    1ff4:	df 92       	push	r13
    1ff6:	ef 92       	push	r14
    1ff8:	ff 92       	push	r15
    1ffa:	0f 93       	push	r16
    1ffc:	1f 93       	push	r17
    1ffe:	cf 93       	push	r28
    2000:	df 93       	push	r29
    2002:	80 91 b4 22 	lds	r24, 0x22B4	; 0x8022b4 <uxSchedulerSuspended>
    2006:	81 11       	cpse	r24, r1
    2008:	b3 c0       	rjmp	.+358    	; 0x2170 <xTaskIncrementTick+0x17c>
    200a:	80 91 bb 22 	lds	r24, 0x22BB	; 0x8022bb <xTickCount>
    200e:	90 91 bc 22 	lds	r25, 0x22BC	; 0x8022bc <xTickCount+0x1>
    2012:	01 96       	adiw	r24, 0x01	; 1
    2014:	80 93 bb 22 	sts	0x22BB, r24	; 0x8022bb <xTickCount>
    2018:	90 93 bc 22 	sts	0x22BC, r25	; 0x8022bc <xTickCount+0x1>
    201c:	e0 90 bb 22 	lds	r14, 0x22BB	; 0x8022bb <xTickCount>
    2020:	f0 90 bc 22 	lds	r15, 0x22BC	; 0x8022bc <xTickCount+0x1>
    2024:	e1 14       	cp	r14, r1
    2026:	f1 04       	cpc	r15, r1
    2028:	99 f5       	brne	.+102    	; 0x2090 <xTaskIncrementTick+0x9c>
    202a:	80 91 c9 22 	lds	r24, 0x22C9	; 0x8022c9 <pxDelayedTaskList>
    202e:	90 91 ca 22 	lds	r25, 0x22CA	; 0x8022ca <pxDelayedTaskList+0x1>
    2032:	20 91 c7 22 	lds	r18, 0x22C7	; 0x8022c7 <pxOverflowDelayedTaskList>
    2036:	30 91 c8 22 	lds	r19, 0x22C8	; 0x8022c8 <pxOverflowDelayedTaskList+0x1>
    203a:	20 93 c9 22 	sts	0x22C9, r18	; 0x8022c9 <pxDelayedTaskList>
    203e:	30 93 ca 22 	sts	0x22CA, r19	; 0x8022ca <pxDelayedTaskList+0x1>
    2042:	80 93 c7 22 	sts	0x22C7, r24	; 0x8022c7 <pxOverflowDelayedTaskList>
    2046:	90 93 c8 22 	sts	0x22C8, r25	; 0x8022c8 <pxOverflowDelayedTaskList+0x1>
    204a:	80 91 b6 22 	lds	r24, 0x22B6	; 0x8022b6 <xNumOfOverflows>
    204e:	8f 5f       	subi	r24, 0xFF	; 255
    2050:	80 93 b6 22 	sts	0x22B6, r24	; 0x8022b6 <xNumOfOverflows>
    2054:	e0 91 c9 22 	lds	r30, 0x22C9	; 0x8022c9 <pxDelayedTaskList>
    2058:	f0 91 ca 22 	lds	r31, 0x22CA	; 0x8022ca <pxDelayedTaskList+0x1>
    205c:	80 81       	ld	r24, Z
    205e:	81 11       	cpse	r24, r1
    2060:	07 c0       	rjmp	.+14     	; 0x2070 <xTaskIncrementTick+0x7c>
    2062:	8f ef       	ldi	r24, 0xFF	; 255
    2064:	9f ef       	ldi	r25, 0xFF	; 255
    2066:	80 93 0d 20 	sts	0x200D, r24	; 0x80200d <xNextTaskUnblockTime>
    206a:	90 93 0e 20 	sts	0x200E, r25	; 0x80200e <xNextTaskUnblockTime+0x1>
    206e:	10 c0       	rjmp	.+32     	; 0x2090 <xTaskIncrementTick+0x9c>
    2070:	e0 91 c9 22 	lds	r30, 0x22C9	; 0x8022c9 <pxDelayedTaskList>
    2074:	f0 91 ca 22 	lds	r31, 0x22CA	; 0x8022ca <pxDelayedTaskList+0x1>
    2078:	05 80       	ldd	r0, Z+5	; 0x05
    207a:	f6 81       	ldd	r31, Z+6	; 0x06
    207c:	e0 2d       	mov	r30, r0
    207e:	06 80       	ldd	r0, Z+6	; 0x06
    2080:	f7 81       	ldd	r31, Z+7	; 0x07
    2082:	e0 2d       	mov	r30, r0
    2084:	82 81       	ldd	r24, Z+2	; 0x02
    2086:	93 81       	ldd	r25, Z+3	; 0x03
    2088:	80 93 0d 20 	sts	0x200D, r24	; 0x80200d <xNextTaskUnblockTime>
    208c:	90 93 0e 20 	sts	0x200E, r25	; 0x80200e <xNextTaskUnblockTime+0x1>
    2090:	80 91 0d 20 	lds	r24, 0x200D	; 0x80200d <xNextTaskUnblockTime>
    2094:	90 91 0e 20 	lds	r25, 0x200E	; 0x80200e <xNextTaskUnblockTime+0x1>
    2098:	e8 16       	cp	r14, r24
    209a:	f9 06       	cpc	r15, r25
    209c:	10 f4       	brcc	.+4      	; 0x20a2 <xTaskIncrementTick+0xae>
    209e:	d1 2c       	mov	r13, r1
    20a0:	4f c0       	rjmp	.+158    	; 0x2140 <xTaskIncrementTick+0x14c>
    20a2:	d1 2c       	mov	r13, r1
    20a4:	e0 91 c9 22 	lds	r30, 0x22C9	; 0x8022c9 <pxDelayedTaskList>
    20a8:	f0 91 ca 22 	lds	r31, 0x22CA	; 0x8022ca <pxDelayedTaskList+0x1>
    20ac:	80 81       	ld	r24, Z
    20ae:	81 11       	cpse	r24, r1
    20b0:	07 c0       	rjmp	.+14     	; 0x20c0 <xTaskIncrementTick+0xcc>
    20b2:	8f ef       	ldi	r24, 0xFF	; 255
    20b4:	9f ef       	ldi	r25, 0xFF	; 255
    20b6:	80 93 0d 20 	sts	0x200D, r24	; 0x80200d <xNextTaskUnblockTime>
    20ba:	90 93 0e 20 	sts	0x200E, r25	; 0x80200e <xNextTaskUnblockTime+0x1>
    20be:	40 c0       	rjmp	.+128    	; 0x2140 <xTaskIncrementTick+0x14c>
    20c0:	e0 91 c9 22 	lds	r30, 0x22C9	; 0x8022c9 <pxDelayedTaskList>
    20c4:	f0 91 ca 22 	lds	r31, 0x22CA	; 0x8022ca <pxDelayedTaskList+0x1>
    20c8:	05 80       	ldd	r0, Z+5	; 0x05
    20ca:	f6 81       	ldd	r31, Z+6	; 0x06
    20cc:	e0 2d       	mov	r30, r0
    20ce:	c6 81       	ldd	r28, Z+6	; 0x06
    20d0:	d7 81       	ldd	r29, Z+7	; 0x07
    20d2:	8a 81       	ldd	r24, Y+2	; 0x02
    20d4:	9b 81       	ldd	r25, Y+3	; 0x03
    20d6:	e8 16       	cp	r14, r24
    20d8:	f9 06       	cpc	r15, r25
    20da:	28 f4       	brcc	.+10     	; 0x20e6 <xTaskIncrementTick+0xf2>
    20dc:	80 93 0d 20 	sts	0x200D, r24	; 0x80200d <xNextTaskUnblockTime>
    20e0:	90 93 0e 20 	sts	0x200E, r25	; 0x80200e <xNextTaskUnblockTime+0x1>
    20e4:	2d c0       	rjmp	.+90     	; 0x2140 <xTaskIncrementTick+0x14c>
    20e6:	8e 01       	movw	r16, r28
    20e8:	0e 5f       	subi	r16, 0xFE	; 254
    20ea:	1f 4f       	sbci	r17, 0xFF	; 255
    20ec:	c8 01       	movw	r24, r16
    20ee:	d7 d9       	rcall	.-3154   	; 0x149e <uxListRemove>
    20f0:	8c 89       	ldd	r24, Y+20	; 0x14
    20f2:	9d 89       	ldd	r25, Y+21	; 0x15
    20f4:	89 2b       	or	r24, r25
    20f6:	19 f0       	breq	.+6      	; 0x20fe <xTaskIncrementTick+0x10a>
    20f8:	ce 01       	movw	r24, r28
    20fa:	0c 96       	adiw	r24, 0x0c	; 12
    20fc:	d0 d9       	rcall	.-3168   	; 0x149e <uxListRemove>
    20fe:	8e 89       	ldd	r24, Y+22	; 0x16
    2100:	90 91 ba 22 	lds	r25, 0x22BA	; 0x8022ba <uxTopReadyPriority>
    2104:	98 17       	cp	r25, r24
    2106:	10 f4       	brcc	.+4      	; 0x210c <xTaskIncrementTick+0x118>
    2108:	80 93 ba 22 	sts	0x22BA, r24	; 0x8022ba <uxTopReadyPriority>
    210c:	90 e0       	ldi	r25, 0x00	; 0
    210e:	9c 01       	movw	r18, r24
    2110:	22 0f       	add	r18, r18
    2112:	33 1f       	adc	r19, r19
    2114:	22 0f       	add	r18, r18
    2116:	33 1f       	adc	r19, r19
    2118:	22 0f       	add	r18, r18
    211a:	33 1f       	adc	r19, r19
    211c:	82 0f       	add	r24, r18
    211e:	93 1f       	adc	r25, r19
    2120:	b8 01       	movw	r22, r16
    2122:	83 52       	subi	r24, 0x23	; 35
    2124:	9d 4d       	sbci	r25, 0xDD	; 221
    2126:	69 d9       	rcall	.-3374   	; 0x13fa <vListInsertEnd>
    2128:	e0 91 0a 23 	lds	r30, 0x230A	; 0x80230a <pxCurrentTCB>
    212c:	f0 91 0b 23 	lds	r31, 0x230B	; 0x80230b <pxCurrentTCB+0x1>
    2130:	9e 89       	ldd	r25, Y+22	; 0x16
    2132:	86 89       	ldd	r24, Z+22	; 0x16
    2134:	98 17       	cp	r25, r24
    2136:	08 f4       	brcc	.+2      	; 0x213a <xTaskIncrementTick+0x146>
    2138:	b5 cf       	rjmp	.-150    	; 0x20a4 <xTaskIncrementTick+0xb0>
    213a:	dd 24       	eor	r13, r13
    213c:	d3 94       	inc	r13
    213e:	b2 cf       	rjmp	.-156    	; 0x20a4 <xTaskIncrementTick+0xb0>
    2140:	e0 91 0a 23 	lds	r30, 0x230A	; 0x80230a <pxCurrentTCB>
    2144:	f0 91 0b 23 	lds	r31, 0x230B	; 0x80230b <pxCurrentTCB+0x1>
    2148:	86 89       	ldd	r24, Z+22	; 0x16
    214a:	90 e0       	ldi	r25, 0x00	; 0
    214c:	fc 01       	movw	r30, r24
    214e:	ee 0f       	add	r30, r30
    2150:	ff 1f       	adc	r31, r31
    2152:	ee 0f       	add	r30, r30
    2154:	ff 1f       	adc	r31, r31
    2156:	ee 0f       	add	r30, r30
    2158:	ff 1f       	adc	r31, r31
    215a:	8e 0f       	add	r24, r30
    215c:	9f 1f       	adc	r25, r31
    215e:	fc 01       	movw	r30, r24
    2160:	e3 52       	subi	r30, 0x23	; 35
    2162:	fd 4d       	sbci	r31, 0xDD	; 221
    2164:	80 81       	ld	r24, Z
    2166:	82 30       	cpi	r24, 0x02	; 2
    2168:	48 f0       	brcs	.+18     	; 0x217c <xTaskIncrementTick+0x188>
    216a:	dd 24       	eor	r13, r13
    216c:	d3 94       	inc	r13
    216e:	06 c0       	rjmp	.+12     	; 0x217c <xTaskIncrementTick+0x188>
    2170:	80 91 b8 22 	lds	r24, 0x22B8	; 0x8022b8 <uxPendedTicks>
    2174:	8f 5f       	subi	r24, 0xFF	; 255
    2176:	80 93 b8 22 	sts	0x22B8, r24	; 0x8022b8 <uxPendedTicks>
    217a:	d1 2c       	mov	r13, r1
    217c:	80 91 b7 22 	lds	r24, 0x22B7	; 0x8022b7 <xYieldPending>
    2180:	88 23       	and	r24, r24
    2182:	11 f0       	breq	.+4      	; 0x2188 <xTaskIncrementTick+0x194>
    2184:	dd 24       	eor	r13, r13
    2186:	d3 94       	inc	r13
    2188:	8d 2d       	mov	r24, r13
    218a:	df 91       	pop	r29
    218c:	cf 91       	pop	r28
    218e:	1f 91       	pop	r17
    2190:	0f 91       	pop	r16
    2192:	ff 90       	pop	r15
    2194:	ef 90       	pop	r14
    2196:	df 90       	pop	r13
    2198:	08 95       	ret

0000219a <xTaskResumeAll>:
    219a:	df 92       	push	r13
    219c:	ef 92       	push	r14
    219e:	ff 92       	push	r15
    21a0:	0f 93       	push	r16
    21a2:	1f 93       	push	r17
    21a4:	cf 93       	push	r28
    21a6:	df 93       	push	r29
    21a8:	0f b6       	in	r0, 0x3f	; 63
    21aa:	f8 94       	cli
    21ac:	0f 92       	push	r0
    21ae:	80 91 b4 22 	lds	r24, 0x22B4	; 0x8022b4 <uxSchedulerSuspended>
    21b2:	81 50       	subi	r24, 0x01	; 1
    21b4:	80 93 b4 22 	sts	0x22B4, r24	; 0x8022b4 <uxSchedulerSuspended>
    21b8:	80 91 b4 22 	lds	r24, 0x22B4	; 0x8022b4 <uxSchedulerSuspended>
    21bc:	81 11       	cpse	r24, r1
    21be:	5d c0       	rjmp	.+186    	; 0x227a <xTaskResumeAll+0xe0>
    21c0:	80 91 bd 22 	lds	r24, 0x22BD	; 0x8022bd <uxCurrentNumberOfTasks>
    21c4:	81 11       	cpse	r24, r1
    21c6:	30 c0       	rjmp	.+96     	; 0x2228 <xTaskResumeAll+0x8e>
    21c8:	5b c0       	rjmp	.+182    	; 0x2280 <xTaskResumeAll+0xe6>
    21ca:	d7 01       	movw	r26, r14
    21cc:	15 96       	adiw	r26, 0x05	; 5
    21ce:	ed 91       	ld	r30, X+
    21d0:	fc 91       	ld	r31, X
    21d2:	16 97       	sbiw	r26, 0x06	; 6
    21d4:	c6 81       	ldd	r28, Z+6	; 0x06
    21d6:	d7 81       	ldd	r29, Z+7	; 0x07
    21d8:	ce 01       	movw	r24, r28
    21da:	0c 96       	adiw	r24, 0x0c	; 12
    21dc:	60 d9       	rcall	.-3392   	; 0x149e <uxListRemove>
    21de:	8e 01       	movw	r16, r28
    21e0:	0e 5f       	subi	r16, 0xFE	; 254
    21e2:	1f 4f       	sbci	r17, 0xFF	; 255
    21e4:	c8 01       	movw	r24, r16
    21e6:	5b d9       	rcall	.-3402   	; 0x149e <uxListRemove>
    21e8:	8e 89       	ldd	r24, Y+22	; 0x16
    21ea:	90 91 ba 22 	lds	r25, 0x22BA	; 0x8022ba <uxTopReadyPriority>
    21ee:	98 17       	cp	r25, r24
    21f0:	10 f4       	brcc	.+4      	; 0x21f6 <xTaskResumeAll+0x5c>
    21f2:	80 93 ba 22 	sts	0x22BA, r24	; 0x8022ba <uxTopReadyPriority>
    21f6:	90 e0       	ldi	r25, 0x00	; 0
    21f8:	9c 01       	movw	r18, r24
    21fa:	22 0f       	add	r18, r18
    21fc:	33 1f       	adc	r19, r19
    21fe:	22 0f       	add	r18, r18
    2200:	33 1f       	adc	r19, r19
    2202:	22 0f       	add	r18, r18
    2204:	33 1f       	adc	r19, r19
    2206:	82 0f       	add	r24, r18
    2208:	93 1f       	adc	r25, r19
    220a:	b8 01       	movw	r22, r16
    220c:	83 52       	subi	r24, 0x23	; 35
    220e:	9d 4d       	sbci	r25, 0xDD	; 221
    2210:	f4 d8       	rcall	.-3608   	; 0x13fa <vListInsertEnd>
    2212:	e0 91 0a 23 	lds	r30, 0x230A	; 0x80230a <pxCurrentTCB>
    2216:	f0 91 0b 23 	lds	r31, 0x230B	; 0x80230b <pxCurrentTCB+0x1>
    221a:	9e 89       	ldd	r25, Y+22	; 0x16
    221c:	86 89       	ldd	r24, Z+22	; 0x16
    221e:	98 17       	cp	r25, r24
    2220:	58 f0       	brcs	.+22     	; 0x2238 <xTaskResumeAll+0x9e>
    2222:	d0 92 b7 22 	sts	0x22B7, r13	; 0x8022b7 <xYieldPending>
    2226:	08 c0       	rjmp	.+16     	; 0x2238 <xTaskResumeAll+0x9e>
    2228:	0f 2e       	mov	r0, r31
    222a:	fe eb       	ldi	r31, 0xBE	; 190
    222c:	ef 2e       	mov	r14, r31
    222e:	f2 e2       	ldi	r31, 0x22	; 34
    2230:	ff 2e       	mov	r15, r31
    2232:	f0 2d       	mov	r31, r0
    2234:	dd 24       	eor	r13, r13
    2236:	d3 94       	inc	r13
    2238:	f7 01       	movw	r30, r14
    223a:	80 81       	ld	r24, Z
    223c:	81 11       	cpse	r24, r1
    223e:	c5 cf       	rjmp	.-118    	; 0x21ca <xTaskResumeAll+0x30>
    2240:	80 91 b8 22 	lds	r24, 0x22B8	; 0x8022b8 <uxPendedTicks>
    2244:	88 23       	and	r24, r24
    2246:	91 f0       	breq	.+36     	; 0x226c <xTaskResumeAll+0xd2>
    2248:	80 91 b8 22 	lds	r24, 0x22B8	; 0x8022b8 <uxPendedTicks>
    224c:	88 23       	and	r24, r24
    224e:	71 f0       	breq	.+28     	; 0x226c <xTaskResumeAll+0xd2>
    2250:	c1 e0       	ldi	r28, 0x01	; 1
    2252:	d0 de       	rcall	.-608    	; 0x1ff4 <xTaskIncrementTick>
    2254:	81 11       	cpse	r24, r1
    2256:	c0 93 b7 22 	sts	0x22B7, r28	; 0x8022b7 <xYieldPending>
    225a:	80 91 b8 22 	lds	r24, 0x22B8	; 0x8022b8 <uxPendedTicks>
    225e:	81 50       	subi	r24, 0x01	; 1
    2260:	80 93 b8 22 	sts	0x22B8, r24	; 0x8022b8 <uxPendedTicks>
    2264:	80 91 b8 22 	lds	r24, 0x22B8	; 0x8022b8 <uxPendedTicks>
    2268:	81 11       	cpse	r24, r1
    226a:	f3 cf       	rjmp	.-26     	; 0x2252 <xTaskResumeAll+0xb8>
    226c:	80 91 b7 22 	lds	r24, 0x22B7	; 0x8022b7 <xYieldPending>
    2270:	81 30       	cpi	r24, 0x01	; 1
    2272:	29 f4       	brne	.+10     	; 0x227e <xTaskResumeAll+0xe4>
    2274:	f6 d9       	rcall	.-3092   	; 0x1662 <vPortYield>
    2276:	81 e0       	ldi	r24, 0x01	; 1
    2278:	03 c0       	rjmp	.+6      	; 0x2280 <xTaskResumeAll+0xe6>
    227a:	80 e0       	ldi	r24, 0x00	; 0
    227c:	01 c0       	rjmp	.+2      	; 0x2280 <xTaskResumeAll+0xe6>
    227e:	80 e0       	ldi	r24, 0x00	; 0
    2280:	0f 90       	pop	r0
    2282:	0f be       	out	0x3f, r0	; 63
    2284:	df 91       	pop	r29
    2286:	cf 91       	pop	r28
    2288:	1f 91       	pop	r17
    228a:	0f 91       	pop	r16
    228c:	ff 90       	pop	r15
    228e:	ef 90       	pop	r14
    2290:	df 90       	pop	r13
    2292:	08 95       	ret

00002294 <vTaskDelay>:
    2294:	cf 93       	push	r28
    2296:	df 93       	push	r29
    2298:	ec 01       	movw	r28, r24
    229a:	89 2b       	or	r24, r25
    229c:	91 f0       	breq	.+36     	; 0x22c2 <vTaskDelay+0x2e>
    229e:	9a de       	rcall	.-716    	; 0x1fd4 <vTaskSuspendAll>
    22a0:	80 91 bb 22 	lds	r24, 0x22BB	; 0x8022bb <xTickCount>
    22a4:	90 91 bc 22 	lds	r25, 0x22BC	; 0x8022bc <xTickCount+0x1>
    22a8:	c8 0f       	add	r28, r24
    22aa:	d9 1f       	adc	r29, r25
    22ac:	80 91 0a 23 	lds	r24, 0x230A	; 0x80230a <pxCurrentTCB>
    22b0:	90 91 0b 23 	lds	r25, 0x230B	; 0x80230b <pxCurrentTCB+0x1>
    22b4:	02 96       	adiw	r24, 0x02	; 2
    22b6:	f3 d8       	rcall	.-3610   	; 0x149e <uxListRemove>
    22b8:	ce 01       	movw	r24, r28
    22ba:	2a dd       	rcall	.-1452   	; 0x1d10 <prvAddCurrentTaskToDelayedList>
    22bc:	6e df       	rcall	.-292    	; 0x219a <xTaskResumeAll>
    22be:	81 11       	cpse	r24, r1
    22c0:	01 c0       	rjmp	.+2      	; 0x22c4 <vTaskDelay+0x30>
    22c2:	cf d9       	rcall	.-3170   	; 0x1662 <vPortYield>
    22c4:	df 91       	pop	r29
    22c6:	cf 91       	pop	r28
    22c8:	08 95       	ret

000022ca <vTaskSwitchContext>:
    22ca:	80 91 b4 22 	lds	r24, 0x22B4	; 0x8022b4 <uxSchedulerSuspended>
    22ce:	88 23       	and	r24, r24
    22d0:	21 f0       	breq	.+8      	; 0x22da <vTaskSwitchContext+0x10>
    22d2:	81 e0       	ldi	r24, 0x01	; 1
    22d4:	80 93 b7 22 	sts	0x22B7, r24	; 0x8022b7 <xYieldPending>
    22d8:	08 95       	ret
    22da:	10 92 b7 22 	sts	0x22B7, r1	; 0x8022b7 <xYieldPending>
    22de:	80 91 ba 22 	lds	r24, 0x22BA	; 0x8022ba <uxTopReadyPriority>
    22e2:	90 e0       	ldi	r25, 0x00	; 0
    22e4:	fc 01       	movw	r30, r24
    22e6:	ee 0f       	add	r30, r30
    22e8:	ff 1f       	adc	r31, r31
    22ea:	ee 0f       	add	r30, r30
    22ec:	ff 1f       	adc	r31, r31
    22ee:	ee 0f       	add	r30, r30
    22f0:	ff 1f       	adc	r31, r31
    22f2:	8e 0f       	add	r24, r30
    22f4:	9f 1f       	adc	r25, r31
    22f6:	fc 01       	movw	r30, r24
    22f8:	e3 52       	subi	r30, 0x23	; 35
    22fa:	fd 4d       	sbci	r31, 0xDD	; 221
    22fc:	80 81       	ld	r24, Z
    22fe:	81 11       	cpse	r24, r1
    2300:	17 c0       	rjmp	.+46     	; 0x2330 <vTaskSwitchContext+0x66>
    2302:	80 91 ba 22 	lds	r24, 0x22BA	; 0x8022ba <uxTopReadyPriority>
    2306:	81 50       	subi	r24, 0x01	; 1
    2308:	80 93 ba 22 	sts	0x22BA, r24	; 0x8022ba <uxTopReadyPriority>
    230c:	80 91 ba 22 	lds	r24, 0x22BA	; 0x8022ba <uxTopReadyPriority>
    2310:	90 e0       	ldi	r25, 0x00	; 0
    2312:	fc 01       	movw	r30, r24
    2314:	ee 0f       	add	r30, r30
    2316:	ff 1f       	adc	r31, r31
    2318:	ee 0f       	add	r30, r30
    231a:	ff 1f       	adc	r31, r31
    231c:	ee 0f       	add	r30, r30
    231e:	ff 1f       	adc	r31, r31
    2320:	8e 0f       	add	r24, r30
    2322:	9f 1f       	adc	r25, r31
    2324:	fc 01       	movw	r30, r24
    2326:	e3 52       	subi	r30, 0x23	; 35
    2328:	fd 4d       	sbci	r31, 0xDD	; 221
    232a:	80 81       	ld	r24, Z
    232c:	88 23       	and	r24, r24
    232e:	49 f3       	breq	.-46     	; 0x2302 <vTaskSwitchContext+0x38>
    2330:	80 91 ba 22 	lds	r24, 0x22BA	; 0x8022ba <uxTopReadyPriority>
    2334:	90 e0       	ldi	r25, 0x00	; 0
    2336:	9c 01       	movw	r18, r24
    2338:	22 0f       	add	r18, r18
    233a:	33 1f       	adc	r19, r19
    233c:	22 0f       	add	r18, r18
    233e:	33 1f       	adc	r19, r19
    2340:	22 0f       	add	r18, r18
    2342:	33 1f       	adc	r19, r19
    2344:	28 0f       	add	r18, r24
    2346:	39 1f       	adc	r19, r25
    2348:	d9 01       	movw	r26, r18
    234a:	a3 52       	subi	r26, 0x23	; 35
    234c:	bd 4d       	sbci	r27, 0xDD	; 221
    234e:	11 96       	adiw	r26, 0x01	; 1
    2350:	ed 91       	ld	r30, X+
    2352:	fc 91       	ld	r31, X
    2354:	12 97       	sbiw	r26, 0x02	; 2
    2356:	02 80       	ldd	r0, Z+2	; 0x02
    2358:	f3 81       	ldd	r31, Z+3	; 0x03
    235a:	e0 2d       	mov	r30, r0
    235c:	11 96       	adiw	r26, 0x01	; 1
    235e:	ed 93       	st	X+, r30
    2360:	fc 93       	st	X, r31
    2362:	12 97       	sbiw	r26, 0x02	; 2
    2364:	20 52       	subi	r18, 0x20	; 32
    2366:	3d 4d       	sbci	r19, 0xDD	; 221
    2368:	e2 17       	cp	r30, r18
    236a:	f3 07       	cpc	r31, r19
    236c:	29 f4       	brne	.+10     	; 0x2378 <vTaskSwitchContext+0xae>
    236e:	22 81       	ldd	r18, Z+2	; 0x02
    2370:	33 81       	ldd	r19, Z+3	; 0x03
    2372:	fd 01       	movw	r30, r26
    2374:	21 83       	std	Z+1, r18	; 0x01
    2376:	32 83       	std	Z+2, r19	; 0x02
    2378:	fc 01       	movw	r30, r24
    237a:	ee 0f       	add	r30, r30
    237c:	ff 1f       	adc	r31, r31
    237e:	ee 0f       	add	r30, r30
    2380:	ff 1f       	adc	r31, r31
    2382:	ee 0f       	add	r30, r30
    2384:	ff 1f       	adc	r31, r31
    2386:	8e 0f       	add	r24, r30
    2388:	9f 1f       	adc	r25, r31
    238a:	fc 01       	movw	r30, r24
    238c:	e3 52       	subi	r30, 0x23	; 35
    238e:	fd 4d       	sbci	r31, 0xDD	; 221
    2390:	01 80       	ldd	r0, Z+1	; 0x01
    2392:	f2 81       	ldd	r31, Z+2	; 0x02
    2394:	e0 2d       	mov	r30, r0
    2396:	86 81       	ldd	r24, Z+6	; 0x06
    2398:	97 81       	ldd	r25, Z+7	; 0x07
    239a:	80 93 0a 23 	sts	0x230A, r24	; 0x80230a <pxCurrentTCB>
    239e:	90 93 0b 23 	sts	0x230B, r25	; 0x80230b <pxCurrentTCB+0x1>
    23a2:	08 95       	ret

000023a4 <vTaskPlaceOnEventList>:
    23a4:	cf 93       	push	r28
    23a6:	df 93       	push	r29
    23a8:	eb 01       	movw	r28, r22
    23aa:	60 91 0a 23 	lds	r22, 0x230A	; 0x80230a <pxCurrentTCB>
    23ae:	70 91 0b 23 	lds	r23, 0x230B	; 0x80230b <pxCurrentTCB+0x1>
    23b2:	64 5f       	subi	r22, 0xF4	; 244
    23b4:	7f 4f       	sbci	r23, 0xFF	; 255
    23b6:	42 d8       	rcall	.-3964   	; 0x143c <vListInsert>
    23b8:	80 91 0a 23 	lds	r24, 0x230A	; 0x80230a <pxCurrentTCB>
    23bc:	90 91 0b 23 	lds	r25, 0x230B	; 0x80230b <pxCurrentTCB+0x1>
    23c0:	02 96       	adiw	r24, 0x02	; 2
    23c2:	6d d8       	rcall	.-3878   	; 0x149e <uxListRemove>
    23c4:	80 91 bb 22 	lds	r24, 0x22BB	; 0x8022bb <xTickCount>
    23c8:	90 91 bc 22 	lds	r25, 0x22BC	; 0x8022bc <xTickCount+0x1>
    23cc:	8c 0f       	add	r24, r28
    23ce:	9d 1f       	adc	r25, r29
    23d0:	9f dc       	rcall	.-1730   	; 0x1d10 <prvAddCurrentTaskToDelayedList>
    23d2:	df 91       	pop	r29
    23d4:	cf 91       	pop	r28
    23d6:	08 95       	ret

000023d8 <vTaskPlaceOnEventListRestricted>:
    23d8:	cf 93       	push	r28
    23da:	df 93       	push	r29
    23dc:	eb 01       	movw	r28, r22
    23de:	60 91 0a 23 	lds	r22, 0x230A	; 0x80230a <pxCurrentTCB>
    23e2:	70 91 0b 23 	lds	r23, 0x230B	; 0x80230b <pxCurrentTCB+0x1>
    23e6:	64 5f       	subi	r22, 0xF4	; 244
    23e8:	7f 4f       	sbci	r23, 0xFF	; 255
    23ea:	07 d8       	rcall	.-4082   	; 0x13fa <vListInsertEnd>
    23ec:	80 91 0a 23 	lds	r24, 0x230A	; 0x80230a <pxCurrentTCB>
    23f0:	90 91 0b 23 	lds	r25, 0x230B	; 0x80230b <pxCurrentTCB+0x1>
    23f4:	02 96       	adiw	r24, 0x02	; 2
    23f6:	53 d8       	rcall	.-3930   	; 0x149e <uxListRemove>
    23f8:	80 91 bb 22 	lds	r24, 0x22BB	; 0x8022bb <xTickCount>
    23fc:	90 91 bc 22 	lds	r25, 0x22BC	; 0x8022bc <xTickCount+0x1>
    2400:	8c 0f       	add	r24, r28
    2402:	9d 1f       	adc	r25, r29
    2404:	85 dc       	rcall	.-1782   	; 0x1d10 <prvAddCurrentTaskToDelayedList>
    2406:	df 91       	pop	r29
    2408:	cf 91       	pop	r28
    240a:	08 95       	ret

0000240c <xTaskRemoveFromEventList>:
    240c:	0f 93       	push	r16
    240e:	1f 93       	push	r17
    2410:	cf 93       	push	r28
    2412:	df 93       	push	r29
    2414:	dc 01       	movw	r26, r24
    2416:	15 96       	adiw	r26, 0x05	; 5
    2418:	ed 91       	ld	r30, X+
    241a:	fc 91       	ld	r31, X
    241c:	16 97       	sbiw	r26, 0x06	; 6
    241e:	c6 81       	ldd	r28, Z+6	; 0x06
    2420:	d7 81       	ldd	r29, Z+7	; 0x07
    2422:	8e 01       	movw	r16, r28
    2424:	04 5f       	subi	r16, 0xF4	; 244
    2426:	1f 4f       	sbci	r17, 0xFF	; 255
    2428:	c8 01       	movw	r24, r16
    242a:	39 d8       	rcall	.-3982   	; 0x149e <uxListRemove>
    242c:	80 91 b4 22 	lds	r24, 0x22B4	; 0x8022b4 <uxSchedulerSuspended>
    2430:	81 11       	cpse	r24, r1
    2432:	1b c0       	rjmp	.+54     	; 0x246a <xTaskRemoveFromEventList+0x5e>
    2434:	0a 50       	subi	r16, 0x0A	; 10
    2436:	11 09       	sbc	r17, r1
    2438:	c8 01       	movw	r24, r16
    243a:	31 d8       	rcall	.-3998   	; 0x149e <uxListRemove>
    243c:	8e 89       	ldd	r24, Y+22	; 0x16
    243e:	90 91 ba 22 	lds	r25, 0x22BA	; 0x8022ba <uxTopReadyPriority>
    2442:	98 17       	cp	r25, r24
    2444:	10 f4       	brcc	.+4      	; 0x244a <xTaskRemoveFromEventList+0x3e>
    2446:	80 93 ba 22 	sts	0x22BA, r24	; 0x8022ba <uxTopReadyPriority>
    244a:	90 e0       	ldi	r25, 0x00	; 0
    244c:	9c 01       	movw	r18, r24
    244e:	22 0f       	add	r18, r18
    2450:	33 1f       	adc	r19, r19
    2452:	22 0f       	add	r18, r18
    2454:	33 1f       	adc	r19, r19
    2456:	22 0f       	add	r18, r18
    2458:	33 1f       	adc	r19, r19
    245a:	82 0f       	add	r24, r18
    245c:	93 1f       	adc	r25, r19
    245e:	b8 01       	movw	r22, r16
    2460:	83 52       	subi	r24, 0x23	; 35
    2462:	9d 4d       	sbci	r25, 0xDD	; 221
    2464:	0e 94 fd 09 	call	0x13fa	; 0x13fa <vListInsertEnd>
    2468:	05 c0       	rjmp	.+10     	; 0x2474 <xTaskRemoveFromEventList+0x68>
    246a:	b8 01       	movw	r22, r16
    246c:	8e eb       	ldi	r24, 0xBE	; 190
    246e:	92 e2       	ldi	r25, 0x22	; 34
    2470:	0e 94 fd 09 	call	0x13fa	; 0x13fa <vListInsertEnd>
    2474:	e0 91 0a 23 	lds	r30, 0x230A	; 0x80230a <pxCurrentTCB>
    2478:	f0 91 0b 23 	lds	r31, 0x230B	; 0x80230b <pxCurrentTCB+0x1>
    247c:	9e 89       	ldd	r25, Y+22	; 0x16
    247e:	86 89       	ldd	r24, Z+22	; 0x16
    2480:	89 17       	cp	r24, r25
    2482:	20 f4       	brcc	.+8      	; 0x248c <xTaskRemoveFromEventList+0x80>
    2484:	81 e0       	ldi	r24, 0x01	; 1
    2486:	80 93 b7 22 	sts	0x22B7, r24	; 0x8022b7 <xYieldPending>
    248a:	01 c0       	rjmp	.+2      	; 0x248e <xTaskRemoveFromEventList+0x82>
    248c:	80 e0       	ldi	r24, 0x00	; 0
    248e:	df 91       	pop	r29
    2490:	cf 91       	pop	r28
    2492:	1f 91       	pop	r17
    2494:	0f 91       	pop	r16
    2496:	08 95       	ret

00002498 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2498:	20 91 b6 22 	lds	r18, 0x22B6	; 0x8022b6 <xNumOfOverflows>
    249c:	fc 01       	movw	r30, r24
    249e:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    24a0:	20 91 bb 22 	lds	r18, 0x22BB	; 0x8022bb <xTickCount>
    24a4:	30 91 bc 22 	lds	r19, 0x22BC	; 0x8022bc <xTickCount+0x1>
    24a8:	21 83       	std	Z+1, r18	; 0x01
    24aa:	32 83       	std	Z+2, r19	; 0x02
    24ac:	08 95       	ret

000024ae <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    24ae:	cf 93       	push	r28
    24b0:	df 93       	push	r29
    24b2:	fc 01       	movw	r30, r24
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    24b4:	0f b6       	in	r0, 0x3f	; 63
    24b6:	f8 94       	cli
    24b8:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    24ba:	20 91 bb 22 	lds	r18, 0x22BB	; 0x8022bb <xTickCount>
    24be:	30 91 bc 22 	lds	r19, 0x22BC	; 0x8022bc <xTickCount+0x1>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    24c2:	80 91 b6 22 	lds	r24, 0x22B6	; 0x8022b6 <xNumOfOverflows>
    24c6:	90 81       	ld	r25, Z
    24c8:	98 17       	cp	r25, r24
    24ca:	29 f0       	breq	.+10     	; 0x24d6 <xTaskCheckForTimeOut+0x28>
    24cc:	81 81       	ldd	r24, Z+1	; 0x01
    24ce:	92 81       	ldd	r25, Z+2	; 0x02
    24d0:	28 17       	cp	r18, r24
    24d2:	39 07       	cpc	r19, r25
    24d4:	a8 f4       	brcc	.+42     	; 0x2500 <xTaskCheckForTimeOut+0x52>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
    24d6:	a1 81       	ldd	r26, Z+1	; 0x01
    24d8:	b2 81       	ldd	r27, Z+2	; 0x02
    24da:	eb 01       	movw	r28, r22
    24dc:	48 81       	ld	r20, Y
    24de:	59 81       	ldd	r21, Y+1	; 0x01
    24e0:	c9 01       	movw	r24, r18
    24e2:	8a 1b       	sub	r24, r26
    24e4:	9b 0b       	sbc	r25, r27
    24e6:	84 17       	cp	r24, r20
    24e8:	95 07       	cpc	r25, r21
    24ea:	60 f4       	brcc	.+24     	; 0x2504 <xTaskCheckForTimeOut+0x56>
    24ec:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
    24ee:	a2 1b       	sub	r26, r18
    24f0:	b3 0b       	sbc	r27, r19
    24f2:	4a 0f       	add	r20, r26
    24f4:	5b 1f       	adc	r21, r27
    24f6:	48 83       	st	Y, r20
    24f8:	59 83       	std	Y+1, r21	; 0x01
			vTaskSetTimeOutState( pxTimeOut );
    24fa:	ce df       	rcall	.-100    	; 0x2498 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    24fc:	80 e0       	ldi	r24, 0x00	; 0
    24fe:	03 c0       	rjmp	.+6      	; 0x2506 <xTaskCheckForTimeOut+0x58>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    2500:	81 e0       	ldi	r24, 0x01	; 1
    2502:	01 c0       	rjmp	.+2      	; 0x2506 <xTaskCheckForTimeOut+0x58>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    2504:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    2506:	0f 90       	pop	r0
    2508:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    250a:	df 91       	pop	r29
    250c:	cf 91       	pop	r28
    250e:	08 95       	ret

00002510 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    2510:	81 e0       	ldi	r24, 0x01	; 1
    2512:	80 93 b7 22 	sts	0x22B7, r24	; 0x8022b7 <xYieldPending>
    2516:	08 95       	ret

00002518 <xTaskGetSchedulerState>:

	BaseType_t xTaskGetSchedulerState( void )
	{
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
    2518:	80 91 b9 22 	lds	r24, 0x22B9	; 0x8022b9 <xSchedulerRunning>
    251c:	88 23       	and	r24, r24
    251e:	31 f0       	breq	.+12     	; 0x252c <xTaskGetSchedulerState+0x14>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    2520:	80 91 b4 22 	lds	r24, 0x22B4	; 0x8022b4 <uxSchedulerSuspended>
    2524:	88 23       	and	r24, r24
    2526:	21 f0       	breq	.+8      	; 0x2530 <xTaskGetSchedulerState+0x18>
			{
				xReturn = taskSCHEDULER_RUNNING;
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
    2528:	80 e0       	ldi	r24, 0x00	; 0
    252a:	08 95       	ret
	{
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
    252c:	81 e0       	ldi	r24, 0x01	; 1
    252e:	08 95       	ret
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
			{
				xReturn = taskSCHEDULER_RUNNING;
    2530:	82 e0       	ldi	r24, 0x02	; 2
				xReturn = taskSCHEDULER_SUSPENDED;
			}
		}

		return xReturn;
	}
    2532:	08 95       	ret

00002534 <prvInsertTimerInActiveList>:

	/* 0 is not a valid value for xTimerPeriodInTicks. */
	configASSERT( ( xTimerPeriodInTicks > 0 ) );

	return ( TimerHandle_t ) pxNewTimer;
}
    2534:	fc 01       	movw	r30, r24
    2536:	62 83       	std	Z+2, r22	; 0x02
    2538:	73 83       	std	Z+3, r23	; 0x03
    253a:	80 87       	std	Z+8, r24	; 0x08
    253c:	91 87       	std	Z+9, r25	; 0x09
    253e:	46 17       	cp	r20, r22
    2540:	57 07       	cpc	r21, r23
    2542:	90 f0       	brcs	.+36     	; 0x2568 <prvInsertTimerInActiveList+0x34>
    2544:	42 1b       	sub	r20, r18
    2546:	53 0b       	sbc	r21, r19
    2548:	84 85       	ldd	r24, Z+12	; 0x0c
    254a:	95 85       	ldd	r25, Z+13	; 0x0d
    254c:	48 17       	cp	r20, r24
    254e:	59 07       	cpc	r21, r25
    2550:	e0 f4       	brcc	.+56     	; 0x258a <prvInsertTimerInActiveList+0x56>
    2552:	bf 01       	movw	r22, r30
    2554:	6e 5f       	subi	r22, 0xFE	; 254
    2556:	7f 4f       	sbci	r23, 0xFF	; 255
    2558:	80 91 10 23 	lds	r24, 0x2310	; 0x802310 <pxOverflowTimerList>
    255c:	90 91 11 23 	lds	r25, 0x2311	; 0x802311 <pxOverflowTimerList+0x1>
    2560:	0e 94 1e 0a 	call	0x143c	; 0x143c <vListInsert>
    2564:	80 e0       	ldi	r24, 0x00	; 0
    2566:	08 95       	ret
    2568:	42 17       	cp	r20, r18
    256a:	53 07       	cpc	r21, r19
    256c:	18 f4       	brcc	.+6      	; 0x2574 <prvInsertTimerInActiveList+0x40>
    256e:	62 17       	cp	r22, r18
    2570:	73 07       	cpc	r23, r19
    2572:	68 f4       	brcc	.+26     	; 0x258e <prvInsertTimerInActiveList+0x5a>
    2574:	bf 01       	movw	r22, r30
    2576:	6e 5f       	subi	r22, 0xFE	; 254
    2578:	7f 4f       	sbci	r23, 0xFF	; 255
    257a:	80 91 12 23 	lds	r24, 0x2312	; 0x802312 <pxCurrentTimerList>
    257e:	90 91 13 23 	lds	r25, 0x2313	; 0x802313 <pxCurrentTimerList+0x1>
    2582:	0e 94 1e 0a 	call	0x143c	; 0x143c <vListInsert>
    2586:	80 e0       	ldi	r24, 0x00	; 0
    2588:	08 95       	ret
    258a:	81 e0       	ldi	r24, 0x01	; 1
    258c:	08 95       	ret
    258e:	81 e0       	ldi	r24, 0x01	; 1
    2590:	08 95       	ret

00002592 <prvCheckForValidListAndQueue>:
    2592:	0f b6       	in	r0, 0x3f	; 63
    2594:	f8 94       	cli
    2596:	0f 92       	push	r0
    2598:	80 91 0e 23 	lds	r24, 0x230E	; 0x80230e <xTimerQueue>
    259c:	90 91 0f 23 	lds	r25, 0x230F	; 0x80230f <xTimerQueue+0x1>
    25a0:	89 2b       	or	r24, r25
    25a2:	e1 f4       	brne	.+56     	; 0x25dc <prvCheckForValidListAndQueue+0x4a>
    25a4:	8d e1       	ldi	r24, 0x1D	; 29
    25a6:	93 e2       	ldi	r25, 0x23	; 35
    25a8:	0e 94 eb 09 	call	0x13d6	; 0x13d6 <vListInitialise>
    25ac:	84 e1       	ldi	r24, 0x14	; 20
    25ae:	93 e2       	ldi	r25, 0x23	; 35
    25b0:	0e 94 eb 09 	call	0x13d6	; 0x13d6 <vListInitialise>
    25b4:	8d e1       	ldi	r24, 0x1D	; 29
    25b6:	93 e2       	ldi	r25, 0x23	; 35
    25b8:	80 93 12 23 	sts	0x2312, r24	; 0x802312 <pxCurrentTimerList>
    25bc:	90 93 13 23 	sts	0x2313, r25	; 0x802313 <pxCurrentTimerList+0x1>
    25c0:	84 e1       	ldi	r24, 0x14	; 20
    25c2:	93 e2       	ldi	r25, 0x23	; 35
    25c4:	80 93 10 23 	sts	0x2310, r24	; 0x802310 <pxOverflowTimerList>
    25c8:	90 93 11 23 	sts	0x2311, r25	; 0x802311 <pxOverflowTimerList+0x1>
    25cc:	40 e0       	ldi	r20, 0x00	; 0
    25ce:	65 e0       	ldi	r22, 0x05	; 5
    25d0:	8a e0       	ldi	r24, 0x0A	; 10
    25d2:	f9 d9       	rcall	.-3086   	; 0x19c6 <xQueueGenericCreate>
    25d4:	80 93 0e 23 	sts	0x230E, r24	; 0x80230e <xTimerQueue>
    25d8:	90 93 0f 23 	sts	0x230F, r25	; 0x80230f <xTimerQueue+0x1>
    25dc:	0f 90       	pop	r0
    25de:	0f be       	out	0x3f, r0	; 63
    25e0:	08 95       	ret

000025e2 <xTimerCreateTimerTask>:
    25e2:	af 92       	push	r10
    25e4:	bf 92       	push	r11
    25e6:	cf 92       	push	r12
    25e8:	df 92       	push	r13
    25ea:	ef 92       	push	r14
    25ec:	ff 92       	push	r15
    25ee:	0f 93       	push	r16
    25f0:	d0 df       	rcall	.-96     	; 0x2592 <prvCheckForValidListAndQueue>
    25f2:	80 91 0e 23 	lds	r24, 0x230E	; 0x80230e <xTimerQueue>
    25f6:	90 91 0f 23 	lds	r25, 0x230F	; 0x80230f <xTimerQueue+0x1>
    25fa:	89 2b       	or	r24, r25
    25fc:	89 f0       	breq	.+34     	; 0x2620 <xTimerCreateTimerTask+0x3e>
    25fe:	a1 2c       	mov	r10, r1
    2600:	b1 2c       	mov	r11, r1
    2602:	c1 2c       	mov	r12, r1
    2604:	d1 2c       	mov	r13, r1
    2606:	e1 2c       	mov	r14, r1
    2608:	f1 2c       	mov	r15, r1
    260a:	03 e0       	ldi	r16, 0x03	; 3
    260c:	20 e0       	ldi	r18, 0x00	; 0
    260e:	30 e0       	ldi	r19, 0x00	; 0
    2610:	45 e5       	ldi	r20, 0x55	; 85
    2612:	50 e0       	ldi	r21, 0x00	; 0
    2614:	64 e1       	ldi	r22, 0x14	; 20
    2616:	70 e2       	ldi	r23, 0x20	; 32
    2618:	89 ec       	ldi	r24, 0xC9	; 201
    261a:	93 e1       	ldi	r25, 0x13	; 19
    261c:	ae db       	rcall	.-2212   	; 0x1d7a <xTaskGenericCreate>
    261e:	01 c0       	rjmp	.+2      	; 0x2622 <xTimerCreateTimerTask+0x40>
    2620:	80 e0       	ldi	r24, 0x00	; 0
    2622:	0f 91       	pop	r16
    2624:	ff 90       	pop	r15
    2626:	ef 90       	pop	r14
    2628:	df 90       	pop	r13
    262a:	cf 90       	pop	r12
    262c:	bf 90       	pop	r11
    262e:	af 90       	pop	r10
    2630:	08 95       	ret

00002632 <xTimerGenericCommand>:
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
    2632:	0f 93       	push	r16
    2634:	1f 93       	push	r17
    2636:	cf 93       	push	r28
    2638:	df 93       	push	r29
    263a:	cd b7       	in	r28, 0x3d	; 61
    263c:	de b7       	in	r29, 0x3e	; 62
    263e:	25 97       	sbiw	r28, 0x05	; 5
    2640:	cd bf       	out	0x3d, r28	; 61
    2642:	de bf       	out	0x3e, r29	; 62
BaseType_t xReturn = pdFAIL;
DaemonTaskMessage_t xMessage;

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
    2644:	e0 91 0e 23 	lds	r30, 0x230E	; 0x80230e <xTimerQueue>
    2648:	f0 91 0f 23 	lds	r31, 0x230F	; 0x80230f <xTimerQueue+0x1>
    264c:	30 97       	sbiw	r30, 0x00	; 0
    264e:	51 f1       	breq	.+84     	; 0x26a4 <xTimerGenericCommand+0x72>
    2650:	d9 01       	movw	r26, r18
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
    2652:	69 83       	std	Y+1, r22	; 0x01
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    2654:	4a 83       	std	Y+2, r20	; 0x02
    2656:	5b 83       	std	Y+3, r21	; 0x03
		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
    2658:	8c 83       	std	Y+4, r24	; 0x04
    265a:	9d 83       	std	Y+5, r25	; 0x05

		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    265c:	66 30       	cpi	r22, 0x06	; 6
    265e:	d4 f4       	brge	.+52     	; 0x2694 <xTimerGenericCommand+0x62>
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    2660:	5b df       	rcall	.-330    	; 0x2518 <xTaskGetSchedulerState>
    2662:	82 30       	cpi	r24, 0x02	; 2
    2664:	59 f4       	brne	.+22     	; 0x267c <xTimerGenericCommand+0x4a>
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    2666:	20 e0       	ldi	r18, 0x00	; 0
    2668:	a8 01       	movw	r20, r16
    266a:	be 01       	movw	r22, r28
    266c:	6f 5f       	subi	r22, 0xFF	; 255
    266e:	7f 4f       	sbci	r23, 0xFF	; 255
    2670:	80 91 0e 23 	lds	r24, 0x230E	; 0x80230e <xTimerQueue>
    2674:	90 91 0f 23 	lds	r25, 0x230F	; 0x80230f <xTimerQueue+0x1>
    2678:	cf d9       	rcall	.-3170   	; 0x1a18 <xQueueGenericSend>
    267a:	15 c0       	rjmp	.+42     	; 0x26a6 <xTimerGenericCommand+0x74>
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    267c:	20 e0       	ldi	r18, 0x00	; 0
    267e:	40 e0       	ldi	r20, 0x00	; 0
    2680:	50 e0       	ldi	r21, 0x00	; 0
    2682:	be 01       	movw	r22, r28
    2684:	6f 5f       	subi	r22, 0xFF	; 255
    2686:	7f 4f       	sbci	r23, 0xFF	; 255
    2688:	80 91 0e 23 	lds	r24, 0x230E	; 0x80230e <xTimerQueue>
    268c:	90 91 0f 23 	lds	r25, 0x230F	; 0x80230f <xTimerQueue+0x1>
    2690:	c3 d9       	rcall	.-3194   	; 0x1a18 <xQueueGenericSend>
    2692:	09 c0       	rjmp	.+18     	; 0x26a6 <xTimerGenericCommand+0x74>
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    2694:	20 e0       	ldi	r18, 0x00	; 0
    2696:	ad 01       	movw	r20, r26
    2698:	be 01       	movw	r22, r28
    269a:	6f 5f       	subi	r22, 0xFF	; 255
    269c:	7f 4f       	sbci	r23, 0xFF	; 255
    269e:	cf 01       	movw	r24, r30
    26a0:	48 da       	rcall	.-2928   	; 0x1b32 <xQueueGenericSendFromISR>
    26a2:	01 c0       	rjmp	.+2      	; 0x26a6 <xTimerGenericCommand+0x74>
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
BaseType_t xReturn = pdFAIL;
    26a4:	80 e0       	ldi	r24, 0x00	; 0
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
}
    26a6:	25 96       	adiw	r28, 0x05	; 5
    26a8:	cd bf       	out	0x3d, r28	; 61
    26aa:	de bf       	out	0x3e, r29	; 62
    26ac:	df 91       	pop	r29
    26ae:	cf 91       	pop	r28
    26b0:	1f 91       	pop	r17
    26b2:	0f 91       	pop	r16
    26b4:	08 95       	ret

000026b6 <prvSampleTimeNow>:
	return xNextExpireTime;
}
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
    26b6:	af 92       	push	r10
    26b8:	bf 92       	push	r11
    26ba:	cf 92       	push	r12
    26bc:	df 92       	push	r13
    26be:	ef 92       	push	r14
    26c0:	ff 92       	push	r15
    26c2:	0f 93       	push	r16
    26c4:	1f 93       	push	r17
    26c6:	cf 93       	push	r28
    26c8:	df 93       	push	r29
    26ca:	6c 01       	movw	r12, r24
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
    26cc:	89 dc       	rcall	.-1774   	; 0x1fe0 <xTaskGetTickCount>
    26ce:	7c 01       	movw	r14, r24

	if( xTimeNow < xLastTime )
    26d0:	80 91 0c 23 	lds	r24, 0x230C	; 0x80230c <xLastTime.4450>
    26d4:	90 91 0d 23 	lds	r25, 0x230D	; 0x80230d <xLastTime.4450+0x1>
    26d8:	e8 16       	cp	r14, r24
    26da:	f9 06       	cpc	r15, r25
    26dc:	08 f0       	brcs	.+2      	; 0x26e0 <prvSampleTimeNow+0x2a>
    26de:	47 c0       	rjmp	.+142    	; 0x276e <prvSampleTimeNow+0xb8>
    26e0:	2f c0       	rjmp	.+94     	; 0x2740 <prvSampleTimeNow+0x8a>
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    26e2:	05 80       	ldd	r0, Z+5	; 0x05
    26e4:	f6 81       	ldd	r31, Z+6	; 0x06
    26e6:	e0 2d       	mov	r30, r0
    26e8:	a0 80       	ld	r10, Z
    26ea:	b1 80       	ldd	r11, Z+1	; 0x01

		/* Remove the timer from the list. */
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    26ec:	c6 81       	ldd	r28, Z+6	; 0x06
    26ee:	d7 81       	ldd	r29, Z+7	; 0x07
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    26f0:	8e 01       	movw	r16, r28
    26f2:	0e 5f       	subi	r16, 0xFE	; 254
    26f4:	1f 4f       	sbci	r17, 0xFF	; 255
    26f6:	c8 01       	movw	r24, r16
    26f8:	0e 94 4f 0a 	call	0x149e	; 0x149e <uxListRemove>
		traceTIMER_EXPIRED( pxTimer );

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    26fc:	e9 89       	ldd	r30, Y+17	; 0x11
    26fe:	fa 89       	ldd	r31, Y+18	; 0x12
    2700:	ce 01       	movw	r24, r28
    2702:	19 95       	eicall

		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    2704:	8e 85       	ldd	r24, Y+14	; 0x0e
    2706:	81 30       	cpi	r24, 0x01	; 1
    2708:	d9 f4       	brne	.+54     	; 0x2740 <prvSampleTimeNow+0x8a>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    270a:	8c 85       	ldd	r24, Y+12	; 0x0c
    270c:	9d 85       	ldd	r25, Y+13	; 0x0d
    270e:	8a 0d       	add	r24, r10
    2710:	9b 1d       	adc	r25, r11
			if( xReloadTime > xNextExpireTime )
    2712:	a8 16       	cp	r10, r24
    2714:	b9 06       	cpc	r11, r25
    2716:	60 f4       	brcc	.+24     	; 0x2730 <prvSampleTimeNow+0x7a>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    2718:	8a 83       	std	Y+2, r24	; 0x02
    271a:	9b 83       	std	Y+3, r25	; 0x03
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    271c:	c8 87       	std	Y+8, r28	; 0x08
    271e:	d9 87       	std	Y+9, r29	; 0x09
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    2720:	b8 01       	movw	r22, r16
    2722:	80 91 12 23 	lds	r24, 0x2312	; 0x802312 <pxCurrentTimerList>
    2726:	90 91 13 23 	lds	r25, 0x2313	; 0x802313 <pxCurrentTimerList+0x1>
    272a:	0e 94 1e 0a 	call	0x143c	; 0x143c <vListInsert>
    272e:	08 c0       	rjmp	.+16     	; 0x2740 <prvSampleTimeNow+0x8a>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    2730:	00 e0       	ldi	r16, 0x00	; 0
    2732:	10 e0       	ldi	r17, 0x00	; 0
    2734:	20 e0       	ldi	r18, 0x00	; 0
    2736:	30 e0       	ldi	r19, 0x00	; 0
    2738:	a5 01       	movw	r20, r10
    273a:	60 e0       	ldi	r22, 0x00	; 0
    273c:	ce 01       	movw	r24, r28
    273e:	79 df       	rcall	.-270    	; 0x2632 <xTimerGenericCommand>

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    2740:	e0 91 12 23 	lds	r30, 0x2312	; 0x802312 <pxCurrentTimerList>
    2744:	f0 91 13 23 	lds	r31, 0x2313	; 0x802313 <pxCurrentTimerList+0x1>
    2748:	80 81       	ld	r24, Z
    274a:	81 11       	cpse	r24, r1
    274c:	ca cf       	rjmp	.-108    	; 0x26e2 <prvSampleTimeNow+0x2c>
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxTemp = pxCurrentTimerList;
	pxCurrentTimerList = pxOverflowTimerList;
    274e:	80 91 10 23 	lds	r24, 0x2310	; 0x802310 <pxOverflowTimerList>
    2752:	90 91 11 23 	lds	r25, 0x2311	; 0x802311 <pxOverflowTimerList+0x1>
    2756:	80 93 12 23 	sts	0x2312, r24	; 0x802312 <pxCurrentTimerList>
    275a:	90 93 13 23 	sts	0x2313, r25	; 0x802313 <pxCurrentTimerList+0x1>
	pxOverflowTimerList = pxTemp;
    275e:	e0 93 10 23 	sts	0x2310, r30	; 0x802310 <pxOverflowTimerList>
    2762:	f0 93 11 23 	sts	0x2311, r31	; 0x802311 <pxOverflowTimerList+0x1>
	xTimeNow = xTaskGetTickCount();

	if( xTimeNow < xLastTime )
	{
		prvSwitchTimerLists();
		*pxTimerListsWereSwitched = pdTRUE;
    2766:	81 e0       	ldi	r24, 0x01	; 1
    2768:	f6 01       	movw	r30, r12
    276a:	80 83       	st	Z, r24
    276c:	02 c0       	rjmp	.+4      	; 0x2772 <prvSampleTimeNow+0xbc>
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
    276e:	f6 01       	movw	r30, r12
    2770:	10 82       	st	Z, r1
	}

	xLastTime = xTimeNow;
    2772:	e0 92 0c 23 	sts	0x230C, r14	; 0x80230c <xLastTime.4450>
    2776:	f0 92 0d 23 	sts	0x230D, r15	; 0x80230d <xLastTime.4450+0x1>

	return xTimeNow;
}
    277a:	c7 01       	movw	r24, r14
    277c:	df 91       	pop	r29
    277e:	cf 91       	pop	r28
    2780:	1f 91       	pop	r17
    2782:	0f 91       	pop	r16
    2784:	ff 90       	pop	r15
    2786:	ef 90       	pop	r14
    2788:	df 90       	pop	r13
    278a:	cf 90       	pop	r12
    278c:	bf 90       	pop	r11
    278e:	af 90       	pop	r10
    2790:	08 95       	ret

00002792 <prvTimerTask>:
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
}
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
    2792:	cf 93       	push	r28
    2794:	df 93       	push	r29
    2796:	00 d0       	rcall	.+0      	; 0x2798 <prvTimerTask+0x6>
    2798:	00 d0       	rcall	.+0      	; 0x279a <prvTimerTask+0x8>
    279a:	cd b7       	in	r28, 0x3d	; 61
    279c:	de b7       	in	r29, 0x3e	; 62
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    279e:	ce 01       	movw	r24, r28
    27a0:	01 96       	adiw	r24, 0x01	; 1
    27a2:	5c 01       	movw	r10, r24
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    27a4:	e8 2e       	mov	r14, r24
    27a6:	fb 2c       	mov	r15, r11
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    27a8:	e0 91 12 23 	lds	r30, 0x2312	; 0x802312 <pxCurrentTimerList>
    27ac:	f0 91 13 23 	lds	r31, 0x2313	; 0x802313 <pxCurrentTimerList+0x1>
	if( *pxListWasEmpty == pdFALSE )
    27b0:	80 81       	ld	r24, Z
    27b2:	88 23       	and	r24, r24
    27b4:	09 f4       	brne	.+2      	; 0x27b8 <prvTimerTask+0x26>
    27b6:	b7 c0       	rjmp	.+366    	; 0x2926 <prvTimerTask+0x194>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    27b8:	05 80       	ldd	r0, Z+5	; 0x05
    27ba:	f6 81       	ldd	r31, Z+6	; 0x06
    27bc:	e0 2d       	mov	r30, r0
    27be:	c0 80       	ld	r12, Z
    27c0:	d1 80       	ldd	r13, Z+1	; 0x01
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, const BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
    27c2:	08 dc       	rcall	.-2032   	; 0x1fd4 <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    27c4:	c5 01       	movw	r24, r10
    27c6:	77 df       	rcall	.-274    	; 0x26b6 <prvSampleTimeNow>
    27c8:	8c 01       	movw	r16, r24
		if( xTimerListsWereSwitched == pdFALSE )
    27ca:	89 81       	ldd	r24, Y+1	; 0x01
    27cc:	81 11       	cpse	r24, r1
    27ce:	43 c0       	rjmp	.+134    	; 0x2856 <prvTimerTask+0xc4>
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    27d0:	0c 15       	cp	r16, r12
    27d2:	1d 05       	cpc	r17, r13
			{
				( void ) xTaskResumeAll();
    27d4:	90 f1       	brcs	.+100    	; 0x283a <prvTimerTask+0xa8>
    27d6:	e1 dc       	rcall	.-1598   	; 0x219a <xTaskResumeAll>
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    27d8:	e0 91 12 23 	lds	r30, 0x2312	; 0x802312 <pxCurrentTimerList>
    27dc:	f0 91 13 23 	lds	r31, 0x2313	; 0x802313 <pxCurrentTimerList+0x1>
    27e0:	05 80       	ldd	r0, Z+5	; 0x05
    27e2:	f6 81       	ldd	r31, Z+6	; 0x06
    27e4:	e0 2d       	mov	r30, r0
    27e6:	86 80       	ldd	r8, Z+6	; 0x06
    27e8:	97 80       	ldd	r9, Z+7	; 0x07

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    27ea:	c4 01       	movw	r24, r8
    27ec:	02 96       	adiw	r24, 0x02	; 2
    27ee:	0e 94 4f 0a 	call	0x149e	; 0x149e <uxListRemove>
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    27f2:	d4 01       	movw	r26, r8
    27f4:	1e 96       	adiw	r26, 0x0e	; 14
    27f6:	8c 91       	ld	r24, X
    27f8:	1e 97       	sbiw	r26, 0x0e	; 14
    27fa:	81 30       	cpi	r24, 0x01	; 1
    27fc:	a1 f4       	brne	.+40     	; 0x2826 <prvTimerTask+0x94>
	{
		/* The timer is inserted into a list using a time relative to anything
		other than the current time.  It will therefore be inserted into the
		correct list relative to the time this task thinks it is now. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) == pdTRUE )
    27fe:	1c 96       	adiw	r26, 0x0c	; 12
    2800:	6d 91       	ld	r22, X+
    2802:	7c 91       	ld	r23, X
    2804:	1d 97       	sbiw	r26, 0x0d	; 13
    2806:	6c 0d       	add	r22, r12
    2808:	7d 1d       	adc	r23, r13
    280a:	96 01       	movw	r18, r12
    280c:	a8 01       	movw	r20, r16
    280e:	c4 01       	movw	r24, r8
    2810:	91 de       	rcall	.-734    	; 0x2534 <prvInsertTimerInActiveList>
    2812:	81 30       	cpi	r24, 0x01	; 1
    2814:	41 f4       	brne	.+16     	; 0x2826 <prvTimerTask+0x94>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    2816:	00 e0       	ldi	r16, 0x00	; 0
    2818:	10 e0       	ldi	r17, 0x00	; 0
    281a:	20 e0       	ldi	r18, 0x00	; 0
    281c:	30 e0       	ldi	r19, 0x00	; 0
    281e:	a6 01       	movw	r20, r12
    2820:	60 e0       	ldi	r22, 0x00	; 0
    2822:	c4 01       	movw	r24, r8
    2824:	06 df       	rcall	.-500    	; 0x2632 <xTimerGenericCommand>
	{
		mtCOVERAGE_TEST_MARKER();
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    2826:	d4 01       	movw	r26, r8
    2828:	51 96       	adiw	r26, 0x11	; 17
    282a:	ed 91       	ld	r30, X+
    282c:	fc 91       	ld	r31, X
    282e:	52 97       	sbiw	r26, 0x12	; 18
    2830:	c4 01       	movw	r24, r8
    2832:	19 95       	eicall
    2834:	6b c0       	rjmp	.+214    	; 0x290c <prvTimerTask+0x17a>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
    2836:	c1 2c       	mov	r12, r1
    2838:	d1 2c       	mov	r13, r1
				time has not been reached yet.  This task should therefore
				block to wait for the next expire time or a command to be
				received - whichever comes first.  The following line cannot
				be reached unless xNextExpireTime > xTimeNow, except in the
				case when the current timer list is empty. */
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ) );
    283a:	b6 01       	movw	r22, r12
    283c:	60 1b       	sub	r22, r16
    283e:	71 0b       	sbc	r23, r17
    2840:	80 91 0e 23 	lds	r24, 0x230E	; 0x80230e <xTimerQueue>
    2844:	90 91 0f 23 	lds	r25, 0x230F	; 0x80230f <xTimerQueue+0x1>

				if( xTaskResumeAll() == pdFALSE )
    2848:	41 da       	rcall	.-2942   	; 0x1ccc <vQueueWaitForMessageRestricted>
    284a:	a7 dc       	rcall	.-1714   	; 0x219a <xTaskResumeAll>
    284c:	81 11       	cpse	r24, r1
				{
					/* Yield to wait for either a command to arrive, or the
					block time to expire.  If a command arrived between the
					critical section being exited and this yield then the yield
					will not cause the task to block. */
					portYIELD_WITHIN_API();
    284e:	5e c0       	rjmp	.+188    	; 0x290c <prvTimerTask+0x17a>
    2850:	0e 94 31 0b 	call	0x1662	; 0x1662 <vPortYield>
				}
			}
		}
		else
		{
			( void ) xTaskResumeAll();
    2854:	5b c0       	rjmp	.+182    	; 0x290c <prvTimerTask+0x17a>
    2856:	a1 dc       	rcall	.-1726   	; 0x219a <xTaskResumeAll>
    2858:	59 c0       	rjmp	.+178    	; 0x290c <prvTimerTask+0x17a>
		}
		#endif /* INCLUDE_xTimerPendFunctionCall */

		/* Commands that are positive are timer commands rather than pended
		function calls. */
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    285a:	89 81       	ldd	r24, Y+1	; 0x01
    285c:	88 23       	and	r24, r24
    285e:	0c f4       	brge	.+2      	; 0x2862 <prvTimerTask+0xd0>
    2860:	55 c0       	rjmp	.+170    	; 0x290c <prvTimerTask+0x17a>
		{
			/* The messages uses the xTimerParameters member to work on a
			software timer. */
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
    2862:	cc 80       	ldd	r12, Y+4	; 0x04
    2864:	dd 80       	ldd	r13, Y+5	; 0x05

			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
    2866:	f6 01       	movw	r30, r12
    2868:	82 85       	ldd	r24, Z+10	; 0x0a
    286a:	93 85       	ldd	r25, Z+11	; 0x0b
    286c:	89 2b       	or	r24, r25
			{
				/* The timer is in a list, remove it. */
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    286e:	21 f0       	breq	.+8      	; 0x2878 <prvTimerTask+0xe6>
    2870:	c6 01       	movw	r24, r12
    2872:	02 96       	adiw	r24, 0x02	; 2
    2874:	0e 94 4f 0a 	call	0x149e	; 0x149e <uxListRemove>
			it must be present in the function call.  prvSampleTimeNow() must be
			called after the message is received from xTimerQueue so there is no
			possibility of a higher priority task adding a message to the message
			queue with a time that is ahead of the timer daemon task (because it
			pre-empted the timer daemon task after the xTimeNow value was set). */
			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    2878:	ce 01       	movw	r24, r28
    287a:	06 96       	adiw	r24, 0x06	; 6
    287c:	1c df       	rcall	.-456    	; 0x26b6 <prvSampleTimeNow>
    287e:	ac 01       	movw	r20, r24

			switch( xMessage.xMessageID )
    2880:	89 81       	ldd	r24, Y+1	; 0x01
    2882:	08 2e       	mov	r0, r24
    2884:	00 0c       	add	r0, r0
    2886:	99 0b       	sbc	r25, r25
    2888:	aa 0b       	sbc	r26, r26
    288a:	bb 0b       	sbc	r27, r27
    288c:	8a 30       	cpi	r24, 0x0A	; 10
    288e:	91 05       	cpc	r25, r1
    2890:	08 f0       	brcs	.+2      	; 0x2894 <prvTimerTask+0x102>
    2892:	3c c0       	rjmp	.+120    	; 0x290c <prvTimerTask+0x17a>
    2894:	fc 01       	movw	r30, r24
    2896:	88 27       	eor	r24, r24
    2898:	e2 50       	subi	r30, 0x02	; 2
    289a:	ff 4f       	sbci	r31, 0xFF	; 255
    289c:	8f 4f       	sbci	r24, 0xFF	; 255
    289e:	08 c3       	rjmp	.+1552   	; 0x2eb0 <__tablejump2__>
			    case tmrCOMMAND_START_FROM_ISR :
			    case tmrCOMMAND_RESET :
			    case tmrCOMMAND_RESET_FROM_ISR :
				case tmrCOMMAND_START_DONT_TRACE :
					/* Start or restart a timer. */
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) == pdTRUE )
    28a0:	2a 81       	ldd	r18, Y+2	; 0x02
    28a2:	3b 81       	ldd	r19, Y+3	; 0x03
    28a4:	d6 01       	movw	r26, r12
    28a6:	1c 96       	adiw	r26, 0x0c	; 12
    28a8:	6d 91       	ld	r22, X+
    28aa:	7c 91       	ld	r23, X
    28ac:	1d 97       	sbiw	r26, 0x0d	; 13
    28ae:	62 0f       	add	r22, r18
    28b0:	73 1f       	adc	r23, r19
    28b2:	c6 01       	movw	r24, r12
    28b4:	3f de       	rcall	.-898    	; 0x2534 <prvInsertTimerInActiveList>
    28b6:	81 30       	cpi	r24, 0x01	; 1
    28b8:	49 f5       	brne	.+82     	; 0x290c <prvTimerTask+0x17a>
					{
						/* The timer expired before it was added to the active
						timer list.  Process it now. */
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    28ba:	d6 01       	movw	r26, r12
    28bc:	51 96       	adiw	r26, 0x11	; 17
    28be:	ed 91       	ld	r30, X+
    28c0:	fc 91       	ld	r31, X
    28c2:	52 97       	sbiw	r26, 0x12	; 18
    28c4:	c6 01       	movw	r24, r12
    28c6:	19 95       	eicall
						traceTIMER_EXPIRED( pxTimer );

						if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    28c8:	f6 01       	movw	r30, r12
    28ca:	86 85       	ldd	r24, Z+14	; 0x0e
    28cc:	81 30       	cpi	r24, 0x01	; 1
    28ce:	f1 f4       	brne	.+60     	; 0x290c <prvTimerTask+0x17a>
						{
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    28d0:	4a 81       	ldd	r20, Y+2	; 0x02
    28d2:	5b 81       	ldd	r21, Y+3	; 0x03
    28d4:	84 85       	ldd	r24, Z+12	; 0x0c
    28d6:	95 85       	ldd	r25, Z+13	; 0x0d
    28d8:	48 0f       	add	r20, r24
    28da:	59 1f       	adc	r21, r25
    28dc:	00 e0       	ldi	r16, 0x00	; 0
    28de:	10 e0       	ldi	r17, 0x00	; 0
    28e0:	20 e0       	ldi	r18, 0x00	; 0
    28e2:	30 e0       	ldi	r19, 0x00	; 0
    28e4:	60 e0       	ldi	r22, 0x00	; 0
    28e6:	c6 01       	movw	r24, r12
    28e8:	a4 de       	rcall	.-696    	; 0x2632 <xTimerGenericCommand>
    28ea:	10 c0       	rjmp	.+32     	; 0x290c <prvTimerTask+0x17a>
					There is nothing to do here. */
					break;

				case tmrCOMMAND_CHANGE_PERIOD :
				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    28ec:	6a 81       	ldd	r22, Y+2	; 0x02
    28ee:	7b 81       	ldd	r23, Y+3	; 0x03
    28f0:	d6 01       	movw	r26, r12
    28f2:	1c 96       	adiw	r26, 0x0c	; 12
    28f4:	6d 93       	st	X+, r22
    28f6:	7c 93       	st	X, r23
    28f8:	1d 97       	sbiw	r26, 0x0d	; 13
					longer or shorter than the old one.  The command time is
					therefore set to the current time, and as the period cannot be
					zero the next expiry time can only be in the future, meaning
					(unlike for the xTimerStart() case above) there is no fail case
					that needs to be handled here. */
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    28fa:	64 0f       	add	r22, r20
    28fc:	75 1f       	adc	r23, r21
    28fe:	9a 01       	movw	r18, r20
    2900:	c6 01       	movw	r24, r12
    2902:	18 de       	rcall	.-976    	; 0x2534 <prvInsertTimerInActiveList>
    2904:	03 c0       	rjmp	.+6      	; 0x290c <prvTimerTask+0x17a>
					break;

				case tmrCOMMAND_DELETE :
					/* The timer has already been removed from the active list,
					just free up the memory. */
					vPortFree( pxTimer );
    2906:	c6 01       	movw	r24, r12
    2908:	0e 94 f0 0b 	call	0x17e0	; 0x17e0 <vPortFree>
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    290c:	20 e0       	ldi	r18, 0x00	; 0
    290e:	40 e0       	ldi	r20, 0x00	; 0
    2910:	50 e0       	ldi	r21, 0x00	; 0
    2912:	6e 2d       	mov	r22, r14
    2914:	7f 2d       	mov	r23, r15
    2916:	80 91 0e 23 	lds	r24, 0x230E	; 0x80230e <xTimerQueue>
    291a:	90 91 0f 23 	lds	r25, 0x230F	; 0x80230f <xTimerQueue+0x1>
    291e:	3f d9       	rcall	.-3458   	; 0x1b9e <xQueueGenericReceive>
    2920:	81 11       	cpse	r24, r1
    2922:	9b cf       	rjmp	.-202    	; 0x285a <prvTimerTask+0xc8>
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, const BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
    2924:	41 cf       	rjmp	.-382    	; 0x27a8 <prvTimerTask+0x16>
    2926:	56 db       	rcall	.-2388   	; 0x1fd4 <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    2928:	c5 01       	movw	r24, r10
    292a:	c5 de       	rcall	.-630    	; 0x26b6 <prvSampleTimeNow>
    292c:	8c 01       	movw	r16, r24
    292e:	89 81       	ldd	r24, Y+1	; 0x01
		if( xTimerListsWereSwitched == pdFALSE )
    2930:	88 23       	and	r24, r24
    2932:	09 f4       	brne	.+2      	; 0x2936 <prvTimerTask+0x1a4>
    2934:	80 cf       	rjmp	.-256    	; 0x2836 <prvTimerTask+0xa4>
    2936:	8f cf       	rjmp	.-226    	; 0x2856 <prvTimerTask+0xc4>

00002938 <__portable_avr_delay_cycles>:
    2938:	04 c0       	rjmp	.+8      	; 0x2942 <__portable_avr_delay_cycles+0xa>

void sendString(char *text) {
    while (*text) {
        sendChar(*text++);
    }
}
    293a:	61 50       	subi	r22, 0x01	; 1
    293c:	71 09       	sbc	r23, r1
    293e:	81 09       	sbc	r24, r1
    2940:	91 09       	sbc	r25, r1
    2942:	61 15       	cp	r22, r1
    2944:	71 05       	cpc	r23, r1
    2946:	81 05       	cpc	r24, r1
    2948:	91 05       	cpc	r25, r1
    294a:	b9 f7       	brne	.-18     	; 0x293a <__portable_avr_delay_cycles+0x2>
    294c:	08 95       	ret

0000294e <vDisplayStatus>:
    294e:	0e 94 ff 04 	call	0x9fe	; 0x9fe <gfx_mono_st7565r_init>
    2952:	80 e1       	ldi	r24, 0x10	; 16
    2954:	80 93 85 06 	sts	0x0685, r24	; 0x800685 <__TEXT_REGION_LENGTH__+0x700685>
    2958:	0f 2e       	mov	r0, r31
    295a:	ff e3       	ldi	r31, 0x3F	; 63
    295c:	ef 2e       	mov	r14, r31
    295e:	f0 e2       	ldi	r31, 0x20	; 32
    2960:	ff 2e       	mov	r15, r31
    2962:	f0 2d       	mov	r31, r0
    2964:	68 94       	set
    2966:	55 24       	eor	r5, r5
    2968:	57 f8       	bld	r5, 7
    296a:	cc e2       	ldi	r28, 0x2C	; 44
    296c:	d3 e2       	ldi	r29, 0x23	; 35
    296e:	09 e4       	ldi	r16, 0x49	; 73
    2970:	10 e2       	ldi	r17, 0x20	; 32
    2972:	0f 2e       	mov	r0, r31
    2974:	fb e2       	ldi	r31, 0x2B	; 43
    2976:	8f 2e       	mov	r8, r31
    2978:	f0 e2       	ldi	r31, 0x20	; 32
    297a:	9f 2e       	mov	r9, r31
    297c:	f0 2d       	mov	r31, r0
    297e:	0f 2e       	mov	r0, r31
    2980:	f0 e3       	ldi	r31, 0x30	; 48
    2982:	af 2e       	mov	r10, r31
    2984:	f0 e2       	ldi	r31, 0x20	; 32
    2986:	bf 2e       	mov	r11, r31
    2988:	f0 2d       	mov	r31, r0
    298a:	0f 2e       	mov	r0, r31
    298c:	fc e1       	ldi	r31, 0x1C	; 28
    298e:	cf 2e       	mov	r12, r31
    2990:	f0 e2       	ldi	r31, 0x20	; 32
    2992:	df 2e       	mov	r13, r31
    2994:	f0 2d       	mov	r31, r0
    2996:	0f 2e       	mov	r0, r31
    2998:	f2 e2       	ldi	r31, 0x22	; 34
    299a:	6f 2e       	mov	r6, r31
    299c:	f0 e2       	ldi	r31, 0x20	; 32
    299e:	7f 2e       	mov	r7, r31
    29a0:	f0 2d       	mov	r31, r0
    29a2:	20 e0       	ldi	r18, 0x00	; 0
    29a4:	4f ef       	ldi	r20, 0xFF	; 255
    29a6:	5f ef       	ldi	r21, 0xFF	; 255
    29a8:	60 e0       	ldi	r22, 0x00	; 0
    29aa:	70 e0       	ldi	r23, 0x00	; 0
    29ac:	80 91 ae 23 	lds	r24, 0x23AE	; 0x8023ae <xSemaphoreSystem>
    29b0:	90 91 af 23 	lds	r25, 0x23AF	; 0x8023af <xSemaphoreSystem+0x1>
    29b4:	f4 d8       	rcall	.-3608   	; 0x1b9e <xQueueGenericReceive>
    29b6:	81 30       	cpi	r24, 0x01	; 1
    29b8:	09 f0       	breq	.+2      	; 0x29bc <vDisplayStatus+0x6e>
    29ba:	49 c0       	rjmp	.+146    	; 0x2a4e <vDisplayStatus+0x100>
    29bc:	26 e0       	ldi	r18, 0x06	; 6
    29be:	30 e2       	ldi	r19, 0x20	; 32
    29c0:	48 e0       	ldi	r20, 0x08	; 8
    29c2:	60 e0       	ldi	r22, 0x00	; 0
    29c4:	86 e3       	ldi	r24, 0x36	; 54
    29c6:	90 e2       	ldi	r25, 0x20	; 32
    29c8:	0e 94 73 06 	call	0xce6	; 0xce6 <gfx_mono_draw_string>
    29cc:	80 91 2b 23 	lds	r24, 0x232B	; 0x80232b <system_active>
    29d0:	81 11       	cpse	r24, r1
    29d2:	03 c0       	rjmp	.+6      	; 0x29da <vDisplayStatus+0x8c>
    29d4:	86 2d       	mov	r24, r6
    29d6:	97 2d       	mov	r25, r7
    29d8:	02 c0       	rjmp	.+4      	; 0x29de <vDisplayStatus+0x90>
    29da:	8c 2d       	mov	r24, r12
    29dc:	9d 2d       	mov	r25, r13
    29de:	26 e0       	ldi	r18, 0x06	; 6
    29e0:	30 e2       	ldi	r19, 0x20	; 32
    29e2:	48 e0       	ldi	r20, 0x08	; 8
    29e4:	62 e3       	ldi	r22, 0x32	; 50
    29e6:	0e 94 73 06 	call	0xce6	; 0xce6 <gfx_mono_draw_string>
    29ea:	80 91 2a 23 	lds	r24, 0x232A	; 0x80232a <door_open>
    29ee:	81 11       	cpse	r24, r1
    29f0:	03 c0       	rjmp	.+6      	; 0x29f8 <vDisplayStatus+0xaa>
    29f2:	8a 2d       	mov	r24, r10
    29f4:	9b 2d       	mov	r25, r11
    29f6:	02 c0       	rjmp	.+4      	; 0x29fc <vDisplayStatus+0xae>
    29f8:	88 2d       	mov	r24, r8
    29fa:	99 2d       	mov	r25, r9
    29fc:	9f 93       	push	r25
    29fe:	8f 93       	push	r24
    2a00:	ff 92       	push	r15
    2a02:	ef 92       	push	r14
    2a04:	1f 92       	push	r1
    2a06:	5f 92       	push	r5
    2a08:	df 93       	push	r29
    2a0a:	cf 93       	push	r28
    2a0c:	9d d3       	rcall	.+1850   	; 0x3148 <snprintf>
    2a0e:	26 e0       	ldi	r18, 0x06	; 6
    2a10:	30 e2       	ldi	r19, 0x20	; 32
    2a12:	40 e1       	ldi	r20, 0x10	; 16
    2a14:	60 e0       	ldi	r22, 0x00	; 0
    2a16:	ce 01       	movw	r24, r28
    2a18:	0e 94 73 06 	call	0xce6	; 0xce6 <gfx_mono_draw_string>
    2a1c:	80 91 27 23 	lds	r24, 0x2327	; 0x802327 <counter>
    2a20:	90 91 28 23 	lds	r25, 0x2328	; 0x802328 <counter+0x1>
    2a24:	9f 93       	push	r25
    2a26:	8f 93       	push	r24
    2a28:	1f 93       	push	r17
    2a2a:	0f 93       	push	r16
    2a2c:	1f 92       	push	r1
    2a2e:	5f 92       	push	r5
    2a30:	df 93       	push	r29
    2a32:	cf 93       	push	r28
    2a34:	89 d3       	rcall	.+1810   	; 0x3148 <snprintf>
    2a36:	26 e0       	ldi	r18, 0x06	; 6
    2a38:	30 e2       	ldi	r19, 0x20	; 32
    2a3a:	48 e1       	ldi	r20, 0x18	; 24
    2a3c:	60 e0       	ldi	r22, 0x00	; 0
    2a3e:	ce 01       	movw	r24, r28
    2a40:	0e 94 73 06 	call	0xce6	; 0xce6 <gfx_mono_draw_string>
    2a44:	8d b7       	in	r24, 0x3d	; 61
    2a46:	9e b7       	in	r25, 0x3e	; 62
    2a48:	40 96       	adiw	r24, 0x10	; 16
    2a4a:	8d bf       	out	0x3d, r24	; 61
    2a4c:	9e bf       	out	0x3e, r25	; 62
    2a4e:	82 e3       	ldi	r24, 0x32	; 50
    2a50:	90 e0       	ldi	r25, 0x00	; 0
    2a52:	20 dc       	rcall	.-1984   	; 0x2294 <vTaskDelay>
    2a54:	a6 cf       	rjmp	.-180    	; 0x29a2 <vDisplayStatus+0x54>

00002a56 <vServoControl>:
    2a56:	c0 e0       	ldi	r28, 0x00	; 0
    2a58:	d8 e0       	ldi	r29, 0x08	; 8
    2a5a:	0f 2e       	mov	r0, r31
    2a5c:	f5 e4       	ldi	r31, 0x45	; 69
    2a5e:	ef 2e       	mov	r14, r31
    2a60:	ff 24       	eor	r15, r15
    2a62:	f3 94       	inc	r15
    2a64:	f0 2d       	mov	r31, r0
    2a66:	0b e4       	ldi	r16, 0x4B	; 75
    2a68:	10 e0       	ldi	r17, 0x00	; 0
    2a6a:	80 91 26 23 	lds	r24, 0x2326	; 0x802326 <access_granted>
    2a6e:	88 23       	and	r24, r24
    2a70:	69 f0       	breq	.+26     	; 0x2a8c <vServoControl+0x36>
    2a72:	e8 a6       	std	Y+40, r14	; 0x28
    2a74:	f9 a6       	std	Y+41, r15	; 0x29
    2a76:	8c ed       	ldi	r24, 0xDC	; 220
    2a78:	95 e0       	ldi	r25, 0x05	; 5
    2a7a:	0c dc       	rcall	.-2024   	; 0x2294 <vTaskDelay>
    2a7c:	08 a7       	std	Y+40, r16	; 0x28
    2a7e:	19 a7       	std	Y+41, r17	; 0x29
    2a80:	10 92 26 23 	sts	0x2326, r1	; 0x802326 <access_granted>
    2a84:	10 92 27 23 	sts	0x2327, r1	; 0x802327 <counter>
    2a88:	10 92 28 23 	sts	0x2328, r1	; 0x802328 <counter+0x1>
    2a8c:	82 e3       	ldi	r24, 0x32	; 50
    2a8e:	90 e0       	ldi	r25, 0x00	; 0
    2a90:	01 dc       	rcall	.-2046   	; 0x2294 <vTaskDelay>
    2a92:	eb cf       	rjmp	.-42     	; 0x2a6a <vServoControl+0x14>

00002a94 <setUpSerial>:
    2a94:	10 92 a7 08 	sts	0x08A7, r1	; 0x8008a7 <__TEXT_REGION_LENGTH__+0x7008a7>
    2a98:	8c e0       	ldi	r24, 0x0C	; 12
    2a9a:	80 93 a6 08 	sts	0x08A6, r24	; 0x8008a6 <__TEXT_REGION_LENGTH__+0x7008a6>
    2a9e:	10 92 a3 08 	sts	0x08A3, r1	; 0x8008a3 <__TEXT_REGION_LENGTH__+0x7008a3>
    2aa2:	83 e0       	ldi	r24, 0x03	; 3
    2aa4:	80 93 a5 08 	sts	0x08A5, r24	; 0x8008a5 <__TEXT_REGION_LENGTH__+0x7008a5>
    2aa8:	88 e1       	ldi	r24, 0x18	; 24
    2aaa:	80 93 a4 08 	sts	0x08A4, r24	; 0x8008a4 <__TEXT_REGION_LENGTH__+0x7008a4>
    2aae:	08 95       	ret

00002ab0 <receiveChar>:

char receiveChar() {
    while (!(USARTC0_STATUS & USART_RXCIF_bm)); // Wait until receive finish
    2ab0:	e1 ea       	ldi	r30, 0xA1	; 161
    2ab2:	f8 e0       	ldi	r31, 0x08	; 8
    2ab4:	80 81       	ld	r24, Z
    2ab6:	88 23       	and	r24, r24
    2ab8:	ec f7       	brge	.-6      	; 0x2ab4 <receiveChar+0x4>
    delay_ms(20); 
    2aba:	6b e0       	ldi	r22, 0x0B	; 11
    2abc:	7a e1       	ldi	r23, 0x1A	; 26
    2abe:	80 e0       	ldi	r24, 0x00	; 0
    2ac0:	90 e0       	ldi	r25, 0x00	; 0
    2ac2:	3a df       	rcall	.-396    	; 0x2938 <__portable_avr_delay_cycles>
    return USARTC0_DATA;
    2ac4:	80 91 a0 08 	lds	r24, 0x08A0	; 0x8008a0 <__TEXT_REGION_LENGTH__+0x7008a0>
}
    2ac8:	08 95       	ret

00002aca <receiveString>:

void receiveString(char *reads, int maxSize) {
    2aca:	cf 92       	push	r12
    2acc:	df 92       	push	r13
    2ace:	ef 92       	push	r14
    2ad0:	ff 92       	push	r15
    2ad2:	0f 93       	push	r16
    2ad4:	1f 93       	push	r17
    2ad6:	cf 93       	push	r28
    2ad8:	df 93       	push	r29
    2ada:	6c 01       	movw	r12, r24
    2adc:	8c 01       	movw	r16, r24
    int i = 0;
    2ade:	c0 e0       	ldi	r28, 0x00	; 0
    2ae0:	d0 e0       	ldi	r29, 0x00	; 0
    while (1) {
        char inp = receiveChar();
        if (inp == '\n' || i >= maxSize - 1) {
    2ae2:	7b 01       	movw	r14, r22
    2ae4:	81 e0       	ldi	r24, 0x01	; 1
    2ae6:	e8 1a       	sub	r14, r24
    2ae8:	f1 08       	sbc	r15, r1
}

void receiveString(char *reads, int maxSize) {
    int i = 0;
    while (1) {
        char inp = receiveChar();
    2aea:	e2 df       	rcall	.-60     	; 0x2ab0 <receiveChar>
        if (inp == '\n' || i >= maxSize - 1) {
    2aec:	8a 30       	cpi	r24, 0x0A	; 10
    2aee:	19 f0       	breq	.+6      	; 0x2af6 <receiveString+0x2c>
    2af0:	ce 15       	cp	r28, r14
    2af2:	df 05       	cpc	r29, r15
    2af4:	24 f0       	brlt	.+8      	; 0x2afe <receiveString+0x34>
            reads[i] = '\0'; // Null terminate the string
    2af6:	cc 0d       	add	r28, r12
    2af8:	dd 1d       	adc	r29, r13
    2afa:	18 82       	st	Y, r1
            break;
        } else {
            reads[i++] = inp;
        }
    }
}
    2afc:	05 c0       	rjmp	.+10     	; 0x2b08 <receiveString+0x3e>
        char inp = receiveChar();
        if (inp == '\n' || i >= maxSize - 1) {
            reads[i] = '\0'; // Null terminate the string
            break;
        } else {
            reads[i++] = inp;
    2afe:	21 96       	adiw	r28, 0x01	; 1
    2b00:	f8 01       	movw	r30, r16
    2b02:	81 93       	st	Z+, r24
    2b04:	8f 01       	movw	r16, r30
        }
    }
    2b06:	f1 cf       	rjmp	.-30     	; 0x2aea <receiveString+0x20>
}
    2b08:	df 91       	pop	r29
    2b0a:	cf 91       	pop	r28
    2b0c:	1f 91       	pop	r17
    2b0e:	0f 91       	pop	r16
    2b10:	ff 90       	pop	r15
    2b12:	ef 90       	pop	r14
    2b14:	df 90       	pop	r13
    2b16:	cf 90       	pop	r12
    2b18:	08 95       	ret

00002b1a <PWM_Init>:
/* PWM Initialization for Servo and Buzzer                             */
/************************************************************************/
void PWM_Init(void)
{
    /* PWM for Servo - TCC0 Channel A */
    PORTC.DIR |= PIN0_bm; // Set PORTC PIN0 as output for Servo
    2b1a:	e0 e4       	ldi	r30, 0x40	; 64
    2b1c:	f6 e0       	ldi	r31, 0x06	; 6
    2b1e:	80 81       	ld	r24, Z
    2b20:	81 60       	ori	r24, 0x01	; 1
    2b22:	80 83       	st	Z, r24
    TCC0.CTRLA = TC_CLKSEL_DIV8_gc;
    2b24:	e0 e0       	ldi	r30, 0x00	; 0
    2b26:	f8 e0       	ldi	r31, 0x08	; 8
    2b28:	24 e0       	ldi	r18, 0x04	; 4
    2b2a:	20 83       	st	Z, r18
    TCC0.CTRLB = TC_WGMODE_SINGLESLOPE_gc | TC0_CCAEN_bm;
    2b2c:	93 e1       	ldi	r25, 0x13	; 19
    2b2e:	91 83       	std	Z+1, r25	; 0x01
    TCC0.PER = 5000; // 20ms period (50Hz)
    2b30:	48 e8       	ldi	r20, 0x88	; 136
    2b32:	53 e1       	ldi	r21, 0x13	; 19
    2b34:	46 a3       	std	Z+38, r20	; 0x26
    2b36:	57 a3       	std	Z+39, r21	; 0x27
    TCC0.CCA = 75;  // Initial duty cycle for 0 degrees
    2b38:	4b e4       	ldi	r20, 0x4B	; 75
    2b3a:	50 e0       	ldi	r21, 0x00	; 0
    2b3c:	40 a7       	std	Z+40, r20	; 0x28
    2b3e:	51 a7       	std	Z+41, r21	; 0x29

    /* PWM for Buzzer - TCC1 Channel A */
    PORTD.DIR |= PIN0_bm; // Set PORTD PIN0 as output for Buzzer
    2b40:	e0 e6       	ldi	r30, 0x60	; 96
    2b42:	f6 e0       	ldi	r31, 0x06	; 6
    2b44:	80 81       	ld	r24, Z
    2b46:	81 60       	ori	r24, 0x01	; 1
    2b48:	80 83       	st	Z, r24
    TCD0.CTRLA = TC_CLKSEL_DIV8_gc;
    2b4a:	e0 e0       	ldi	r30, 0x00	; 0
    2b4c:	f9 e0       	ldi	r31, 0x09	; 9
    2b4e:	20 83       	st	Z, r18
    TCD0.CTRLB = TC_WGMODE_SINGLESLOPE_gc | TC0_CCAEN_bm;
    2b50:	91 83       	std	Z+1, r25	; 0x01
    TCD0.PER = 1000; // Set period for Buzzer frequency
    2b52:	88 ee       	ldi	r24, 0xE8	; 232
    2b54:	93 e0       	ldi	r25, 0x03	; 3
    2b56:	86 a3       	std	Z+38, r24	; 0x26
    2b58:	97 a3       	std	Z+39, r25	; 0x27
    TCD0.CCA = 0;    // Start with buzzer off
    2b5a:	10 a6       	std	Z+40, r1	; 0x28
    2b5c:	11 a6       	std	Z+41, r1	; 0x29
    2b5e:	08 95       	ret

00002b60 <reset_actuators>:
/* Resets all actuators (buzzer & LED) and counter                      */
/************************************************************************/
void reset_actuators(void)
{
    // Turn off the buzzer
    TCD0.CCA = 0;
    2b60:	10 92 28 09 	sts	0x0928, r1	; 0x800928 <__TEXT_REGION_LENGTH__+0x700928>
    2b64:	10 92 29 09 	sts	0x0929, r1	; 0x800929 <__TEXT_REGION_LENGTH__+0x700929>
    // Reset servo to 0 degrees
    TCC0.CCA = 75;
    2b68:	8b e4       	ldi	r24, 0x4B	; 75
    2b6a:	90 e0       	ldi	r25, 0x00	; 0
    2b6c:	80 93 28 08 	sts	0x0828, r24	; 0x800828 <__TEXT_REGION_LENGTH__+0x700828>
    2b70:	90 93 29 08 	sts	0x0829, r25	; 0x800829 <__TEXT_REGION_LENGTH__+0x700829>
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
    2b74:	e0 ee       	ldi	r30, 0xE0	; 224
    2b76:	f7 e0       	ldi	r31, 0x07	; 7
    2b78:	81 e0       	ldi	r24, 0x01	; 1
    2b7a:	85 83       	std	Z+5, r24	; 0x05
    2b7c:	82 e0       	ldi	r24, 0x02	; 2
    2b7e:	85 83       	std	Z+5, r24	; 0x05
    // Turn off LED
    LED_Off(LED0);
    LED_Off(LED1);
    // Reset counter
    counter = 0;
    2b80:	10 92 27 23 	sts	0x2327, r1	; 0x802327 <counter>
    2b84:	10 92 28 23 	sts	0x2328, r1	; 0x802328 <counter+0x1>
    2b88:	08 95       	ret

00002b8a <vUARTTask>:
}

/************************************************************************/
/* UART Task: Receive RFID Logs and Status                              */
/************************************************************************/
static portTASK_FUNCTION(vUARTTask, pvParameters) {
    2b8a:	cf 93       	push	r28
    2b8c:	df 93       	push	r29
    2b8e:	cd b7       	in	r28, 0x3d	; 61
    2b90:	de b7       	in	r29, 0x3e	; 62
    2b92:	c0 58       	subi	r28, 0x80	; 128
    2b94:	d1 09       	sbc	r29, r1
    2b96:	cd bf       	out	0x3d, r28	; 61
    2b98:	de bf       	out	0x3e, r29	; 62
    char logBuffer[128];
    while (1) {
        memset(logBuffer, 0, sizeof(logBuffer));
    2b9a:	68 94       	set
    2b9c:	ff 24       	eor	r15, r15
    2b9e:	f7 f8       	bld	r15, 7
    2ba0:	8e 01       	movw	r16, r28
    2ba2:	0f 5f       	subi	r16, 0xFF	; 255
    2ba4:	1f 4f       	sbci	r17, 0xFF	; 255
        receiveString(logBuffer, sizeof(logBuffer));

        // Parse the log message
        if (strstr(logBuffer, "ACCESS: TRUE")) {
            access_granted = true;
    2ba6:	ee 24       	eor	r14, r14
    2ba8:	e3 94       	inc	r14
/* UART Task: Receive RFID Logs and Status                              */
/************************************************************************/
static portTASK_FUNCTION(vUARTTask, pvParameters) {
    char logBuffer[128];
    while (1) {
        memset(logBuffer, 0, sizeof(logBuffer));
    2baa:	f8 01       	movw	r30, r16
    2bac:	8f 2d       	mov	r24, r15
    2bae:	11 92       	st	Z+, r1
    2bb0:	8a 95       	dec	r24
    2bb2:	e9 f7       	brne	.-6      	; 0x2bae <vUARTTask+0x24>
        receiveString(logBuffer, sizeof(logBuffer));
    2bb4:	60 e8       	ldi	r22, 0x80	; 128
    2bb6:	70 e0       	ldi	r23, 0x00	; 0
    2bb8:	c8 01       	movw	r24, r16
    2bba:	87 df       	rcall	.-242    	; 0x2aca <receiveString>

        // Parse the log message
        if (strstr(logBuffer, "ACCESS: TRUE")) {
    2bbc:	67 e5       	ldi	r22, 0x57	; 87
    2bbe:	70 e2       	ldi	r23, 0x20	; 32
    2bc0:	c8 01       	movw	r24, r16
    2bc2:	a8 d2       	rcall	.+1360   	; 0x3114 <strstr>
    2bc4:	89 2b       	or	r24, r25
    2bc6:	31 f0       	breq	.+12     	; 0x2bd4 <vUARTTask+0x4a>
            access_granted = true;
    2bc8:	e0 92 26 23 	sts	0x2326, r14	; 0x802326 <access_granted>
            alarm_active = false;
    2bcc:	10 92 29 23 	sts	0x2329, r1	; 0x802329 <alarm_active>
            reset_actuators();
    2bd0:	c7 df       	rcall	.-114    	; 0x2b60 <reset_actuators>
    2bd2:	08 c0       	rjmp	.+16     	; 0x2be4 <vUARTTask+0x5a>
        } else if (strstr(logBuffer, "ACCESS: FALSE")) {
    2bd4:	64 e6       	ldi	r22, 0x64	; 100
    2bd6:	70 e2       	ldi	r23, 0x20	; 32
    2bd8:	c8 01       	movw	r24, r16
    2bda:	9c d2       	rcall	.+1336   	; 0x3114 <strstr>
    2bdc:	89 2b       	or	r24, r25
    2bde:	11 f0       	breq	.+4      	; 0x2be4 <vUARTTask+0x5a>
            access_granted = false;
    2be0:	10 92 26 23 	sts	0x2326, r1	; 0x802326 <access_granted>
        }

        // Optional: Display the log on LCD
        gfx_mono_draw_string(logBuffer, 0, 32, &sysfont);
    2be4:	26 e0       	ldi	r18, 0x06	; 6
    2be6:	30 e2       	ldi	r19, 0x20	; 32
    2be8:	40 e2       	ldi	r20, 0x20	; 32
    2bea:	60 e0       	ldi	r22, 0x00	; 0
    2bec:	c8 01       	movw	r24, r16
    2bee:	0e 94 73 06 	call	0xce6	; 0xce6 <gfx_mono_draw_string>

        vTaskDelay(100 / portTICK_PERIOD_MS);
    2bf2:	82 e3       	ldi	r24, 0x32	; 50
    2bf4:	90 e0       	ldi	r25, 0x00	; 0
    2bf6:	4e db       	rcall	.-2404   	; 0x2294 <vTaskDelay>
    }
    2bf8:	d8 cf       	rjmp	.-80     	; 0x2baa <vUARTTask+0x20>

00002bfa <vAlarmControl>:
/* Task: Alarm Control                                                  */
/************************************************************************/
static portTASK_FUNCTION(vAlarmControl, pvParameters) {
    while (1) {
        if (xSemaphoreTake(xSemaphoreDoor, portMAX_DELAY) == pdTRUE) {
            alarm_active = true;
    2bfa:	bb 24       	eor	r11, r11
    2bfc:	b3 94       	inc	r11
            counter = 0;

            while (alarm_active && system_active) {
                if (counter < 10) {
                    TCD0.CCA = 500; // Low buzzer frequency
    2bfe:	00 e0       	ldi	r16, 0x00	; 0
    2c00:	19 e0       	ldi	r17, 0x09	; 9
    2c02:	0f 2e       	mov	r0, r31
    2c04:	f4 ef       	ldi	r31, 0xF4	; 244
    2c06:	cf 2e       	mov	r12, r31
    2c08:	dd 24       	eor	r13, r13
    2c0a:	d3 94       	inc	r13
    2c0c:	f0 2d       	mov	r31, r0
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
    2c0e:	c0 ee       	ldi	r28, 0xE0	; 224
    2c10:	d7 e0       	ldi	r29, 0x07	; 7
    2c12:	68 94       	set
    2c14:	aa 24       	eor	r10, r10
    2c16:	a1 f8       	bld	r10, 1
                    LED_On(LED0);
                    LED_On(LED1);
                } else {
                    TCD0.CCA = 800; // High buzzer frequency
    2c18:	0f 2e       	mov	r0, r31
    2c1a:	f0 e2       	ldi	r31, 0x20	; 32
    2c1c:	ef 2e       	mov	r14, r31
    2c1e:	f3 e0       	ldi	r31, 0x03	; 3
    2c20:	ff 2e       	mov	r15, r31
    2c22:	f0 2d       	mov	r31, r0
/************************************************************************/
/* Task: Alarm Control                                                  */
/************************************************************************/
static portTASK_FUNCTION(vAlarmControl, pvParameters) {
    while (1) {
        if (xSemaphoreTake(xSemaphoreDoor, portMAX_DELAY) == pdTRUE) {
    2c24:	20 e0       	ldi	r18, 0x00	; 0
    2c26:	4f ef       	ldi	r20, 0xFF	; 255
    2c28:	5f ef       	ldi	r21, 0xFF	; 255
    2c2a:	60 e0       	ldi	r22, 0x00	; 0
    2c2c:	70 e0       	ldi	r23, 0x00	; 0
    2c2e:	80 91 ac 23 	lds	r24, 0x23AC	; 0x8023ac <xSemaphoreDoor>
    2c32:	90 91 ad 23 	lds	r25, 0x23AD	; 0x8023ad <xSemaphoreDoor+0x1>
    2c36:	0e 94 cf 0d 	call	0x1b9e	; 0x1b9e <xQueueGenericReceive>
    2c3a:	81 30       	cpi	r24, 0x01	; 1
    2c3c:	c1 f5       	brne	.+112    	; 0x2cae <vAlarmControl+0xb4>
            alarm_active = true;
    2c3e:	b0 92 29 23 	sts	0x2329, r11	; 0x802329 <alarm_active>
            counter = 0;
    2c42:	10 92 27 23 	sts	0x2327, r1	; 0x802327 <counter>
    2c46:	10 92 28 23 	sts	0x2328, r1	; 0x802328 <counter+0x1>

            while (alarm_active && system_active) {
    2c4a:	80 91 29 23 	lds	r24, 0x2329	; 0x802329 <alarm_active>
    2c4e:	88 23       	and	r24, r24
    2c50:	49 f1       	breq	.+82     	; 0x2ca4 <vAlarmControl+0xaa>
    2c52:	80 91 2b 23 	lds	r24, 0x232B	; 0x80232b <system_active>
    2c56:	88 23       	and	r24, r24
    2c58:	29 f1       	breq	.+74     	; 0x2ca4 <vAlarmControl+0xaa>
                if (counter < 10) {
    2c5a:	80 91 27 23 	lds	r24, 0x2327	; 0x802327 <counter>
    2c5e:	90 91 28 23 	lds	r25, 0x2328	; 0x802328 <counter+0x1>
    2c62:	0a 97       	sbiw	r24, 0x0a	; 10
    2c64:	34 f4       	brge	.+12     	; 0x2c72 <vAlarmControl+0x78>
                    TCD0.CCA = 500; // Low buzzer frequency
    2c66:	f8 01       	movw	r30, r16
    2c68:	c0 a6       	std	Z+40, r12	; 0x28
    2c6a:	d1 a6       	std	Z+41, r13	; 0x29
    2c6c:	be 82       	std	Y+6, r11	; 0x06
    2c6e:	ae 82       	std	Y+6, r10	; 0x06
    2c70:	05 c0       	rjmp	.+10     	; 0x2c7c <vAlarmControl+0x82>
                    LED_On(LED0);
                    LED_On(LED1);
                } else {
                    TCD0.CCA = 800; // High buzzer frequency
    2c72:	f8 01       	movw	r30, r16
    2c74:	e0 a6       	std	Z+40, r14	; 0x28
    2c76:	f1 a6       	std	Z+41, r15	; 0x29

__always_inline static void arch_ioport_toggle_pin_level(ioport_pin_t pin)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	base->OUTTGL = arch_ioport_pin_to_mask(pin);
    2c78:	bf 82       	std	Y+7, r11	; 0x07
    2c7a:	af 82       	std	Y+7, r10	; 0x07
                    LED_Toggle(LED0);
                    LED_Toggle(LED1);
                }
                counter++;
    2c7c:	80 91 27 23 	lds	r24, 0x2327	; 0x802327 <counter>
    2c80:	90 91 28 23 	lds	r25, 0x2328	; 0x802328 <counter+0x1>
    2c84:	01 96       	adiw	r24, 0x01	; 1
    2c86:	80 93 27 23 	sts	0x2327, r24	; 0x802327 <counter>
    2c8a:	90 93 28 23 	sts	0x2328, r25	; 0x802328 <counter+0x1>
                vTaskDelay(100 / portTICK_PERIOD_MS);
    2c8e:	82 e3       	ldi	r24, 0x32	; 50
    2c90:	90 e0       	ldi	r25, 0x00	; 0
    2c92:	00 db       	rcall	.-2560   	; 0x2294 <vTaskDelay>
    while (1) {
        if (xSemaphoreTake(xSemaphoreDoor, portMAX_DELAY) == pdTRUE) {
            alarm_active = true;
            counter = 0;

            while (alarm_active && system_active) {
    2c94:	80 91 29 23 	lds	r24, 0x2329	; 0x802329 <alarm_active>
    2c98:	88 23       	and	r24, r24
    2c9a:	21 f0       	breq	.+8      	; 0x2ca4 <vAlarmControl+0xaa>
    2c9c:	80 91 2b 23 	lds	r24, 0x232B	; 0x80232b <system_active>
    2ca0:	81 11       	cpse	r24, r1
                    LED_Toggle(LED1);
                }
                counter++;
                vTaskDelay(100 / portTICK_PERIOD_MS);
            }
            reset_actuators();
    2ca2:	db cf       	rjmp	.-74     	; 0x2c5a <vAlarmControl+0x60>
    2ca4:	5d df       	rcall	.-326    	; 0x2b60 <reset_actuators>
            counter = 0; // Confirm counter reset after alarm deactivation
    2ca6:	10 92 27 23 	sts	0x2327, r1	; 0x802327 <counter>
    2caa:	10 92 28 23 	sts	0x2328, r1	; 0x802328 <counter+0x1>
        }
        vTaskDelay(100 / portTICK_PERIOD_MS);
    2cae:	82 e3       	ldi	r24, 0x32	; 50
    2cb0:	90 e0       	ldi	r25, 0x00	; 0
    2cb2:	f0 da       	rcall	.-2592   	; 0x2294 <vTaskDelay>
    }
    2cb4:	b7 cf       	rjmp	.-146    	; 0x2c24 <vAlarmControl+0x2a>

00002cb6 <vPushButton>:
/************************************************************************/
/* Task: Push Button Handling                                           */
/************************************************************************/
static portTASK_FUNCTION(vPushButton, pvParameters) {
    while (1) {
        if (!(PORTF.IN & PIN1_bm)) {  // SW1 toggle system state
    2cb6:	c0 ea       	ldi	r28, 0xA0	; 160
    2cb8:	d6 e0       	ldi	r29, 0x06	; 6
            system_active = !system_active;
    2cba:	11 e0       	ldi	r17, 0x01	; 1
/************************************************************************/
/* Task: Push Button Handling                                           */
/************************************************************************/
static portTASK_FUNCTION(vPushButton, pvParameters) {
    while (1) {
        if (!(PORTF.IN & PIN1_bm)) {  // SW1 toggle system state
    2cbc:	88 85       	ldd	r24, Y+8	; 0x08
    2cbe:	81 fd       	sbrc	r24, 1
    2cc0:	18 c0       	rjmp	.+48     	; 0x2cf2 <vPushButton+0x3c>
            system_active = !system_active;
    2cc2:	80 91 2b 23 	lds	r24, 0x232B	; 0x80232b <system_active>
    2cc6:	81 27       	eor	r24, r17
    2cc8:	80 93 2b 23 	sts	0x232B, r24	; 0x80232b <system_active>
            if (!system_active) {
    2ccc:	80 91 2b 23 	lds	r24, 0x232B	; 0x80232b <system_active>
    2cd0:	81 11       	cpse	r24, r1
    2cd2:	01 c0       	rjmp	.+2      	; 0x2cd6 <vPushButton+0x20>
                reset_actuators();
    2cd4:	45 df       	rcall	.-374    	; 0x2b60 <reset_actuators>
            }
            xSemaphoreGive(xSemaphoreSystem);  // Signal status change
    2cd6:	20 e0       	ldi	r18, 0x00	; 0
    2cd8:	40 e0       	ldi	r20, 0x00	; 0
    2cda:	50 e0       	ldi	r21, 0x00	; 0
    2cdc:	60 e0       	ldi	r22, 0x00	; 0
    2cde:	70 e0       	ldi	r23, 0x00	; 0
    2ce0:	80 91 ae 23 	lds	r24, 0x23AE	; 0x8023ae <xSemaphoreSystem>
    2ce4:	90 91 af 23 	lds	r25, 0x23AF	; 0x8023af <xSemaphoreSystem+0x1>
    2ce8:	0e 94 0c 0d 	call	0x1a18	; 0x1a18 <xQueueGenericSend>
            vTaskDelay(200 / portTICK_PERIOD_MS);
    2cec:	84 e6       	ldi	r24, 0x64	; 100
    2cee:	90 e0       	ldi	r25, 0x00	; 0
    2cf0:	d1 da       	rcall	.-2654   	; 0x2294 <vTaskDelay>
        }
        if (!(PORTF.IN & PIN2_bm)) {  // SW2 reset actuators
    2cf2:	88 85       	ldd	r24, Y+8	; 0x08
    2cf4:	82 fd       	sbrc	r24, 2
    2cf6:	11 c0       	rjmp	.+34     	; 0x2d1a <vPushButton+0x64>
            alarm_active = false;
    2cf8:	10 92 29 23 	sts	0x2329, r1	; 0x802329 <alarm_active>
            reset_actuators();
    2cfc:	31 df       	rcall	.-414    	; 0x2b60 <reset_actuators>
            xSemaphoreGive(xSemaphoreSystem);  // Signal system reset
    2cfe:	20 e0       	ldi	r18, 0x00	; 0
    2d00:	40 e0       	ldi	r20, 0x00	; 0
    2d02:	50 e0       	ldi	r21, 0x00	; 0
    2d04:	60 e0       	ldi	r22, 0x00	; 0
    2d06:	70 e0       	ldi	r23, 0x00	; 0
    2d08:	80 91 ae 23 	lds	r24, 0x23AE	; 0x8023ae <xSemaphoreSystem>
    2d0c:	90 91 af 23 	lds	r25, 0x23AF	; 0x8023af <xSemaphoreSystem+0x1>
    2d10:	0e 94 0c 0d 	call	0x1a18	; 0x1a18 <xQueueGenericSend>
            vTaskDelay(200 / portTICK_PERIOD_MS);
    2d14:	84 e6       	ldi	r24, 0x64	; 100
    2d16:	90 e0       	ldi	r25, 0x00	; 0
        }
        vTaskDelay(100 / portTICK_PERIOD_MS);
    2d18:	bd da       	rcall	.-2694   	; 0x2294 <vTaskDelay>
    2d1a:	82 e3       	ldi	r24, 0x32	; 50
    2d1c:	90 e0       	ldi	r25, 0x00	; 0
    2d1e:	ba da       	rcall	.-2700   	; 0x2294 <vTaskDelay>
    }
    2d20:	cd cf       	rjmp	.-102    	; 0x2cbc <vPushButton+0x6>

00002d22 <check_door_sensor>:
/************************************************************************/
/* Function to Check Door Sensor                                        */
/************************************************************************/
void check_door_sensor(void)
{
    bool is_closed = PORTE.IN & PIN0_bm;
    2d22:	80 91 88 06 	lds	r24, 0x0688	; 0x800688 <__TEXT_REGION_LENGTH__+0x700688>
    door_open = !is_closed;
    2d26:	80 95       	com	r24
    2d28:	81 70       	andi	r24, 0x01	; 1
    2d2a:	80 93 2a 23 	sts	0x232A, r24	; 0x80232a <door_open>
    2d2e:	08 95       	ret

00002d30 <vCheckDoor>:
/************************************************************************/
/* Task: Check Door Status                                              */
/************************************************************************/
static portTASK_FUNCTION(vCheckDoor, pvParameters) {
    while (1) {
        if (system_active) {
    2d30:	80 91 2b 23 	lds	r24, 0x232B	; 0x80232b <system_active>
    2d34:	88 23       	and	r24, r24
    2d36:	a1 f0       	breq	.+40     	; 0x2d60 <vCheckDoor+0x30>
            check_door_sensor(); // Update door_open status
    2d38:	f4 df       	rcall	.-24     	; 0x2d22 <check_door_sensor>
            if (!door_open && !access_granted) {
    2d3a:	80 91 2a 23 	lds	r24, 0x232A	; 0x80232a <door_open>
    2d3e:	81 11       	cpse	r24, r1
    2d40:	0f c0       	rjmp	.+30     	; 0x2d60 <vCheckDoor+0x30>
    2d42:	80 91 26 23 	lds	r24, 0x2326	; 0x802326 <access_granted>
    2d46:	81 11       	cpse	r24, r1
    2d48:	0b c0       	rjmp	.+22     	; 0x2d60 <vCheckDoor+0x30>
                xSemaphoreGive(xSemaphoreDoor); // Trigger alarm
    2d4a:	20 e0       	ldi	r18, 0x00	; 0
    2d4c:	40 e0       	ldi	r20, 0x00	; 0
    2d4e:	50 e0       	ldi	r21, 0x00	; 0
    2d50:	60 e0       	ldi	r22, 0x00	; 0
    2d52:	70 e0       	ldi	r23, 0x00	; 0
    2d54:	80 91 ac 23 	lds	r24, 0x23AC	; 0x8023ac <xSemaphoreDoor>
    2d58:	90 91 ad 23 	lds	r25, 0x23AD	; 0x8023ad <xSemaphoreDoor+0x1>
    2d5c:	0e 94 0c 0d 	call	0x1a18	; 0x1a18 <xQueueGenericSend>
            }
        }
        vTaskDelay(100 / portTICK_PERIOD_MS);
    2d60:	82 e3       	ldi	r24, 0x32	; 50
    2d62:	90 e0       	ldi	r25, 0x00	; 0
    2d64:	97 da       	rcall	.-2770   	; 0x2294 <vTaskDelay>
    }
    2d66:	e4 cf       	rjmp	.-56     	; 0x2d30 <vCheckDoor>

00002d68 <main>:
}

/************************************************************************/
/* Main Function                                                        */
/************************************************************************/
int main(void) {
    2d68:	af 92       	push	r10
    2d6a:	bf 92       	push	r11
    2d6c:	cf 92       	push	r12
    2d6e:	df 92       	push	r13
    2d70:	ef 92       	push	r14
    2d72:	ff 92       	push	r15
    2d74:	0f 93       	push	r16
    board_init();
    2d76:	0e 94 38 07 	call	0xe70	; 0xe70 <board_init>
    PMIC.CTRL |= PMIC_LOLVLEN_bm;
    2d7a:	e0 ea       	ldi	r30, 0xA0	; 160
    2d7c:	f0 e0       	ldi	r31, 0x00	; 0
    2d7e:	82 81       	ldd	r24, Z+2	; 0x02
    2d80:	81 60       	ori	r24, 0x01	; 1
    2d82:	82 83       	std	Z+2, r24	; 0x02
    cpu_irq_enable();
    2d84:	78 94       	sei

    // Initialize Semaphores
    xSemaphoreDoor = xSemaphoreCreateBinary();
    2d86:	43 e0       	ldi	r20, 0x03	; 3
    2d88:	60 e0       	ldi	r22, 0x00	; 0
    2d8a:	81 e0       	ldi	r24, 0x01	; 1
    2d8c:	0e 94 e3 0c 	call	0x19c6	; 0x19c6 <xQueueGenericCreate>
    2d90:	80 93 ac 23 	sts	0x23AC, r24	; 0x8023ac <xSemaphoreDoor>
    2d94:	90 93 ad 23 	sts	0x23AD, r25	; 0x8023ad <xSemaphoreDoor+0x1>
    xSemaphoreSystem = xSemaphoreCreateBinary();
    2d98:	43 e0       	ldi	r20, 0x03	; 3
    2d9a:	60 e0       	ldi	r22, 0x00	; 0
    2d9c:	81 e0       	ldi	r24, 0x01	; 1
    2d9e:	0e 94 e3 0c 	call	0x19c6	; 0x19c6 <xQueueGenericCreate>
    2da2:	80 93 ae 23 	sts	0x23AE, r24	; 0x8023ae <xSemaphoreSystem>
    2da6:	90 93 af 23 	sts	0x23AF, r25	; 0x8023af <xSemaphoreSystem+0x1>

    // Initialize UART
    setUpSerial();
    2daa:	74 de       	rcall	.-792    	; 0x2a94 <setUpSerial>

    // Initialize PWM for Servo and Buzzer
    PWM_Init();
    2dac:	b6 de       	rcall	.-660    	; 0x2b1a <PWM_Init>
    2dae:	e0 ea       	ldi	r30, 0xA0	; 160

    // Initialize button pins
    PORTF.DIRCLR = PIN1_bm | PIN2_bm;
    2db0:	f6 e0       	ldi	r31, 0x06	; 6
    2db2:	86 e0       	ldi	r24, 0x06	; 6
    2db4:	82 83       	std	Z+2, r24	; 0x02
    2db6:	82 e0       	ldi	r24, 0x02	; 2
    PORTF.PIN1CTRL = PORT_ISC_FALLING_gc;
    2db8:	81 8b       	std	Z+17, r24	; 0x11
    2dba:	82 8b       	std	Z+18, r24	; 0x12
    PORTF.PIN2CTRL = PORT_ISC_FALLING_gc;
    2dbc:	e0 e8       	ldi	r30, 0x80	; 128

    // Initialize door sensor pin
    PORTE.DIRCLR = PIN0_bm;
    2dbe:	f6 e0       	ldi	r31, 0x06	; 6
    2dc0:	81 e0       	ldi	r24, 0x01	; 1
    2dc2:	82 83       	std	Z+2, r24	; 0x02
    2dc4:	88 e1       	ldi	r24, 0x18	; 24
    PORTE.PIN0CTRL = PORT_OPC_PULLUP_gc;
    2dc6:	80 8b       	std	Z+16, r24	; 0x10
    2dc8:	a1 2c       	mov	r10, r1

    // Create Tasks
    xTaskCreate(vPushButton, "PushButton", 1000, NULL, tskIDLE_PRIORITY + 4, NULL);
    2dca:	b1 2c       	mov	r11, r1
    2dcc:	c1 2c       	mov	r12, r1
    2dce:	d1 2c       	mov	r13, r1
    2dd0:	e1 2c       	mov	r14, r1
    2dd2:	f1 2c       	mov	r15, r1
    2dd4:	04 e0       	ldi	r16, 0x04	; 4
    2dd6:	20 e0       	ldi	r18, 0x00	; 0
    2dd8:	30 e0       	ldi	r19, 0x00	; 0
    2dda:	48 ee       	ldi	r20, 0xE8	; 232
    2ddc:	53 e0       	ldi	r21, 0x03	; 3
    2dde:	62 e7       	ldi	r22, 0x72	; 114
    2de0:	70 e2       	ldi	r23, 0x20	; 32
    2de2:	8b e5       	ldi	r24, 0x5B	; 91
    2de4:	96 e1       	ldi	r25, 0x16	; 22
    2de6:	0e 94 bd 0e 	call	0x1d7a	; 0x1d7a <xTaskGenericCreate>
    2dea:	03 e0       	ldi	r16, 0x03	; 3
    xTaskCreate(vCheckDoor, "CheckDoor", 1000, NULL, tskIDLE_PRIORITY + 3, NULL);
    2dec:	20 e0       	ldi	r18, 0x00	; 0
    2dee:	30 e0       	ldi	r19, 0x00	; 0
    2df0:	48 ee       	ldi	r20, 0xE8	; 232
    2df2:	53 e0       	ldi	r21, 0x03	; 3
    2df4:	6d e7       	ldi	r22, 0x7D	; 125
    2df6:	70 e2       	ldi	r23, 0x20	; 32
    2df8:	88 e9       	ldi	r24, 0x98	; 152
    2dfa:	96 e1       	ldi	r25, 0x16	; 22
    2dfc:	0e 94 bd 0e 	call	0x1d7a	; 0x1d7a <xTaskGenericCreate>
    2e00:	02 e0       	ldi	r16, 0x02	; 2
    xTaskCreate(vAlarmControl, "AlarmControl", 1000, NULL, tskIDLE_PRIORITY + 2, NULL);
    2e02:	20 e0       	ldi	r18, 0x00	; 0
    2e04:	30 e0       	ldi	r19, 0x00	; 0
    2e06:	48 ee       	ldi	r20, 0xE8	; 232
    2e08:	53 e0       	ldi	r21, 0x03	; 3
    2e0a:	67 e8       	ldi	r22, 0x87	; 135
    2e0c:	70 e2       	ldi	r23, 0x20	; 32
    2e0e:	8d ef       	ldi	r24, 0xFD	; 253
    2e10:	95 e1       	ldi	r25, 0x15	; 21
    2e12:	0e 94 bd 0e 	call	0x1d7a	; 0x1d7a <xTaskGenericCreate>
    2e16:	20 e0       	ldi	r18, 0x00	; 0
    xTaskCreate(vServoControl, "ServoControl", 1000, NULL, tskIDLE_PRIORITY + 2, NULL);
    2e18:	30 e0       	ldi	r19, 0x00	; 0
    2e1a:	48 ee       	ldi	r20, 0xE8	; 232
    2e1c:	53 e0       	ldi	r21, 0x03	; 3
    2e1e:	64 e9       	ldi	r22, 0x94	; 148
    2e20:	70 e2       	ldi	r23, 0x20	; 32
    2e22:	8b e2       	ldi	r24, 0x2B	; 43
    2e24:	95 e1       	ldi	r25, 0x15	; 21
    2e26:	0e 94 bd 0e 	call	0x1d7a	; 0x1d7a <xTaskGenericCreate>
    2e2a:	01 e0       	ldi	r16, 0x01	; 1
    xTaskCreate(vUARTTask, "UARTTask", 1000, NULL, tskIDLE_PRIORITY + 1, NULL);
    2e2c:	20 e0       	ldi	r18, 0x00	; 0
    2e2e:	30 e0       	ldi	r19, 0x00	; 0
    2e30:	48 ee       	ldi	r20, 0xE8	; 232
    2e32:	53 e0       	ldi	r21, 0x03	; 3
    2e34:	61 ea       	ldi	r22, 0xA1	; 161
    2e36:	70 e2       	ldi	r23, 0x20	; 32
    2e38:	85 ec       	ldi	r24, 0xC5	; 197
    2e3a:	95 e1       	ldi	r25, 0x15	; 21
    2e3c:	0e 94 bd 0e 	call	0x1d7a	; 0x1d7a <xTaskGenericCreate>
    2e40:	00 e0       	ldi	r16, 0x00	; 0
    xTaskCreate(vDisplayStatus, "Display", 1000, NULL, tskIDLE_PRIORITY, NULL);
    2e42:	20 e0       	ldi	r18, 0x00	; 0
    2e44:	30 e0       	ldi	r19, 0x00	; 0
    2e46:	48 ee       	ldi	r20, 0xE8	; 232
    2e48:	53 e0       	ldi	r21, 0x03	; 3
    2e4a:	6a ea       	ldi	r22, 0xAA	; 170
    2e4c:	70 e2       	ldi	r23, 0x20	; 32
    2e4e:	87 ea       	ldi	r24, 0xA7	; 167
    2e50:	94 e1       	ldi	r25, 0x14	; 20
    2e52:	0e 94 bd 0e 	call	0x1d7a	; 0x1d7a <xTaskGenericCreate>

    // Start Scheduler
    vTaskStartScheduler();
    2e56:	92 d8       	rcall	.-3804   	; 0x1f7c <vTaskStartScheduler>
    2e58:	80 e0       	ldi	r24, 0x00	; 0
    2e5a:	90 e0       	ldi	r25, 0x00	; 0
    2e5c:	0f 91       	pop	r16
    2e5e:	ff 90       	pop	r15
    2e60:	ef 90       	pop	r14
    2e62:	df 90       	pop	r13
    2e64:	cf 90       	pop	r12
    2e66:	bf 90       	pop	r11
    2e68:	af 90       	pop	r10
    2e6a:	08 95       	ret

00002e6c <__udivmodsi4>:
    2e6c:	a1 e2       	ldi	r26, 0x21	; 33
    2e6e:	1a 2e       	mov	r1, r26
    2e70:	aa 1b       	sub	r26, r26
    2e72:	bb 1b       	sub	r27, r27
    2e74:	fd 01       	movw	r30, r26
    2e76:	0d c0       	rjmp	.+26     	; 0x2e92 <__udivmodsi4_ep>

00002e78 <__udivmodsi4_loop>:
    2e78:	aa 1f       	adc	r26, r26
    2e7a:	bb 1f       	adc	r27, r27
    2e7c:	ee 1f       	adc	r30, r30
    2e7e:	ff 1f       	adc	r31, r31
    2e80:	a2 17       	cp	r26, r18
    2e82:	b3 07       	cpc	r27, r19
    2e84:	e4 07       	cpc	r30, r20
    2e86:	f5 07       	cpc	r31, r21
    2e88:	20 f0       	brcs	.+8      	; 0x2e92 <__udivmodsi4_ep>
    2e8a:	a2 1b       	sub	r26, r18
    2e8c:	b3 0b       	sbc	r27, r19
    2e8e:	e4 0b       	sbc	r30, r20
    2e90:	f5 0b       	sbc	r31, r21

00002e92 <__udivmodsi4_ep>:
    2e92:	66 1f       	adc	r22, r22
    2e94:	77 1f       	adc	r23, r23
    2e96:	88 1f       	adc	r24, r24
    2e98:	99 1f       	adc	r25, r25
    2e9a:	1a 94       	dec	r1
    2e9c:	69 f7       	brne	.-38     	; 0x2e78 <__udivmodsi4_loop>
    2e9e:	60 95       	com	r22
    2ea0:	70 95       	com	r23
    2ea2:	80 95       	com	r24
    2ea4:	90 95       	com	r25
    2ea6:	9b 01       	movw	r18, r22
    2ea8:	ac 01       	movw	r20, r24
    2eaa:	bd 01       	movw	r22, r26
    2eac:	cf 01       	movw	r24, r30
    2eae:	08 95       	ret

00002eb0 <__tablejump2__>:
    2eb0:	ee 0f       	add	r30, r30
    2eb2:	ff 1f       	adc	r31, r31
    2eb4:	88 1f       	adc	r24, r24
    2eb6:	8b bf       	out	0x3b, r24	; 59
    2eb8:	07 90       	elpm	r0, Z+
    2eba:	f6 91       	elpm	r31, Z
    2ebc:	e0 2d       	mov	r30, r0
    2ebe:	19 94       	eijmp

00002ec0 <malloc>:
    2ec0:	0f 93       	push	r16
    2ec2:	1f 93       	push	r17
    2ec4:	cf 93       	push	r28
    2ec6:	df 93       	push	r29
    2ec8:	82 30       	cpi	r24, 0x02	; 2
    2eca:	91 05       	cpc	r25, r1
    2ecc:	10 f4       	brcc	.+4      	; 0x2ed2 <malloc+0x12>
    2ece:	82 e0       	ldi	r24, 0x02	; 2
    2ed0:	90 e0       	ldi	r25, 0x00	; 0
    2ed2:	e0 91 b2 23 	lds	r30, 0x23B2	; 0x8023b2 <__flp>
    2ed6:	f0 91 b3 23 	lds	r31, 0x23B3	; 0x8023b3 <__flp+0x1>
    2eda:	20 e0       	ldi	r18, 0x00	; 0
    2edc:	30 e0       	ldi	r19, 0x00	; 0
    2ede:	a0 e0       	ldi	r26, 0x00	; 0
    2ee0:	b0 e0       	ldi	r27, 0x00	; 0
    2ee2:	30 97       	sbiw	r30, 0x00	; 0
    2ee4:	19 f1       	breq	.+70     	; 0x2f2c <malloc+0x6c>
    2ee6:	40 81       	ld	r20, Z
    2ee8:	51 81       	ldd	r21, Z+1	; 0x01
    2eea:	02 81       	ldd	r16, Z+2	; 0x02
    2eec:	13 81       	ldd	r17, Z+3	; 0x03
    2eee:	48 17       	cp	r20, r24
    2ef0:	59 07       	cpc	r21, r25
    2ef2:	c8 f0       	brcs	.+50     	; 0x2f26 <malloc+0x66>
    2ef4:	84 17       	cp	r24, r20
    2ef6:	95 07       	cpc	r25, r21
    2ef8:	69 f4       	brne	.+26     	; 0x2f14 <malloc+0x54>
    2efa:	10 97       	sbiw	r26, 0x00	; 0
    2efc:	31 f0       	breq	.+12     	; 0x2f0a <malloc+0x4a>
    2efe:	12 96       	adiw	r26, 0x02	; 2
    2f00:	0c 93       	st	X, r16
    2f02:	12 97       	sbiw	r26, 0x02	; 2
    2f04:	13 96       	adiw	r26, 0x03	; 3
    2f06:	1c 93       	st	X, r17
    2f08:	27 c0       	rjmp	.+78     	; 0x2f58 <malloc+0x98>
    2f0a:	00 93 b2 23 	sts	0x23B2, r16	; 0x8023b2 <__flp>
    2f0e:	10 93 b3 23 	sts	0x23B3, r17	; 0x8023b3 <__flp+0x1>
    2f12:	22 c0       	rjmp	.+68     	; 0x2f58 <malloc+0x98>
    2f14:	21 15       	cp	r18, r1
    2f16:	31 05       	cpc	r19, r1
    2f18:	19 f0       	breq	.+6      	; 0x2f20 <malloc+0x60>
    2f1a:	42 17       	cp	r20, r18
    2f1c:	53 07       	cpc	r21, r19
    2f1e:	18 f4       	brcc	.+6      	; 0x2f26 <malloc+0x66>
    2f20:	9a 01       	movw	r18, r20
    2f22:	bd 01       	movw	r22, r26
    2f24:	ef 01       	movw	r28, r30
    2f26:	df 01       	movw	r26, r30
    2f28:	f8 01       	movw	r30, r16
    2f2a:	db cf       	rjmp	.-74     	; 0x2ee2 <malloc+0x22>
    2f2c:	21 15       	cp	r18, r1
    2f2e:	31 05       	cpc	r19, r1
    2f30:	f9 f0       	breq	.+62     	; 0x2f70 <malloc+0xb0>
    2f32:	28 1b       	sub	r18, r24
    2f34:	39 0b       	sbc	r19, r25
    2f36:	24 30       	cpi	r18, 0x04	; 4
    2f38:	31 05       	cpc	r19, r1
    2f3a:	80 f4       	brcc	.+32     	; 0x2f5c <malloc+0x9c>
    2f3c:	8a 81       	ldd	r24, Y+2	; 0x02
    2f3e:	9b 81       	ldd	r25, Y+3	; 0x03
    2f40:	61 15       	cp	r22, r1
    2f42:	71 05       	cpc	r23, r1
    2f44:	21 f0       	breq	.+8      	; 0x2f4e <malloc+0x8e>
    2f46:	fb 01       	movw	r30, r22
    2f48:	82 83       	std	Z+2, r24	; 0x02
    2f4a:	93 83       	std	Z+3, r25	; 0x03
    2f4c:	04 c0       	rjmp	.+8      	; 0x2f56 <malloc+0x96>
    2f4e:	80 93 b2 23 	sts	0x23B2, r24	; 0x8023b2 <__flp>
    2f52:	90 93 b3 23 	sts	0x23B3, r25	; 0x8023b3 <__flp+0x1>
    2f56:	fe 01       	movw	r30, r28
    2f58:	32 96       	adiw	r30, 0x02	; 2
    2f5a:	44 c0       	rjmp	.+136    	; 0x2fe4 <malloc+0x124>
    2f5c:	fe 01       	movw	r30, r28
    2f5e:	e2 0f       	add	r30, r18
    2f60:	f3 1f       	adc	r31, r19
    2f62:	81 93       	st	Z+, r24
    2f64:	91 93       	st	Z+, r25
    2f66:	22 50       	subi	r18, 0x02	; 2
    2f68:	31 09       	sbc	r19, r1
    2f6a:	28 83       	st	Y, r18
    2f6c:	39 83       	std	Y+1, r19	; 0x01
    2f6e:	3a c0       	rjmp	.+116    	; 0x2fe4 <malloc+0x124>
    2f70:	20 91 b0 23 	lds	r18, 0x23B0	; 0x8023b0 <__brkval>
    2f74:	30 91 b1 23 	lds	r19, 0x23B1	; 0x8023b1 <__brkval+0x1>
    2f78:	23 2b       	or	r18, r19
    2f7a:	41 f4       	brne	.+16     	; 0x2f8c <malloc+0xcc>
    2f7c:	20 91 02 20 	lds	r18, 0x2002	; 0x802002 <__malloc_heap_start>
    2f80:	30 91 03 20 	lds	r19, 0x2003	; 0x802003 <__malloc_heap_start+0x1>
    2f84:	20 93 b0 23 	sts	0x23B0, r18	; 0x8023b0 <__brkval>
    2f88:	30 93 b1 23 	sts	0x23B1, r19	; 0x8023b1 <__brkval+0x1>
    2f8c:	20 91 00 20 	lds	r18, 0x2000	; 0x802000 <__DATA_REGION_ORIGIN__>
    2f90:	30 91 01 20 	lds	r19, 0x2001	; 0x802001 <__DATA_REGION_ORIGIN__+0x1>
    2f94:	21 15       	cp	r18, r1
    2f96:	31 05       	cpc	r19, r1
    2f98:	41 f4       	brne	.+16     	; 0x2faa <malloc+0xea>
    2f9a:	2d b7       	in	r18, 0x3d	; 61
    2f9c:	3e b7       	in	r19, 0x3e	; 62
    2f9e:	40 91 04 20 	lds	r20, 0x2004	; 0x802004 <__malloc_margin>
    2fa2:	50 91 05 20 	lds	r21, 0x2005	; 0x802005 <__malloc_margin+0x1>
    2fa6:	24 1b       	sub	r18, r20
    2fa8:	35 0b       	sbc	r19, r21
    2faa:	e0 91 b0 23 	lds	r30, 0x23B0	; 0x8023b0 <__brkval>
    2fae:	f0 91 b1 23 	lds	r31, 0x23B1	; 0x8023b1 <__brkval+0x1>
    2fb2:	e2 17       	cp	r30, r18
    2fb4:	f3 07       	cpc	r31, r19
    2fb6:	a0 f4       	brcc	.+40     	; 0x2fe0 <malloc+0x120>
    2fb8:	2e 1b       	sub	r18, r30
    2fba:	3f 0b       	sbc	r19, r31
    2fbc:	28 17       	cp	r18, r24
    2fbe:	39 07       	cpc	r19, r25
    2fc0:	78 f0       	brcs	.+30     	; 0x2fe0 <malloc+0x120>
    2fc2:	ac 01       	movw	r20, r24
    2fc4:	4e 5f       	subi	r20, 0xFE	; 254
    2fc6:	5f 4f       	sbci	r21, 0xFF	; 255
    2fc8:	24 17       	cp	r18, r20
    2fca:	35 07       	cpc	r19, r21
    2fcc:	48 f0       	brcs	.+18     	; 0x2fe0 <malloc+0x120>
    2fce:	4e 0f       	add	r20, r30
    2fd0:	5f 1f       	adc	r21, r31
    2fd2:	40 93 b0 23 	sts	0x23B0, r20	; 0x8023b0 <__brkval>
    2fd6:	50 93 b1 23 	sts	0x23B1, r21	; 0x8023b1 <__brkval+0x1>
    2fda:	81 93       	st	Z+, r24
    2fdc:	91 93       	st	Z+, r25
    2fde:	02 c0       	rjmp	.+4      	; 0x2fe4 <malloc+0x124>
    2fe0:	e0 e0       	ldi	r30, 0x00	; 0
    2fe2:	f0 e0       	ldi	r31, 0x00	; 0
    2fe4:	cf 01       	movw	r24, r30
    2fe6:	df 91       	pop	r29
    2fe8:	cf 91       	pop	r28
    2fea:	1f 91       	pop	r17
    2fec:	0f 91       	pop	r16
    2fee:	08 95       	ret

00002ff0 <free>:
    2ff0:	cf 93       	push	r28
    2ff2:	df 93       	push	r29
    2ff4:	00 97       	sbiw	r24, 0x00	; 0
    2ff6:	09 f4       	brne	.+2      	; 0x2ffa <free+0xa>
    2ff8:	81 c0       	rjmp	.+258    	; 0x30fc <free+0x10c>
    2ffa:	fc 01       	movw	r30, r24
    2ffc:	32 97       	sbiw	r30, 0x02	; 2
    2ffe:	12 82       	std	Z+2, r1	; 0x02
    3000:	13 82       	std	Z+3, r1	; 0x03
    3002:	a0 91 b2 23 	lds	r26, 0x23B2	; 0x8023b2 <__flp>
    3006:	b0 91 b3 23 	lds	r27, 0x23B3	; 0x8023b3 <__flp+0x1>
    300a:	10 97       	sbiw	r26, 0x00	; 0
    300c:	81 f4       	brne	.+32     	; 0x302e <free+0x3e>
    300e:	20 81       	ld	r18, Z
    3010:	31 81       	ldd	r19, Z+1	; 0x01
    3012:	82 0f       	add	r24, r18
    3014:	93 1f       	adc	r25, r19
    3016:	20 91 b0 23 	lds	r18, 0x23B0	; 0x8023b0 <__brkval>
    301a:	30 91 b1 23 	lds	r19, 0x23B1	; 0x8023b1 <__brkval+0x1>
    301e:	28 17       	cp	r18, r24
    3020:	39 07       	cpc	r19, r25
    3022:	51 f5       	brne	.+84     	; 0x3078 <free+0x88>
    3024:	e0 93 b0 23 	sts	0x23B0, r30	; 0x8023b0 <__brkval>
    3028:	f0 93 b1 23 	sts	0x23B1, r31	; 0x8023b1 <__brkval+0x1>
    302c:	67 c0       	rjmp	.+206    	; 0x30fc <free+0x10c>
    302e:	ed 01       	movw	r28, r26
    3030:	20 e0       	ldi	r18, 0x00	; 0
    3032:	30 e0       	ldi	r19, 0x00	; 0
    3034:	ce 17       	cp	r28, r30
    3036:	df 07       	cpc	r29, r31
    3038:	40 f4       	brcc	.+16     	; 0x304a <free+0x5a>
    303a:	4a 81       	ldd	r20, Y+2	; 0x02
    303c:	5b 81       	ldd	r21, Y+3	; 0x03
    303e:	9e 01       	movw	r18, r28
    3040:	41 15       	cp	r20, r1
    3042:	51 05       	cpc	r21, r1
    3044:	f1 f0       	breq	.+60     	; 0x3082 <free+0x92>
    3046:	ea 01       	movw	r28, r20
    3048:	f5 cf       	rjmp	.-22     	; 0x3034 <free+0x44>
    304a:	c2 83       	std	Z+2, r28	; 0x02
    304c:	d3 83       	std	Z+3, r29	; 0x03
    304e:	40 81       	ld	r20, Z
    3050:	51 81       	ldd	r21, Z+1	; 0x01
    3052:	84 0f       	add	r24, r20
    3054:	95 1f       	adc	r25, r21
    3056:	c8 17       	cp	r28, r24
    3058:	d9 07       	cpc	r29, r25
    305a:	59 f4       	brne	.+22     	; 0x3072 <free+0x82>
    305c:	88 81       	ld	r24, Y
    305e:	99 81       	ldd	r25, Y+1	; 0x01
    3060:	84 0f       	add	r24, r20
    3062:	95 1f       	adc	r25, r21
    3064:	02 96       	adiw	r24, 0x02	; 2
    3066:	80 83       	st	Z, r24
    3068:	91 83       	std	Z+1, r25	; 0x01
    306a:	8a 81       	ldd	r24, Y+2	; 0x02
    306c:	9b 81       	ldd	r25, Y+3	; 0x03
    306e:	82 83       	std	Z+2, r24	; 0x02
    3070:	93 83       	std	Z+3, r25	; 0x03
    3072:	21 15       	cp	r18, r1
    3074:	31 05       	cpc	r19, r1
    3076:	29 f4       	brne	.+10     	; 0x3082 <free+0x92>
    3078:	e0 93 b2 23 	sts	0x23B2, r30	; 0x8023b2 <__flp>
    307c:	f0 93 b3 23 	sts	0x23B3, r31	; 0x8023b3 <__flp+0x1>
    3080:	3d c0       	rjmp	.+122    	; 0x30fc <free+0x10c>
    3082:	e9 01       	movw	r28, r18
    3084:	ea 83       	std	Y+2, r30	; 0x02
    3086:	fb 83       	std	Y+3, r31	; 0x03
    3088:	49 91       	ld	r20, Y+
    308a:	59 91       	ld	r21, Y+
    308c:	c4 0f       	add	r28, r20
    308e:	d5 1f       	adc	r29, r21
    3090:	ec 17       	cp	r30, r28
    3092:	fd 07       	cpc	r31, r29
    3094:	61 f4       	brne	.+24     	; 0x30ae <free+0xbe>
    3096:	80 81       	ld	r24, Z
    3098:	91 81       	ldd	r25, Z+1	; 0x01
    309a:	84 0f       	add	r24, r20
    309c:	95 1f       	adc	r25, r21
    309e:	02 96       	adiw	r24, 0x02	; 2
    30a0:	e9 01       	movw	r28, r18
    30a2:	88 83       	st	Y, r24
    30a4:	99 83       	std	Y+1, r25	; 0x01
    30a6:	82 81       	ldd	r24, Z+2	; 0x02
    30a8:	93 81       	ldd	r25, Z+3	; 0x03
    30aa:	8a 83       	std	Y+2, r24	; 0x02
    30ac:	9b 83       	std	Y+3, r25	; 0x03
    30ae:	e0 e0       	ldi	r30, 0x00	; 0
    30b0:	f0 e0       	ldi	r31, 0x00	; 0
    30b2:	12 96       	adiw	r26, 0x02	; 2
    30b4:	8d 91       	ld	r24, X+
    30b6:	9c 91       	ld	r25, X
    30b8:	13 97       	sbiw	r26, 0x03	; 3
    30ba:	00 97       	sbiw	r24, 0x00	; 0
    30bc:	19 f0       	breq	.+6      	; 0x30c4 <free+0xd4>
    30be:	fd 01       	movw	r30, r26
    30c0:	dc 01       	movw	r26, r24
    30c2:	f7 cf       	rjmp	.-18     	; 0x30b2 <free+0xc2>
    30c4:	8d 91       	ld	r24, X+
    30c6:	9c 91       	ld	r25, X
    30c8:	11 97       	sbiw	r26, 0x01	; 1
    30ca:	9d 01       	movw	r18, r26
    30cc:	2e 5f       	subi	r18, 0xFE	; 254
    30ce:	3f 4f       	sbci	r19, 0xFF	; 255
    30d0:	82 0f       	add	r24, r18
    30d2:	93 1f       	adc	r25, r19
    30d4:	20 91 b0 23 	lds	r18, 0x23B0	; 0x8023b0 <__brkval>
    30d8:	30 91 b1 23 	lds	r19, 0x23B1	; 0x8023b1 <__brkval+0x1>
    30dc:	28 17       	cp	r18, r24
    30de:	39 07       	cpc	r19, r25
    30e0:	69 f4       	brne	.+26     	; 0x30fc <free+0x10c>
    30e2:	30 97       	sbiw	r30, 0x00	; 0
    30e4:	29 f4       	brne	.+10     	; 0x30f0 <free+0x100>
    30e6:	10 92 b2 23 	sts	0x23B2, r1	; 0x8023b2 <__flp>
    30ea:	10 92 b3 23 	sts	0x23B3, r1	; 0x8023b3 <__flp+0x1>
    30ee:	02 c0       	rjmp	.+4      	; 0x30f4 <free+0x104>
    30f0:	12 82       	std	Z+2, r1	; 0x02
    30f2:	13 82       	std	Z+3, r1	; 0x03
    30f4:	a0 93 b0 23 	sts	0x23B0, r26	; 0x8023b0 <__brkval>
    30f8:	b0 93 b1 23 	sts	0x23B1, r27	; 0x8023b1 <__brkval+0x1>
    30fc:	df 91       	pop	r29
    30fe:	cf 91       	pop	r28
    3100:	08 95       	ret

00003102 <memcpy>:
    3102:	fb 01       	movw	r30, r22
    3104:	dc 01       	movw	r26, r24
    3106:	02 c0       	rjmp	.+4      	; 0x310c <memcpy+0xa>
    3108:	01 90       	ld	r0, Z+
    310a:	0d 92       	st	X+, r0
    310c:	41 50       	subi	r20, 0x01	; 1
    310e:	50 40       	sbci	r21, 0x00	; 0
    3110:	d8 f7       	brcc	.-10     	; 0x3108 <memcpy+0x6>
    3112:	08 95       	ret

00003114 <strstr>:
    3114:	fb 01       	movw	r30, r22
    3116:	51 91       	ld	r21, Z+
    3118:	55 23       	and	r21, r21
    311a:	a9 f0       	breq	.+42     	; 0x3146 <strstr+0x32>
    311c:	bf 01       	movw	r22, r30
    311e:	dc 01       	movw	r26, r24
    3120:	4d 91       	ld	r20, X+
    3122:	45 17       	cp	r20, r21
    3124:	41 11       	cpse	r20, r1
    3126:	e1 f7       	brne	.-8      	; 0x3120 <strstr+0xc>
    3128:	59 f4       	brne	.+22     	; 0x3140 <strstr+0x2c>
    312a:	cd 01       	movw	r24, r26
    312c:	01 90       	ld	r0, Z+
    312e:	00 20       	and	r0, r0
    3130:	49 f0       	breq	.+18     	; 0x3144 <strstr+0x30>
    3132:	4d 91       	ld	r20, X+
    3134:	40 15       	cp	r20, r0
    3136:	41 11       	cpse	r20, r1
    3138:	c9 f3       	breq	.-14     	; 0x312c <strstr+0x18>
    313a:	fb 01       	movw	r30, r22
    313c:	41 11       	cpse	r20, r1
    313e:	ef cf       	rjmp	.-34     	; 0x311e <strstr+0xa>
    3140:	81 e0       	ldi	r24, 0x01	; 1
    3142:	90 e0       	ldi	r25, 0x00	; 0
    3144:	01 97       	sbiw	r24, 0x01	; 1
    3146:	08 95       	ret

00003148 <snprintf>:
    3148:	0f 93       	push	r16
    314a:	1f 93       	push	r17
    314c:	cf 93       	push	r28
    314e:	df 93       	push	r29
    3150:	cd b7       	in	r28, 0x3d	; 61
    3152:	de b7       	in	r29, 0x3e	; 62
    3154:	2e 97       	sbiw	r28, 0x0e	; 14
    3156:	cd bf       	out	0x3d, r28	; 61
    3158:	de bf       	out	0x3e, r29	; 62
    315a:	0e 89       	ldd	r16, Y+22	; 0x16
    315c:	1f 89       	ldd	r17, Y+23	; 0x17
    315e:	88 8d       	ldd	r24, Y+24	; 0x18
    3160:	99 8d       	ldd	r25, Y+25	; 0x19
    3162:	26 e0       	ldi	r18, 0x06	; 6
    3164:	2c 83       	std	Y+4, r18	; 0x04
    3166:	09 83       	std	Y+1, r16	; 0x01
    3168:	1a 83       	std	Y+2, r17	; 0x02
    316a:	97 ff       	sbrs	r25, 7
    316c:	02 c0       	rjmp	.+4      	; 0x3172 <snprintf+0x2a>
    316e:	80 e0       	ldi	r24, 0x00	; 0
    3170:	90 e8       	ldi	r25, 0x80	; 128
    3172:	01 97       	sbiw	r24, 0x01	; 1
    3174:	8d 83       	std	Y+5, r24	; 0x05
    3176:	9e 83       	std	Y+6, r25	; 0x06
    3178:	ae 01       	movw	r20, r28
    317a:	44 5e       	subi	r20, 0xE4	; 228
    317c:	5f 4f       	sbci	r21, 0xFF	; 255
    317e:	6a 8d       	ldd	r22, Y+26	; 0x1a
    3180:	7b 8d       	ldd	r23, Y+27	; 0x1b
    3182:	ce 01       	movw	r24, r28
    3184:	01 96       	adiw	r24, 0x01	; 1
    3186:	16 d0       	rcall	.+44     	; 0x31b4 <vfprintf>
    3188:	4d 81       	ldd	r20, Y+5	; 0x05
    318a:	5e 81       	ldd	r21, Y+6	; 0x06
    318c:	57 fd       	sbrc	r21, 7
    318e:	0a c0       	rjmp	.+20     	; 0x31a4 <snprintf+0x5c>
    3190:	2f 81       	ldd	r18, Y+7	; 0x07
    3192:	38 85       	ldd	r19, Y+8	; 0x08
    3194:	42 17       	cp	r20, r18
    3196:	53 07       	cpc	r21, r19
    3198:	0c f4       	brge	.+2      	; 0x319c <snprintf+0x54>
    319a:	9a 01       	movw	r18, r20
    319c:	f8 01       	movw	r30, r16
    319e:	e2 0f       	add	r30, r18
    31a0:	f3 1f       	adc	r31, r19
    31a2:	10 82       	st	Z, r1
    31a4:	2e 96       	adiw	r28, 0x0e	; 14
    31a6:	cd bf       	out	0x3d, r28	; 61
    31a8:	de bf       	out	0x3e, r29	; 62
    31aa:	df 91       	pop	r29
    31ac:	cf 91       	pop	r28
    31ae:	1f 91       	pop	r17
    31b0:	0f 91       	pop	r16
    31b2:	08 95       	ret

000031b4 <vfprintf>:
    31b4:	2f 92       	push	r2
    31b6:	3f 92       	push	r3
    31b8:	4f 92       	push	r4
    31ba:	5f 92       	push	r5
    31bc:	6f 92       	push	r6
    31be:	7f 92       	push	r7
    31c0:	8f 92       	push	r8
    31c2:	9f 92       	push	r9
    31c4:	af 92       	push	r10
    31c6:	bf 92       	push	r11
    31c8:	cf 92       	push	r12
    31ca:	df 92       	push	r13
    31cc:	ef 92       	push	r14
    31ce:	ff 92       	push	r15
    31d0:	0f 93       	push	r16
    31d2:	1f 93       	push	r17
    31d4:	cf 93       	push	r28
    31d6:	df 93       	push	r29
    31d8:	cd b7       	in	r28, 0x3d	; 61
    31da:	de b7       	in	r29, 0x3e	; 62
    31dc:	2b 97       	sbiw	r28, 0x0b	; 11
    31de:	cd bf       	out	0x3d, r28	; 61
    31e0:	de bf       	out	0x3e, r29	; 62
    31e2:	6c 01       	movw	r12, r24
    31e4:	7b 01       	movw	r14, r22
    31e6:	8a 01       	movw	r16, r20
    31e8:	fc 01       	movw	r30, r24
    31ea:	16 82       	std	Z+6, r1	; 0x06
    31ec:	17 82       	std	Z+7, r1	; 0x07
    31ee:	83 81       	ldd	r24, Z+3	; 0x03
    31f0:	81 ff       	sbrs	r24, 1
    31f2:	bf c1       	rjmp	.+894    	; 0x3572 <vfprintf+0x3be>
    31f4:	ce 01       	movw	r24, r28
    31f6:	01 96       	adiw	r24, 0x01	; 1
    31f8:	3c 01       	movw	r6, r24
    31fa:	f6 01       	movw	r30, r12
    31fc:	93 81       	ldd	r25, Z+3	; 0x03
    31fe:	f7 01       	movw	r30, r14
    3200:	93 fd       	sbrc	r25, 3
    3202:	85 91       	lpm	r24, Z+
    3204:	93 ff       	sbrs	r25, 3
    3206:	81 91       	ld	r24, Z+
    3208:	7f 01       	movw	r14, r30
    320a:	88 23       	and	r24, r24
    320c:	09 f4       	brne	.+2      	; 0x3210 <vfprintf+0x5c>
    320e:	ad c1       	rjmp	.+858    	; 0x356a <vfprintf+0x3b6>
    3210:	85 32       	cpi	r24, 0x25	; 37
    3212:	39 f4       	brne	.+14     	; 0x3222 <vfprintf+0x6e>
    3214:	93 fd       	sbrc	r25, 3
    3216:	85 91       	lpm	r24, Z+
    3218:	93 ff       	sbrs	r25, 3
    321a:	81 91       	ld	r24, Z+
    321c:	7f 01       	movw	r14, r30
    321e:	85 32       	cpi	r24, 0x25	; 37
    3220:	21 f4       	brne	.+8      	; 0x322a <vfprintf+0x76>
    3222:	b6 01       	movw	r22, r12
    3224:	90 e0       	ldi	r25, 0x00	; 0
    3226:	d3 d1       	rcall	.+934    	; 0x35ce <fputc>
    3228:	e8 cf       	rjmp	.-48     	; 0x31fa <vfprintf+0x46>
    322a:	91 2c       	mov	r9, r1
    322c:	21 2c       	mov	r2, r1
    322e:	31 2c       	mov	r3, r1
    3230:	ff e1       	ldi	r31, 0x1F	; 31
    3232:	f3 15       	cp	r31, r3
    3234:	d8 f0       	brcs	.+54     	; 0x326c <vfprintf+0xb8>
    3236:	8b 32       	cpi	r24, 0x2B	; 43
    3238:	79 f0       	breq	.+30     	; 0x3258 <vfprintf+0xa4>
    323a:	38 f4       	brcc	.+14     	; 0x324a <vfprintf+0x96>
    323c:	80 32       	cpi	r24, 0x20	; 32
    323e:	79 f0       	breq	.+30     	; 0x325e <vfprintf+0xaa>
    3240:	83 32       	cpi	r24, 0x23	; 35
    3242:	a1 f4       	brne	.+40     	; 0x326c <vfprintf+0xb8>
    3244:	23 2d       	mov	r18, r3
    3246:	20 61       	ori	r18, 0x10	; 16
    3248:	1d c0       	rjmp	.+58     	; 0x3284 <vfprintf+0xd0>
    324a:	8d 32       	cpi	r24, 0x2D	; 45
    324c:	61 f0       	breq	.+24     	; 0x3266 <vfprintf+0xb2>
    324e:	80 33       	cpi	r24, 0x30	; 48
    3250:	69 f4       	brne	.+26     	; 0x326c <vfprintf+0xb8>
    3252:	23 2d       	mov	r18, r3
    3254:	21 60       	ori	r18, 0x01	; 1
    3256:	16 c0       	rjmp	.+44     	; 0x3284 <vfprintf+0xd0>
    3258:	83 2d       	mov	r24, r3
    325a:	82 60       	ori	r24, 0x02	; 2
    325c:	38 2e       	mov	r3, r24
    325e:	e3 2d       	mov	r30, r3
    3260:	e4 60       	ori	r30, 0x04	; 4
    3262:	3e 2e       	mov	r3, r30
    3264:	2a c0       	rjmp	.+84     	; 0x32ba <vfprintf+0x106>
    3266:	f3 2d       	mov	r31, r3
    3268:	f8 60       	ori	r31, 0x08	; 8
    326a:	1d c0       	rjmp	.+58     	; 0x32a6 <vfprintf+0xf2>
    326c:	37 fc       	sbrc	r3, 7
    326e:	2d c0       	rjmp	.+90     	; 0x32ca <vfprintf+0x116>
    3270:	20 ed       	ldi	r18, 0xD0	; 208
    3272:	28 0f       	add	r18, r24
    3274:	2a 30       	cpi	r18, 0x0A	; 10
    3276:	40 f0       	brcs	.+16     	; 0x3288 <vfprintf+0xd4>
    3278:	8e 32       	cpi	r24, 0x2E	; 46
    327a:	b9 f4       	brne	.+46     	; 0x32aa <vfprintf+0xf6>
    327c:	36 fc       	sbrc	r3, 6
    327e:	75 c1       	rjmp	.+746    	; 0x356a <vfprintf+0x3b6>
    3280:	23 2d       	mov	r18, r3
    3282:	20 64       	ori	r18, 0x40	; 64
    3284:	32 2e       	mov	r3, r18
    3286:	19 c0       	rjmp	.+50     	; 0x32ba <vfprintf+0x106>
    3288:	36 fe       	sbrs	r3, 6
    328a:	06 c0       	rjmp	.+12     	; 0x3298 <vfprintf+0xe4>
    328c:	8a e0       	ldi	r24, 0x0A	; 10
    328e:	98 9e       	mul	r9, r24
    3290:	20 0d       	add	r18, r0
    3292:	11 24       	eor	r1, r1
    3294:	92 2e       	mov	r9, r18
    3296:	11 c0       	rjmp	.+34     	; 0x32ba <vfprintf+0x106>
    3298:	ea e0       	ldi	r30, 0x0A	; 10
    329a:	2e 9e       	mul	r2, r30
    329c:	20 0d       	add	r18, r0
    329e:	11 24       	eor	r1, r1
    32a0:	22 2e       	mov	r2, r18
    32a2:	f3 2d       	mov	r31, r3
    32a4:	f0 62       	ori	r31, 0x20	; 32
    32a6:	3f 2e       	mov	r3, r31
    32a8:	08 c0       	rjmp	.+16     	; 0x32ba <vfprintf+0x106>
    32aa:	8c 36       	cpi	r24, 0x6C	; 108
    32ac:	21 f4       	brne	.+8      	; 0x32b6 <vfprintf+0x102>
    32ae:	83 2d       	mov	r24, r3
    32b0:	80 68       	ori	r24, 0x80	; 128
    32b2:	38 2e       	mov	r3, r24
    32b4:	02 c0       	rjmp	.+4      	; 0x32ba <vfprintf+0x106>
    32b6:	88 36       	cpi	r24, 0x68	; 104
    32b8:	41 f4       	brne	.+16     	; 0x32ca <vfprintf+0x116>
    32ba:	f7 01       	movw	r30, r14
    32bc:	93 fd       	sbrc	r25, 3
    32be:	85 91       	lpm	r24, Z+
    32c0:	93 ff       	sbrs	r25, 3
    32c2:	81 91       	ld	r24, Z+
    32c4:	7f 01       	movw	r14, r30
    32c6:	81 11       	cpse	r24, r1
    32c8:	b3 cf       	rjmp	.-154    	; 0x3230 <vfprintf+0x7c>
    32ca:	98 2f       	mov	r25, r24
    32cc:	9f 7d       	andi	r25, 0xDF	; 223
    32ce:	95 54       	subi	r25, 0x45	; 69
    32d0:	93 30       	cpi	r25, 0x03	; 3
    32d2:	28 f4       	brcc	.+10     	; 0x32de <vfprintf+0x12a>
    32d4:	0c 5f       	subi	r16, 0xFC	; 252
    32d6:	1f 4f       	sbci	r17, 0xFF	; 255
    32d8:	9f e3       	ldi	r25, 0x3F	; 63
    32da:	99 83       	std	Y+1, r25	; 0x01
    32dc:	0d c0       	rjmp	.+26     	; 0x32f8 <vfprintf+0x144>
    32de:	83 36       	cpi	r24, 0x63	; 99
    32e0:	31 f0       	breq	.+12     	; 0x32ee <vfprintf+0x13a>
    32e2:	83 37       	cpi	r24, 0x73	; 115
    32e4:	71 f0       	breq	.+28     	; 0x3302 <vfprintf+0x14e>
    32e6:	83 35       	cpi	r24, 0x53	; 83
    32e8:	09 f0       	breq	.+2      	; 0x32ec <vfprintf+0x138>
    32ea:	55 c0       	rjmp	.+170    	; 0x3396 <vfprintf+0x1e2>
    32ec:	20 c0       	rjmp	.+64     	; 0x332e <vfprintf+0x17a>
    32ee:	f8 01       	movw	r30, r16
    32f0:	80 81       	ld	r24, Z
    32f2:	89 83       	std	Y+1, r24	; 0x01
    32f4:	0e 5f       	subi	r16, 0xFE	; 254
    32f6:	1f 4f       	sbci	r17, 0xFF	; 255
    32f8:	88 24       	eor	r8, r8
    32fa:	83 94       	inc	r8
    32fc:	91 2c       	mov	r9, r1
    32fe:	53 01       	movw	r10, r6
    3300:	12 c0       	rjmp	.+36     	; 0x3326 <vfprintf+0x172>
    3302:	28 01       	movw	r4, r16
    3304:	f2 e0       	ldi	r31, 0x02	; 2
    3306:	4f 0e       	add	r4, r31
    3308:	51 1c       	adc	r5, r1
    330a:	f8 01       	movw	r30, r16
    330c:	a0 80       	ld	r10, Z
    330e:	b1 80       	ldd	r11, Z+1	; 0x01
    3310:	36 fe       	sbrs	r3, 6
    3312:	03 c0       	rjmp	.+6      	; 0x331a <vfprintf+0x166>
    3314:	69 2d       	mov	r22, r9
    3316:	70 e0       	ldi	r23, 0x00	; 0
    3318:	02 c0       	rjmp	.+4      	; 0x331e <vfprintf+0x16a>
    331a:	6f ef       	ldi	r22, 0xFF	; 255
    331c:	7f ef       	ldi	r23, 0xFF	; 255
    331e:	c5 01       	movw	r24, r10
    3320:	4b d1       	rcall	.+662    	; 0x35b8 <strnlen>
    3322:	4c 01       	movw	r8, r24
    3324:	82 01       	movw	r16, r4
    3326:	f3 2d       	mov	r31, r3
    3328:	ff 77       	andi	r31, 0x7F	; 127
    332a:	3f 2e       	mov	r3, r31
    332c:	15 c0       	rjmp	.+42     	; 0x3358 <vfprintf+0x1a4>
    332e:	28 01       	movw	r4, r16
    3330:	22 e0       	ldi	r18, 0x02	; 2
    3332:	42 0e       	add	r4, r18
    3334:	51 1c       	adc	r5, r1
    3336:	f8 01       	movw	r30, r16
    3338:	a0 80       	ld	r10, Z
    333a:	b1 80       	ldd	r11, Z+1	; 0x01
    333c:	36 fe       	sbrs	r3, 6
    333e:	03 c0       	rjmp	.+6      	; 0x3346 <vfprintf+0x192>
    3340:	69 2d       	mov	r22, r9
    3342:	70 e0       	ldi	r23, 0x00	; 0
    3344:	02 c0       	rjmp	.+4      	; 0x334a <vfprintf+0x196>
    3346:	6f ef       	ldi	r22, 0xFF	; 255
    3348:	7f ef       	ldi	r23, 0xFF	; 255
    334a:	c5 01       	movw	r24, r10
    334c:	2a d1       	rcall	.+596    	; 0x35a2 <strnlen_P>
    334e:	4c 01       	movw	r8, r24
    3350:	f3 2d       	mov	r31, r3
    3352:	f0 68       	ori	r31, 0x80	; 128
    3354:	3f 2e       	mov	r3, r31
    3356:	82 01       	movw	r16, r4
    3358:	33 fc       	sbrc	r3, 3
    335a:	19 c0       	rjmp	.+50     	; 0x338e <vfprintf+0x1da>
    335c:	82 2d       	mov	r24, r2
    335e:	90 e0       	ldi	r25, 0x00	; 0
    3360:	88 16       	cp	r8, r24
    3362:	99 06       	cpc	r9, r25
    3364:	a0 f4       	brcc	.+40     	; 0x338e <vfprintf+0x1da>
    3366:	b6 01       	movw	r22, r12
    3368:	80 e2       	ldi	r24, 0x20	; 32
    336a:	90 e0       	ldi	r25, 0x00	; 0
    336c:	30 d1       	rcall	.+608    	; 0x35ce <fputc>
    336e:	2a 94       	dec	r2
    3370:	f5 cf       	rjmp	.-22     	; 0x335c <vfprintf+0x1a8>
    3372:	f5 01       	movw	r30, r10
    3374:	37 fc       	sbrc	r3, 7
    3376:	85 91       	lpm	r24, Z+
    3378:	37 fe       	sbrs	r3, 7
    337a:	81 91       	ld	r24, Z+
    337c:	5f 01       	movw	r10, r30
    337e:	b6 01       	movw	r22, r12
    3380:	90 e0       	ldi	r25, 0x00	; 0
    3382:	25 d1       	rcall	.+586    	; 0x35ce <fputc>
    3384:	21 10       	cpse	r2, r1
    3386:	2a 94       	dec	r2
    3388:	21 e0       	ldi	r18, 0x01	; 1
    338a:	82 1a       	sub	r8, r18
    338c:	91 08       	sbc	r9, r1
    338e:	81 14       	cp	r8, r1
    3390:	91 04       	cpc	r9, r1
    3392:	79 f7       	brne	.-34     	; 0x3372 <vfprintf+0x1be>
    3394:	e1 c0       	rjmp	.+450    	; 0x3558 <vfprintf+0x3a4>
    3396:	84 36       	cpi	r24, 0x64	; 100
    3398:	11 f0       	breq	.+4      	; 0x339e <vfprintf+0x1ea>
    339a:	89 36       	cpi	r24, 0x69	; 105
    339c:	39 f5       	brne	.+78     	; 0x33ec <vfprintf+0x238>
    339e:	f8 01       	movw	r30, r16
    33a0:	37 fe       	sbrs	r3, 7
    33a2:	07 c0       	rjmp	.+14     	; 0x33b2 <vfprintf+0x1fe>
    33a4:	60 81       	ld	r22, Z
    33a6:	71 81       	ldd	r23, Z+1	; 0x01
    33a8:	82 81       	ldd	r24, Z+2	; 0x02
    33aa:	93 81       	ldd	r25, Z+3	; 0x03
    33ac:	0c 5f       	subi	r16, 0xFC	; 252
    33ae:	1f 4f       	sbci	r17, 0xFF	; 255
    33b0:	08 c0       	rjmp	.+16     	; 0x33c2 <vfprintf+0x20e>
    33b2:	60 81       	ld	r22, Z
    33b4:	71 81       	ldd	r23, Z+1	; 0x01
    33b6:	07 2e       	mov	r0, r23
    33b8:	00 0c       	add	r0, r0
    33ba:	88 0b       	sbc	r24, r24
    33bc:	99 0b       	sbc	r25, r25
    33be:	0e 5f       	subi	r16, 0xFE	; 254
    33c0:	1f 4f       	sbci	r17, 0xFF	; 255
    33c2:	f3 2d       	mov	r31, r3
    33c4:	ff 76       	andi	r31, 0x6F	; 111
    33c6:	3f 2e       	mov	r3, r31
    33c8:	97 ff       	sbrs	r25, 7
    33ca:	09 c0       	rjmp	.+18     	; 0x33de <vfprintf+0x22a>
    33cc:	90 95       	com	r25
    33ce:	80 95       	com	r24
    33d0:	70 95       	com	r23
    33d2:	61 95       	neg	r22
    33d4:	7f 4f       	sbci	r23, 0xFF	; 255
    33d6:	8f 4f       	sbci	r24, 0xFF	; 255
    33d8:	9f 4f       	sbci	r25, 0xFF	; 255
    33da:	f0 68       	ori	r31, 0x80	; 128
    33dc:	3f 2e       	mov	r3, r31
    33de:	2a e0       	ldi	r18, 0x0A	; 10
    33e0:	30 e0       	ldi	r19, 0x00	; 0
    33e2:	a3 01       	movw	r20, r6
    33e4:	30 d1       	rcall	.+608    	; 0x3646 <__ultoa_invert>
    33e6:	88 2e       	mov	r8, r24
    33e8:	86 18       	sub	r8, r6
    33ea:	44 c0       	rjmp	.+136    	; 0x3474 <vfprintf+0x2c0>
    33ec:	85 37       	cpi	r24, 0x75	; 117
    33ee:	31 f4       	brne	.+12     	; 0x33fc <vfprintf+0x248>
    33f0:	23 2d       	mov	r18, r3
    33f2:	2f 7e       	andi	r18, 0xEF	; 239
    33f4:	b2 2e       	mov	r11, r18
    33f6:	2a e0       	ldi	r18, 0x0A	; 10
    33f8:	30 e0       	ldi	r19, 0x00	; 0
    33fa:	25 c0       	rjmp	.+74     	; 0x3446 <vfprintf+0x292>
    33fc:	93 2d       	mov	r25, r3
    33fe:	99 7f       	andi	r25, 0xF9	; 249
    3400:	b9 2e       	mov	r11, r25
    3402:	8f 36       	cpi	r24, 0x6F	; 111
    3404:	c1 f0       	breq	.+48     	; 0x3436 <vfprintf+0x282>
    3406:	18 f4       	brcc	.+6      	; 0x340e <vfprintf+0x25a>
    3408:	88 35       	cpi	r24, 0x58	; 88
    340a:	79 f0       	breq	.+30     	; 0x342a <vfprintf+0x276>
    340c:	ae c0       	rjmp	.+348    	; 0x356a <vfprintf+0x3b6>
    340e:	80 37       	cpi	r24, 0x70	; 112
    3410:	19 f0       	breq	.+6      	; 0x3418 <vfprintf+0x264>
    3412:	88 37       	cpi	r24, 0x78	; 120
    3414:	21 f0       	breq	.+8      	; 0x341e <vfprintf+0x26a>
    3416:	a9 c0       	rjmp	.+338    	; 0x356a <vfprintf+0x3b6>
    3418:	e9 2f       	mov	r30, r25
    341a:	e0 61       	ori	r30, 0x10	; 16
    341c:	be 2e       	mov	r11, r30
    341e:	b4 fe       	sbrs	r11, 4
    3420:	0d c0       	rjmp	.+26     	; 0x343c <vfprintf+0x288>
    3422:	fb 2d       	mov	r31, r11
    3424:	f4 60       	ori	r31, 0x04	; 4
    3426:	bf 2e       	mov	r11, r31
    3428:	09 c0       	rjmp	.+18     	; 0x343c <vfprintf+0x288>
    342a:	34 fe       	sbrs	r3, 4
    342c:	0a c0       	rjmp	.+20     	; 0x3442 <vfprintf+0x28e>
    342e:	29 2f       	mov	r18, r25
    3430:	26 60       	ori	r18, 0x06	; 6
    3432:	b2 2e       	mov	r11, r18
    3434:	06 c0       	rjmp	.+12     	; 0x3442 <vfprintf+0x28e>
    3436:	28 e0       	ldi	r18, 0x08	; 8
    3438:	30 e0       	ldi	r19, 0x00	; 0
    343a:	05 c0       	rjmp	.+10     	; 0x3446 <vfprintf+0x292>
    343c:	20 e1       	ldi	r18, 0x10	; 16
    343e:	30 e0       	ldi	r19, 0x00	; 0
    3440:	02 c0       	rjmp	.+4      	; 0x3446 <vfprintf+0x292>
    3442:	20 e1       	ldi	r18, 0x10	; 16
    3444:	32 e0       	ldi	r19, 0x02	; 2
    3446:	f8 01       	movw	r30, r16
    3448:	b7 fe       	sbrs	r11, 7
    344a:	07 c0       	rjmp	.+14     	; 0x345a <vfprintf+0x2a6>
    344c:	60 81       	ld	r22, Z
    344e:	71 81       	ldd	r23, Z+1	; 0x01
    3450:	82 81       	ldd	r24, Z+2	; 0x02
    3452:	93 81       	ldd	r25, Z+3	; 0x03
    3454:	0c 5f       	subi	r16, 0xFC	; 252
    3456:	1f 4f       	sbci	r17, 0xFF	; 255
    3458:	06 c0       	rjmp	.+12     	; 0x3466 <vfprintf+0x2b2>
    345a:	60 81       	ld	r22, Z
    345c:	71 81       	ldd	r23, Z+1	; 0x01
    345e:	80 e0       	ldi	r24, 0x00	; 0
    3460:	90 e0       	ldi	r25, 0x00	; 0
    3462:	0e 5f       	subi	r16, 0xFE	; 254
    3464:	1f 4f       	sbci	r17, 0xFF	; 255
    3466:	a3 01       	movw	r20, r6
    3468:	ee d0       	rcall	.+476    	; 0x3646 <__ultoa_invert>
    346a:	88 2e       	mov	r8, r24
    346c:	86 18       	sub	r8, r6
    346e:	fb 2d       	mov	r31, r11
    3470:	ff 77       	andi	r31, 0x7F	; 127
    3472:	3f 2e       	mov	r3, r31
    3474:	36 fe       	sbrs	r3, 6
    3476:	0d c0       	rjmp	.+26     	; 0x3492 <vfprintf+0x2de>
    3478:	23 2d       	mov	r18, r3
    347a:	2e 7f       	andi	r18, 0xFE	; 254
    347c:	a2 2e       	mov	r10, r18
    347e:	89 14       	cp	r8, r9
    3480:	58 f4       	brcc	.+22     	; 0x3498 <vfprintf+0x2e4>
    3482:	34 fe       	sbrs	r3, 4
    3484:	0b c0       	rjmp	.+22     	; 0x349c <vfprintf+0x2e8>
    3486:	32 fc       	sbrc	r3, 2
    3488:	09 c0       	rjmp	.+18     	; 0x349c <vfprintf+0x2e8>
    348a:	83 2d       	mov	r24, r3
    348c:	8e 7e       	andi	r24, 0xEE	; 238
    348e:	a8 2e       	mov	r10, r24
    3490:	05 c0       	rjmp	.+10     	; 0x349c <vfprintf+0x2e8>
    3492:	b8 2c       	mov	r11, r8
    3494:	a3 2c       	mov	r10, r3
    3496:	03 c0       	rjmp	.+6      	; 0x349e <vfprintf+0x2ea>
    3498:	b8 2c       	mov	r11, r8
    349a:	01 c0       	rjmp	.+2      	; 0x349e <vfprintf+0x2ea>
    349c:	b9 2c       	mov	r11, r9
    349e:	a4 fe       	sbrs	r10, 4
    34a0:	0f c0       	rjmp	.+30     	; 0x34c0 <vfprintf+0x30c>
    34a2:	fe 01       	movw	r30, r28
    34a4:	e8 0d       	add	r30, r8
    34a6:	f1 1d       	adc	r31, r1
    34a8:	80 81       	ld	r24, Z
    34aa:	80 33       	cpi	r24, 0x30	; 48
    34ac:	21 f4       	brne	.+8      	; 0x34b6 <vfprintf+0x302>
    34ae:	9a 2d       	mov	r25, r10
    34b0:	99 7e       	andi	r25, 0xE9	; 233
    34b2:	a9 2e       	mov	r10, r25
    34b4:	09 c0       	rjmp	.+18     	; 0x34c8 <vfprintf+0x314>
    34b6:	a2 fe       	sbrs	r10, 2
    34b8:	06 c0       	rjmp	.+12     	; 0x34c6 <vfprintf+0x312>
    34ba:	b3 94       	inc	r11
    34bc:	b3 94       	inc	r11
    34be:	04 c0       	rjmp	.+8      	; 0x34c8 <vfprintf+0x314>
    34c0:	8a 2d       	mov	r24, r10
    34c2:	86 78       	andi	r24, 0x86	; 134
    34c4:	09 f0       	breq	.+2      	; 0x34c8 <vfprintf+0x314>
    34c6:	b3 94       	inc	r11
    34c8:	a3 fc       	sbrc	r10, 3
    34ca:	10 c0       	rjmp	.+32     	; 0x34ec <vfprintf+0x338>
    34cc:	a0 fe       	sbrs	r10, 0
    34ce:	06 c0       	rjmp	.+12     	; 0x34dc <vfprintf+0x328>
    34d0:	b2 14       	cp	r11, r2
    34d2:	80 f4       	brcc	.+32     	; 0x34f4 <vfprintf+0x340>
    34d4:	28 0c       	add	r2, r8
    34d6:	92 2c       	mov	r9, r2
    34d8:	9b 18       	sub	r9, r11
    34da:	0d c0       	rjmp	.+26     	; 0x34f6 <vfprintf+0x342>
    34dc:	b2 14       	cp	r11, r2
    34de:	58 f4       	brcc	.+22     	; 0x34f6 <vfprintf+0x342>
    34e0:	b6 01       	movw	r22, r12
    34e2:	80 e2       	ldi	r24, 0x20	; 32
    34e4:	90 e0       	ldi	r25, 0x00	; 0
    34e6:	73 d0       	rcall	.+230    	; 0x35ce <fputc>
    34e8:	b3 94       	inc	r11
    34ea:	f8 cf       	rjmp	.-16     	; 0x34dc <vfprintf+0x328>
    34ec:	b2 14       	cp	r11, r2
    34ee:	18 f4       	brcc	.+6      	; 0x34f6 <vfprintf+0x342>
    34f0:	2b 18       	sub	r2, r11
    34f2:	02 c0       	rjmp	.+4      	; 0x34f8 <vfprintf+0x344>
    34f4:	98 2c       	mov	r9, r8
    34f6:	21 2c       	mov	r2, r1
    34f8:	a4 fe       	sbrs	r10, 4
    34fa:	0f c0       	rjmp	.+30     	; 0x351a <vfprintf+0x366>
    34fc:	b6 01       	movw	r22, r12
    34fe:	80 e3       	ldi	r24, 0x30	; 48
    3500:	90 e0       	ldi	r25, 0x00	; 0
    3502:	65 d0       	rcall	.+202    	; 0x35ce <fputc>
    3504:	a2 fe       	sbrs	r10, 2
    3506:	16 c0       	rjmp	.+44     	; 0x3534 <vfprintf+0x380>
    3508:	a1 fc       	sbrc	r10, 1
    350a:	03 c0       	rjmp	.+6      	; 0x3512 <vfprintf+0x35e>
    350c:	88 e7       	ldi	r24, 0x78	; 120
    350e:	90 e0       	ldi	r25, 0x00	; 0
    3510:	02 c0       	rjmp	.+4      	; 0x3516 <vfprintf+0x362>
    3512:	88 e5       	ldi	r24, 0x58	; 88
    3514:	90 e0       	ldi	r25, 0x00	; 0
    3516:	b6 01       	movw	r22, r12
    3518:	0c c0       	rjmp	.+24     	; 0x3532 <vfprintf+0x37e>
    351a:	8a 2d       	mov	r24, r10
    351c:	86 78       	andi	r24, 0x86	; 134
    351e:	51 f0       	breq	.+20     	; 0x3534 <vfprintf+0x380>
    3520:	a1 fe       	sbrs	r10, 1
    3522:	02 c0       	rjmp	.+4      	; 0x3528 <vfprintf+0x374>
    3524:	8b e2       	ldi	r24, 0x2B	; 43
    3526:	01 c0       	rjmp	.+2      	; 0x352a <vfprintf+0x376>
    3528:	80 e2       	ldi	r24, 0x20	; 32
    352a:	a7 fc       	sbrc	r10, 7
    352c:	8d e2       	ldi	r24, 0x2D	; 45
    352e:	b6 01       	movw	r22, r12
    3530:	90 e0       	ldi	r25, 0x00	; 0
    3532:	4d d0       	rcall	.+154    	; 0x35ce <fputc>
    3534:	89 14       	cp	r8, r9
    3536:	30 f4       	brcc	.+12     	; 0x3544 <vfprintf+0x390>
    3538:	b6 01       	movw	r22, r12
    353a:	80 e3       	ldi	r24, 0x30	; 48
    353c:	90 e0       	ldi	r25, 0x00	; 0
    353e:	47 d0       	rcall	.+142    	; 0x35ce <fputc>
    3540:	9a 94       	dec	r9
    3542:	f8 cf       	rjmp	.-16     	; 0x3534 <vfprintf+0x380>
    3544:	8a 94       	dec	r8
    3546:	f3 01       	movw	r30, r6
    3548:	e8 0d       	add	r30, r8
    354a:	f1 1d       	adc	r31, r1
    354c:	80 81       	ld	r24, Z
    354e:	b6 01       	movw	r22, r12
    3550:	90 e0       	ldi	r25, 0x00	; 0
    3552:	3d d0       	rcall	.+122    	; 0x35ce <fputc>
    3554:	81 10       	cpse	r8, r1
    3556:	f6 cf       	rjmp	.-20     	; 0x3544 <vfprintf+0x390>
    3558:	22 20       	and	r2, r2
    355a:	09 f4       	brne	.+2      	; 0x355e <vfprintf+0x3aa>
    355c:	4e ce       	rjmp	.-868    	; 0x31fa <vfprintf+0x46>
    355e:	b6 01       	movw	r22, r12
    3560:	80 e2       	ldi	r24, 0x20	; 32
    3562:	90 e0       	ldi	r25, 0x00	; 0
    3564:	34 d0       	rcall	.+104    	; 0x35ce <fputc>
    3566:	2a 94       	dec	r2
    3568:	f7 cf       	rjmp	.-18     	; 0x3558 <vfprintf+0x3a4>
    356a:	f6 01       	movw	r30, r12
    356c:	86 81       	ldd	r24, Z+6	; 0x06
    356e:	97 81       	ldd	r25, Z+7	; 0x07
    3570:	02 c0       	rjmp	.+4      	; 0x3576 <vfprintf+0x3c2>
    3572:	8f ef       	ldi	r24, 0xFF	; 255
    3574:	9f ef       	ldi	r25, 0xFF	; 255
    3576:	2b 96       	adiw	r28, 0x0b	; 11
    3578:	cd bf       	out	0x3d, r28	; 61
    357a:	de bf       	out	0x3e, r29	; 62
    357c:	df 91       	pop	r29
    357e:	cf 91       	pop	r28
    3580:	1f 91       	pop	r17
    3582:	0f 91       	pop	r16
    3584:	ff 90       	pop	r15
    3586:	ef 90       	pop	r14
    3588:	df 90       	pop	r13
    358a:	cf 90       	pop	r12
    358c:	bf 90       	pop	r11
    358e:	af 90       	pop	r10
    3590:	9f 90       	pop	r9
    3592:	8f 90       	pop	r8
    3594:	7f 90       	pop	r7
    3596:	6f 90       	pop	r6
    3598:	5f 90       	pop	r5
    359a:	4f 90       	pop	r4
    359c:	3f 90       	pop	r3
    359e:	2f 90       	pop	r2
    35a0:	08 95       	ret

000035a2 <strnlen_P>:
    35a2:	fc 01       	movw	r30, r24
    35a4:	05 90       	lpm	r0, Z+
    35a6:	61 50       	subi	r22, 0x01	; 1
    35a8:	70 40       	sbci	r23, 0x00	; 0
    35aa:	01 10       	cpse	r0, r1
    35ac:	d8 f7       	brcc	.-10     	; 0x35a4 <strnlen_P+0x2>
    35ae:	80 95       	com	r24
    35b0:	90 95       	com	r25
    35b2:	8e 0f       	add	r24, r30
    35b4:	9f 1f       	adc	r25, r31
    35b6:	08 95       	ret

000035b8 <strnlen>:
    35b8:	fc 01       	movw	r30, r24
    35ba:	61 50       	subi	r22, 0x01	; 1
    35bc:	70 40       	sbci	r23, 0x00	; 0
    35be:	01 90       	ld	r0, Z+
    35c0:	01 10       	cpse	r0, r1
    35c2:	d8 f7       	brcc	.-10     	; 0x35ba <strnlen+0x2>
    35c4:	80 95       	com	r24
    35c6:	90 95       	com	r25
    35c8:	8e 0f       	add	r24, r30
    35ca:	9f 1f       	adc	r25, r31
    35cc:	08 95       	ret

000035ce <fputc>:
    35ce:	0f 93       	push	r16
    35d0:	1f 93       	push	r17
    35d2:	cf 93       	push	r28
    35d4:	df 93       	push	r29
    35d6:	fb 01       	movw	r30, r22
    35d8:	23 81       	ldd	r18, Z+3	; 0x03
    35da:	21 fd       	sbrc	r18, 1
    35dc:	03 c0       	rjmp	.+6      	; 0x35e4 <fputc+0x16>
    35de:	8f ef       	ldi	r24, 0xFF	; 255
    35e0:	9f ef       	ldi	r25, 0xFF	; 255
    35e2:	2c c0       	rjmp	.+88     	; 0x363c <fputc+0x6e>
    35e4:	22 ff       	sbrs	r18, 2
    35e6:	16 c0       	rjmp	.+44     	; 0x3614 <fputc+0x46>
    35e8:	46 81       	ldd	r20, Z+6	; 0x06
    35ea:	57 81       	ldd	r21, Z+7	; 0x07
    35ec:	24 81       	ldd	r18, Z+4	; 0x04
    35ee:	35 81       	ldd	r19, Z+5	; 0x05
    35f0:	42 17       	cp	r20, r18
    35f2:	53 07       	cpc	r21, r19
    35f4:	44 f4       	brge	.+16     	; 0x3606 <fputc+0x38>
    35f6:	a0 81       	ld	r26, Z
    35f8:	b1 81       	ldd	r27, Z+1	; 0x01
    35fa:	9d 01       	movw	r18, r26
    35fc:	2f 5f       	subi	r18, 0xFF	; 255
    35fe:	3f 4f       	sbci	r19, 0xFF	; 255
    3600:	20 83       	st	Z, r18
    3602:	31 83       	std	Z+1, r19	; 0x01
    3604:	8c 93       	st	X, r24
    3606:	26 81       	ldd	r18, Z+6	; 0x06
    3608:	37 81       	ldd	r19, Z+7	; 0x07
    360a:	2f 5f       	subi	r18, 0xFF	; 255
    360c:	3f 4f       	sbci	r19, 0xFF	; 255
    360e:	26 83       	std	Z+6, r18	; 0x06
    3610:	37 83       	std	Z+7, r19	; 0x07
    3612:	14 c0       	rjmp	.+40     	; 0x363c <fputc+0x6e>
    3614:	8b 01       	movw	r16, r22
    3616:	ec 01       	movw	r28, r24
    3618:	fb 01       	movw	r30, r22
    361a:	00 84       	ldd	r0, Z+8	; 0x08
    361c:	f1 85       	ldd	r31, Z+9	; 0x09
    361e:	e0 2d       	mov	r30, r0
    3620:	19 95       	eicall
    3622:	89 2b       	or	r24, r25
    3624:	e1 f6       	brne	.-72     	; 0x35de <fputc+0x10>
    3626:	d8 01       	movw	r26, r16
    3628:	16 96       	adiw	r26, 0x06	; 6
    362a:	8d 91       	ld	r24, X+
    362c:	9c 91       	ld	r25, X
    362e:	17 97       	sbiw	r26, 0x07	; 7
    3630:	01 96       	adiw	r24, 0x01	; 1
    3632:	16 96       	adiw	r26, 0x06	; 6
    3634:	8d 93       	st	X+, r24
    3636:	9c 93       	st	X, r25
    3638:	17 97       	sbiw	r26, 0x07	; 7
    363a:	ce 01       	movw	r24, r28
    363c:	df 91       	pop	r29
    363e:	cf 91       	pop	r28
    3640:	1f 91       	pop	r17
    3642:	0f 91       	pop	r16
    3644:	08 95       	ret

00003646 <__ultoa_invert>:
    3646:	fa 01       	movw	r30, r20
    3648:	aa 27       	eor	r26, r26
    364a:	28 30       	cpi	r18, 0x08	; 8
    364c:	51 f1       	breq	.+84     	; 0x36a2 <__ultoa_invert+0x5c>
    364e:	20 31       	cpi	r18, 0x10	; 16
    3650:	81 f1       	breq	.+96     	; 0x36b2 <__ultoa_invert+0x6c>
    3652:	e8 94       	clt
    3654:	6f 93       	push	r22
    3656:	6e 7f       	andi	r22, 0xFE	; 254
    3658:	6e 5f       	subi	r22, 0xFE	; 254
    365a:	7f 4f       	sbci	r23, 0xFF	; 255
    365c:	8f 4f       	sbci	r24, 0xFF	; 255
    365e:	9f 4f       	sbci	r25, 0xFF	; 255
    3660:	af 4f       	sbci	r26, 0xFF	; 255
    3662:	b1 e0       	ldi	r27, 0x01	; 1
    3664:	3e d0       	rcall	.+124    	; 0x36e2 <__ultoa_invert+0x9c>
    3666:	b4 e0       	ldi	r27, 0x04	; 4
    3668:	3c d0       	rcall	.+120    	; 0x36e2 <__ultoa_invert+0x9c>
    366a:	67 0f       	add	r22, r23
    366c:	78 1f       	adc	r23, r24
    366e:	89 1f       	adc	r24, r25
    3670:	9a 1f       	adc	r25, r26
    3672:	a1 1d       	adc	r26, r1
    3674:	68 0f       	add	r22, r24
    3676:	79 1f       	adc	r23, r25
    3678:	8a 1f       	adc	r24, r26
    367a:	91 1d       	adc	r25, r1
    367c:	a1 1d       	adc	r26, r1
    367e:	6a 0f       	add	r22, r26
    3680:	71 1d       	adc	r23, r1
    3682:	81 1d       	adc	r24, r1
    3684:	91 1d       	adc	r25, r1
    3686:	a1 1d       	adc	r26, r1
    3688:	20 d0       	rcall	.+64     	; 0x36ca <__ultoa_invert+0x84>
    368a:	09 f4       	brne	.+2      	; 0x368e <__ultoa_invert+0x48>
    368c:	68 94       	set
    368e:	3f 91       	pop	r19
    3690:	2a e0       	ldi	r18, 0x0A	; 10
    3692:	26 9f       	mul	r18, r22
    3694:	11 24       	eor	r1, r1
    3696:	30 19       	sub	r19, r0
    3698:	30 5d       	subi	r19, 0xD0	; 208
    369a:	31 93       	st	Z+, r19
    369c:	de f6       	brtc	.-74     	; 0x3654 <__ultoa_invert+0xe>
    369e:	cf 01       	movw	r24, r30
    36a0:	08 95       	ret
    36a2:	46 2f       	mov	r20, r22
    36a4:	47 70       	andi	r20, 0x07	; 7
    36a6:	40 5d       	subi	r20, 0xD0	; 208
    36a8:	41 93       	st	Z+, r20
    36aa:	b3 e0       	ldi	r27, 0x03	; 3
    36ac:	0f d0       	rcall	.+30     	; 0x36cc <__ultoa_invert+0x86>
    36ae:	c9 f7       	brne	.-14     	; 0x36a2 <__ultoa_invert+0x5c>
    36b0:	f6 cf       	rjmp	.-20     	; 0x369e <__ultoa_invert+0x58>
    36b2:	46 2f       	mov	r20, r22
    36b4:	4f 70       	andi	r20, 0x0F	; 15
    36b6:	40 5d       	subi	r20, 0xD0	; 208
    36b8:	4a 33       	cpi	r20, 0x3A	; 58
    36ba:	18 f0       	brcs	.+6      	; 0x36c2 <__ultoa_invert+0x7c>
    36bc:	49 5d       	subi	r20, 0xD9	; 217
    36be:	31 fd       	sbrc	r19, 1
    36c0:	40 52       	subi	r20, 0x20	; 32
    36c2:	41 93       	st	Z+, r20
    36c4:	02 d0       	rcall	.+4      	; 0x36ca <__ultoa_invert+0x84>
    36c6:	a9 f7       	brne	.-22     	; 0x36b2 <__ultoa_invert+0x6c>
    36c8:	ea cf       	rjmp	.-44     	; 0x369e <__ultoa_invert+0x58>
    36ca:	b4 e0       	ldi	r27, 0x04	; 4
    36cc:	a6 95       	lsr	r26
    36ce:	97 95       	ror	r25
    36d0:	87 95       	ror	r24
    36d2:	77 95       	ror	r23
    36d4:	67 95       	ror	r22
    36d6:	ba 95       	dec	r27
    36d8:	c9 f7       	brne	.-14     	; 0x36cc <__ultoa_invert+0x86>
    36da:	00 97       	sbiw	r24, 0x00	; 0
    36dc:	61 05       	cpc	r22, r1
    36de:	71 05       	cpc	r23, r1
    36e0:	08 95       	ret
    36e2:	9b 01       	movw	r18, r22
    36e4:	ac 01       	movw	r20, r24
    36e6:	0a 2e       	mov	r0, r26
    36e8:	06 94       	lsr	r0
    36ea:	57 95       	ror	r21
    36ec:	47 95       	ror	r20
    36ee:	37 95       	ror	r19
    36f0:	27 95       	ror	r18
    36f2:	ba 95       	dec	r27
    36f4:	c9 f7       	brne	.-14     	; 0x36e8 <__ultoa_invert+0xa2>
    36f6:	62 0f       	add	r22, r18
    36f8:	73 1f       	adc	r23, r19
    36fa:	84 1f       	adc	r24, r20
    36fc:	95 1f       	adc	r25, r21
    36fe:	a0 1d       	adc	r26, r0
    3700:	08 95       	ret

00003702 <_exit>:
    3702:	f8 94       	cli

00003704 <__stop_program>:
    3704:	ff cf       	rjmp	.-2      	; 0x3704 <__stop_program>
